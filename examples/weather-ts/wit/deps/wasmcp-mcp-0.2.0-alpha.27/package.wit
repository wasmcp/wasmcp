/// Model Context Protocol (MCP) is an open protocol that enables seamless integration between LLM applications and external data sources and tools.
/// https://modelcontextprotocol.io/specification/2025-06-18
package wasmcp:mcp@0.2.0-alpha.27;

/// Core type definitions for the Model Context Protocol, shared by other interfaces.
interface mcp-types {
  /// Role in a conversation
  enum role {
    user,
    assistant,
  }

  /// JSON value as a string
  /// This is a JSON-encoded value that should be parsed/validated by implementations
  type json-value = string;

  /// JSON object as a string
  /// This is a JSON-encoded object that should be parsed/validated by implementations
  type json-object = string;

  /// JSON Schema as a string
  /// This is a JSON Schema document that defines structure and validation rules
  type json-schema = string;

  /// Metadata fields for extensibility
  /// Key-value pairs where values are JSON-encoded strings
  type meta-fields = list<tuple<string, string>>;

  /// Icon specification for visual representation
  record icon {
    /// A standard URI pointing to an icon resource
    src: string,
    /// Optional override if the server's MIME type is missing or generic
    mime-type: option<string>,
    /// Size specification (e.g., "48x48", "any" for SVG, or "48x48 96x96")
    sizes: option<string>,
  }

  /// Annotations provide hints to clients about how to handle data
  record annotations {
    /// Who this data is intended for
    audience: option<list<role>>,
    /// Priority from 0.0 (least) to 1.0 (most important)
    /// Implementations SHOULD validate this is within [0.0, 1.0] range
    priority: option<f64>,
    /// ISO 8601 timestamp of last modification
    /// Format: YYYY-MM-DDTHH:mm:ss[.sss]Z or Â±HH:MM offset
    last-modified: option<string>,
  }

  /// Text content with optional annotations
  record text-content {
    text: string,
    /// Optional protocol-level metadata for this content block
    meta: option<json-object>,
    annotations: option<annotations>,
  }

  /// Image content as base64-encoded string
  record image-content {
    /// Base64-encoded image data
    data: string,
    /// MIME type (e.g., "image/png", "image/jpeg")
    mime-type: string,
    /// Optional protocol-level metadata for this content block
    meta: option<json-object>,
    annotations: option<annotations>,
  }

  /// Audio content as base64-encoded string
  record audio-content {
    /// Base64-encoded audio data
    data: string,
    /// MIME type (e.g., "audio/wav", "audio/mp3")
    mime-type: string,
    annotations: option<annotations>,
  }

  /// Raw resource representation (for resource links)
  record raw-resource {
    /// URI representing the resource location
    uri: string,
    /// Name of the resource
    name: string,
    /// Human-readable title of the resource
    title: option<string>,
    /// Optional description of the resource
    description: option<string>,
    /// MIME type of the resource content
    mime-type: option<string>,
    /// Size in bytes (before encoding), if known
    size: option<u32>,
    /// Optional list of icons for the resource
    icons: option<list<icon>>,
  }

  record text-resource-contents {
    uri: string,
    mime-type: option<string>,
    text: string,
    meta: option<json-object>,
  }

  record blob-resource-contents {
    uri: string,
    mime-type: option<string>,
    /// Base64-encoded binary data
    blob: string,
    meta: option<json-object>,
  }

  /// Resource contents can be either text or binary
  variant resource-contents {
    text(text-resource-contents),
    blob(blob-resource-contents),
  }

  /// Embedded resource content
  record embedded-resource {
    /// Optional protocol-level metadata for this content block
    meta: option<json-object>,
    /// The actual resource contents
    %resource: resource-contents,
    annotations: option<annotations>,
  }

  /// Content block types that can be included in messages
  variant content-block {
    text(text-content),
    image(image-content),
    audio(audio-content),
    %resource(embedded-resource),
    resource-link(raw-resource),
  }

  /// Standard JSON-RPC and MCP error codes
  variant error-code {
    /// JSON-RPC standard errors
    parse-error,
    /// -32700
    invalid-request,
    /// -32600
    method-not-found,
    /// -32601
    invalid-params,
    /// -32602
    internal-error,
    /// -32603
    /// MCP-specific errors
    resource-not-found,
    tool-not-found,
    prompt-not-found,
    unauthorized,
    rate-limited,
    timeout,
    cancelled,
    /// Custom error with specific code
    custom-code(s32),
  }

  /// Standard error structure
  record mcp-error {
    code: error-code,
    message: string,
    /// Additional error context (JSON-encoded)
    data: option<string>,
  }

  /// Progress token for tracking long-running operations
  type progress-token = string;

  /// JSON-RPC request ID
  /// Can be either a string or number in JSON-RPC
  variant request-id {
    str(string),
    num(s64),
  }

  /// Message role for LLM interactions
  enum message-role {
    user,
    assistant,
    system,
  }

  /// Hint for model selection
  record model-hint {
    /// Name pattern to match (e.g., "claude", "gpt-4")
    name: option<string>,
  }

  /// Model selection preferences for LLM sampling
  record model-preferences {
    /// Hints for model selection
    hints: option<list<model-hint>>,
    /// Priority for cost optimization (0.0-1.0)
    cost-priority: option<f64>,
    /// Priority for speed (0.0-1.0)
    speed-priority: option<f64>,
    /// Priority for intelligence/capability (0.0-1.0)
    intelligence-priority: option<f64>,
  }
}

/// Type definitions for authentication and authorization
interface authorization-types {
  use mcp-types.{meta-fields};

  /// Provider declares its authorization requirements
  /// This is returned by get-auth-config()
  /// and used by the transport to enforce authorization
  record provider-auth-config {
    /// Expected JWT issuer (REQUIRED for auth)
    expected-issuer: string,
    /// Expected JWT audiences (REQUIRED for auth - must have at least one)
    expected-audiences: list<string>,
    /// JWKS URI for key discovery (REQUIRED for auth)
    jwks-uri: string,
    /// Pass raw JWT token to tools via "jwt.token" meta field.
    pass-jwt: bool,
    /// Expected JWT subject - if set, only this exact subject is allowed
    expected-subject: option<string>,
    /// Optional Rego policy for complex authorization rules
    policy: option<string>,
    /// Optional data for policy evaluation
    policy-data: option<string>,
  }

  /// Authorization context passed between components after successful authorization
  record auth-context {
    /// OAuth client ID that made the request
    client-id: option<string>,
    /// Subject claim from the token - always present from validated JWT
    sub: string,
    /// OAuth scopes granted to this token
    scopes: list<string>,
    /// Issuer claim from the token - always present from validated JWT
    iss: string,
    /// Audience claim from token (aud) - always validated, can be multiple values
    aud: list<string>,
    /// Additional claims from token as key-value pairs
    claims: meta-fields,
    /// Expiration timestamp (Unix seconds) - always validated and required for security
    exp: u64,
    /// Issued at timestamp (Unix seconds)
    iat: option<u64>,
    /// Not before timestamp (Unix seconds)
    nbf: option<u64>,
    /// Raw JWT iff enabled by pass-jwt flag in provider-auth-config
    jwt: option<string>,
  }
}

/// Authorization capabilities are provided at the transport level, enabling MCP clients to make requests to restricted MCP servers on behalf of resource owners.
///
/// https://modelcontextprotocol.io/specification/2025-06-18/basic/authorization
interface authorization {
  use authorization-types.{provider-auth-config};

  /// Get provider's auth configuration
  /// The transport should enforce authorization
  get-auth-config: func() -> option<provider-auth-config>;

  /// Get cached JWKS for a given URI (optional - return none if not cached or not implemented)
  /// Allows providers to implement JWKS caching via WASI-KV or other persistence mechanisms
  /// The transport will call this before fetching from jwks-uri to check for cached keys
  jwks-cache-get: func(jwks-uri: string) -> option<string>;

  /// Cache JWKS for a given URI (optional - no-op if caching not implemented)
  /// The transport calls this after successfully fetching JWKS from jwks-uri
  /// Providers can implement caching via WASI-KV or other persistence mechanisms
  /// The jwks parameter contains the raw JWKS JSON string to cache
  jwks-cache-set: func(jwks-uri: string, jwks: string);
}

/// Type definitions for completion
interface completion-types {
  use mcp-types.{json-object};

  /// Resource reference
  record resource-reference {
    uri: string,
  }

  /// Prompt reference
  record prompt-reference {
    name: string,
  }

  /// Reference to what we're completing
  variant reference {
    /// Completing for a resource
    %resource(resource-reference),
    /// Completing for a prompt
    prompt(prompt-reference),
  }

  /// Argument information
  record argument-info {
    /// Name of the argument being completed
    name: string,
    /// Current partial value of the argument
    value: string,
  }

  /// Additional context for generating completions
  record completion-context {
    /// Previously resolved argument values
    arguments: option<json-object>,
  }

  /// Request for completion suggestions
  record complete-request {
    /// What we're completing for
    ref: reference,
    /// Argument information
    argument: argument-info,
    /// Optional context containing previously resolved argument values
    context: option<completion-context>,
  }

  /// Completion information
  record completion-info {
    /// Suggested completion values
    values: list<string>,
    /// Total number of possible completions (may exceed returned values)
    total: option<u32>,
    /// Whether more completions are available
    has-more: option<bool>,
  }

  /// Completion result
  record complete-result {
    /// Completion information
    completion: completion-info,
  }
}

/// Provides a standardized way for servers to offer argument autocompletion suggestions for prompts and resource URIs
///
/// https://modelcontextprotocol.io/specification/2025-06-18/server/utilities/completion
interface completion {
  use mcp-types.{mcp-error};
  use completion-types.{complete-request, complete-result};

  /// Handle request for completion suggestions
  complete: func(request: complete-request) -> result<complete-result, mcp-error>;
}

/// Type definitions for the MCP lifecycle
interface lifecycle-types {
  use mcp-types.{meta-fields, json-object, icon};

  /// Protocol version string
  /// Common values: "2024-11-05", "2025-03-26", "2025-06-18"
  type protocol-version = string;

  /// Information about an MCP implementation
  record implementation {
    /// Implementation name (e.g., "weather-server")
    name: string,
    /// Optional human-readable title
    title: option<string>,
    /// Implementation version (e.g., "1.0.0")
    version: string,
    /// Optional website URL for more information
    website-url: option<string>,
    /// Optional list of icons for the implementation
    icons: option<list<icon>>,
  }

  /// Root listing capability details
  record roots-capability {
    /// Server will notify when roots list changes
    list-changed: option<bool>,
  }

  /// Prompts capability details
  record prompts-capability {
    /// Server will notify when prompts list changes
    list-changed: option<bool>,
  }

  /// Resources capability details
  record resources-capability {
    /// Server supports resource subscriptions
    subscribe: option<bool>,
    /// Server will notify when resource list changes
    list-changed: option<bool>,
  }

  /// Tools capability details
  record tools-capability {
    /// Server will notify when tools list changes
    list-changed: option<bool>,
  }

  /// Elicitation capability details
  record elicitation-capability {
    /// Whether the client supports JSON Schema validation
    schema-validation: option<bool>,
  }

  /// Capabilities that a client supports
  record client-capabilities {
    /// Experimental/custom capabilities as JSON objects
    experimental: option<json-object>,
    /// Support for roots (directory access)
    roots: option<roots-capability>,
    /// Support for LLM sampling (empty object when enabled)
    sampling: option<json-object>,
    /// Support for user elicitation
    elicitation: option<elicitation-capability>,
  }

  /// Capabilities that a server provides
  record server-capabilities {
    /// Experimental/custom capabilities as JSON objects
    experimental: option<json-object>,
    /// Server can send log messages (empty object when enabled)
    logging: option<json-object>,
    /// Server supports argument autocompletion (empty object when enabled)
    completions: option<json-object>,
    /// Server offers prompts
    prompts: option<prompts-capability>,
    /// Server offers resources
    resources: option<resources-capability>,
    /// Server offers tools
    tools: option<tools-capability>,
  }

  /// Initialize request sent by client on connection
  record initialize-request {
    /// Protocol version the client supports
    protocol-version: protocol-version,
    /// Client's capabilities
    capabilities: client-capabilities,
    /// Client implementation details
    client-info: implementation,
  }

  /// Initialize response from server
  record initialize-result {
    /// Protocol version the server supports
    protocol-version: protocol-version,
    /// Server's capabilities
    capabilities: server-capabilities,
    /// Server implementation details
    server-info: implementation,
    /// Optional instructions for using the server
    instructions: option<string>,
  }
}

/// A lifecycle for client-server connections that ensures proper capability negotiation and state management.
/// Initialization: Capability negotiation and protocol version agreement
/// Operation: Normal protocol communication
/// Shutdown: Graceful termination of the connection
///
/// https://modelcontextprotocol.io/specification/2025-06-18/basic/lifecycle
interface lifecycle {
  use mcp-types.{mcp-error};
  use lifecycle-types.{initialize-request, initialize-result};

  /// Handle session initialization
  /// Implementations should declare their capabilities here
  initialize: func(request: initialize-request) -> result<initialize-result, mcp-error>;

  /// Handle initialization complete notification
  client-initialized: func() -> result<_, mcp-error>;

  /// Handle shutdown request
  shutdown: func() -> result<_, mcp-error>;
}

/// Type definitions for prompts
interface prompts-types {
  use mcp-types.{annotations, resource-contents, json-object, icon};

  /// Argument definition for a prompt template
  record prompt-argument {
    /// The name of the argument
    name: string,
    /// A human-readable title for the argument
    title: option<string>,
    /// A description of what the argument is used for
    description: option<string>,
    /// Whether this argument is required
    required: option<bool>,
  }

  /// Prompt template definition
  record prompt {
    /// The name of the prompt
    name: string,
    /// A human-readable title
    title: option<string>,
    /// Description of what this prompt does
    description: option<string>,
    /// Arguments that can be passed to the prompt
    arguments: option<list<prompt-argument>>,
    /// Optional list of icons for the prompt
    icons: option<list<icon>>,
  }

  /// Role of a message sender in a prompt conversation
  enum prompt-message-role {
    user,
    assistant,
  }

  /// Plain text content in a prompt message
  record text-content {
    text: string,
  }

  /// Image content in a prompt message
  record image-content {
    /// Base64-encoded image data
    data: string,
    /// MIME type of the image
    mime-type: string,
    /// Optional metadata
    meta: option<json-object>,
    /// Optional annotations
    annotations: option<annotations>,
  }

  /// Embedded resource in a prompt message
  record embedded-resource {
    /// The resource contents
    %resource: resource-contents,
    /// Optional metadata
    meta: option<json-object>,
    /// Optional annotations
    annotations: option<annotations>,
  }

  /// Link to a resource in a prompt message
  record resource-link {
    /// URI of the resource
    uri: string,
    /// Name of the resource
    name: string,
    /// Optional title
    title: option<string>,
    /// Optional description
    description: option<string>,
    /// Optional MIME type
    mime-type: option<string>,
    /// Optional size in bytes
    size: option<u32>,
    /// Optional list of icons for the resource
    icons: option<list<icon>>,
    /// Optional annotations
    annotations: option<annotations>,
  }

  /// Content types that can be included in prompt messages
  variant prompt-message-content {
    text(text-content),
    image(image-content),
    %resource(embedded-resource),
    resource-link(resource-link),
  }

  /// Message in a prompt conversation
  record prompt-message {
    /// The role of the message sender
    role: prompt-message-role,
    /// The content of the message
    content: prompt-message-content,
  }

  /// Request to list available prompts
  record list-prompts-request {
    /// Pagination cursor
    cursor: option<string>,
  }

  /// Response with list of prompts
  record list-prompts-result {
    /// Available prompts
    prompts: list<prompt>,
    /// Cursor for next page
    next-cursor: option<string>,
  }

  /// Request to get a specific prompt
  record get-prompt-request {
    /// Name of the prompt to retrieve
    name: string,
    /// Arguments for template substitution as JSON object
    arguments: option<json-object>,
  }

  /// Response with rendered prompt messages
  record get-prompt-result {
    /// Optional description of the rendered prompt
    description: option<string>,
    /// Messages that make up the prompt
    messages: list<prompt-message>,
  }
}

/// Prompts allow servers to provide structured messages and instructions for interacting with language models.
/// Clients can discover available prompts, retrieve their contents, and provide arguments to customize them.
///
/// https://modelcontextprotocol.io/specification/2025-06-18/server/prompts
interface prompts {
  use mcp-types.{mcp-error};
  use prompts-types.{list-prompts-request, list-prompts-result, get-prompt-request, get-prompt-result};

  /// List available prompts
  list-prompts: func(request: list-prompts-request) -> result<list-prompts-result, mcp-error>;

  /// Get a specific prompt
  get-prompt: func(request: get-prompt-request) -> result<get-prompt-result, mcp-error>;
}

/// Type definitions for resources
interface resources-types {
  use mcp-types.{annotations, resource-contents, icon};

  /// A resource that can be read by the client
  record mcp-resource {
    /// URI identifying the resource
    uri: string,
    /// Name of the resource
    name: string,
    /// Human-readable title
    title: option<string>,
    /// Human-readable description
    description: option<string>,
    /// MIME type if known
    mime-type: option<string>,
    /// Size in bytes (before encoding)
    size: option<u32>,
    /// Optional list of icons for the resource
    icons: option<list<icon>>,
    /// Client hints
    annotations: option<annotations>,
  }

  /// Resource template with URI template support (RFC 6570)
  record resource-template {
    /// URI template that can be expanded with variables
    uri-template: string,
    /// Identifier for the template
    name: string,
    /// Human-readable title
    title: option<string>,
    /// Human-readable description
    description: option<string>,
    /// Expected MIME type of resources
    mime-type: option<string>,
    /// Client hints
    annotations: option<annotations>,
  }

  /// Request to list available resources
  record list-resources-request {
    /// Pagination cursor
    cursor: option<string>,
  }

  /// Response with list of resources
  record list-resources-result {
    /// Available resources
    resources: list<mcp-resource>,
    /// Cursor for next page
    next-cursor: option<string>,
  }

  /// Request to list resource templates
  record list-resource-templates-request {
    /// Pagination cursor
    cursor: option<string>,
  }

  /// Response with list of resource templates
  record list-resource-templates-result {
    /// Available templates
    resource-templates: list<resource-template>,
    /// Cursor for next page
    next-cursor: option<string>,
  }

  /// Request to read a specific resource
  record read-resource-request {
    /// URI of the resource to read
    uri: string,
  }

  /// Response with resource contents
  record read-resource-result {
    /// Resource contents (may be multiple for sub-resources)
    contents: list<resource-contents>,
  }

  /// Request to subscribe to resource updates
  record subscribe-request {
    /// URI of the resource to monitor
    uri: string,
  }

  /// Request to unsubscribe from resource updates
  record unsubscribe-request {
    /// URI of the resource to stop monitoring
    uri: string,
  }
}

/// Resources allow servers to share data that provides context to language models, such as files, database schemas, or application-specific information.
/// Each resource is uniquely identified by a URI.
///
/// https://modelcontextprotocol.io/specification/2025-06-18/server/resources
interface resources {
  use mcp-types.{mcp-error};
  use resources-types.{list-resources-request, list-resources-result, list-resource-templates-request, list-resource-templates-result, read-resource-request, read-resource-result, subscribe-request, unsubscribe-request};

  /// List available resources
  list-resources: func(request: list-resources-request) -> result<list-resources-result, mcp-error>;

  /// List resource templates
  list-resource-templates: func(request: list-resource-templates-request) -> result<list-resource-templates-result, mcp-error>;

  /// Read a specific resource
  read-resource: func(request: read-resource-request) -> result<read-resource-result, mcp-error>;

  /// Subscribe to resource changes
  subscribe-resource: func(request: subscribe-request) -> result<_, mcp-error>;

  /// Unsubscribe from resource changes
  unsubscribe-resource: func(request: unsubscribe-request) -> result<_, mcp-error>;
}

/// Type definitions for tools
interface tools-types {
  use mcp-types.{content-block, json-value, json-object, icon};
  use authorization-types.{auth-context};

  /// Behavioral hints about tool operations
  record tool-annotations {
    /// Human-readable title for display
    title: option<string>,
    /// Tool does not modify environment (default: false)
    read-only-hint: option<bool>,
    /// Tool may perform destructive updates (default: true)
    destructive-hint: option<bool>,
    /// Repeated calls with same args have no additional effect (default: false)
    idempotent-hint: option<bool>,
    /// Tool interacts with external entities (default: true)
    open-world-hint: option<bool>,
  }

  /// Tool definition with metadata and schema
  record tool {
    /// The name of the tool
    name: string,
    /// A human-readable title for the tool
    title: option<string>,
    /// Human-readable description of what the tool does
    description: option<string>,
    /// JSON Schema object for input parameters
    input-schema: json-object,
    /// Optional JSON Schema object for structured output
    output-schema: option<json-object>,
    /// Behavioral hints for clients
    annotations: option<tool-annotations>,
    /// Optional list of icons for the tool
    icons: option<list<icon>>,
  }

  /// Request to execute a tool
  record call-tool-request {
    /// Name of the tool to execute
    name: string,
    /// Arguments as JSON object (must match the tool's input schema)
    arguments: option<json-object>,
  }

  /// Result from executing a tool
  record call-tool-result {
    /// Unstructured content blocks (text, images, etc.)
    content: list<content-block>,
    /// Optional structured JSON output
    structured-content: option<json-value>,
    /// Whether the tool execution resulted in an error
    is-error: option<bool>,
    /// Optional metadata
    meta: option<json-object>,
  }

  /// Request to list available tools
  record list-tools-request {
    /// Pagination cursor from previous response
    cursor: option<string>,
  }

  /// Response with list of available tools
  record list-tools-result {
    /// Available tools
    tools: list<tool>,
    /// Cursor for next page if more tools exist
    next-cursor: option<string>,
  }
}

/// Tools enable models to interact with external systems, such as querying databases, calling APIs, or performing computations.
/// Each tool is uniquely identified by a name and includes metadata describing its schema.
///
/// https://modelcontextprotocol.io/specification/2025-06-18/server/tools
interface tools {
  use mcp-types.{mcp-error};
  use authorization-types.{auth-context};
  use tools-types.{list-tools-request, list-tools-result, call-tool-request, call-tool-result};

  /// List available tools
  list-tools: func(request: list-tools-request) -> result<list-tools-result, mcp-error>;

  /// Execute a tool
  call-tool: func(request: call-tool-request, context: option<auth-context>) -> result<call-tool-result, mcp-error>;
}

/// World definitions for MCP transports
world streamable-http-transport {
  import mcp-types;
  import lifecycle-types;
  import lifecycle;
  import authorization-types;
  import authorization;
}
/// Serves TOOLS
world tools-transport {
  import mcp-types;
  import authorization-types;
  import tools-types;
  import tools;
  import lifecycle-types;
  import lifecycle;
  import authorization;
}
/// Serves TOOLS + RESOURCES
world tools-resources-transport {
  import mcp-types;
  import resources-types;
  import resources;
  import authorization-types;
  import tools-types;
  import tools;
  import lifecycle-types;
  import lifecycle;
  import authorization;
}
/// Serves TOOLS + RESOURCES + PROMPTS
world tools-resources-prompts-transport {
  import mcp-types;
  import prompts-types;
  import prompts;
  import resources-types;
  import resources;
  import authorization-types;
  import tools-types;
  import tools;
  import lifecycle-types;
  import lifecycle;
  import authorization;
}
/// Serves TOOLS + RESOURCES + PROMPTS + COMPLETION
world full-transport {
  import mcp-types;
  import completion-types;
  import completion;
  import prompts-types;
  import prompts;
  import resources-types;
  import resources;
  import authorization-types;
  import tools-types;
  import tools;
  import lifecycle-types;
  import lifecycle;
  import authorization;
}
