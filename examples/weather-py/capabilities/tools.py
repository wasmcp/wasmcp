"""Tools implementation for weather-py MCP server."""

import json
import asyncio
import urllib.parse
from typing import Dict, Any, Optional, List

# PollLoop is componentize-py's async event loop for WebAssembly.
# It bridges Python's asyncio with WebAssembly's poll-based I/O model,
# similar to how Node.js libuv works but for WebAssembly components.
# Source: https://github.com/bytecodealliance/componentize-py/blob/main/bundled/poll_loop.py
from poll_loop import PollLoop, Stream, send

# WIT-generated types from the Component Model interfaces.
# These are Python dataclasses/enums generated by componentize-py from the WIT definitions.
# The underscore naming (e.g., ContentBlock_Text) indicates variant cases in WIT.
from wit_world.imports.mcp_types import ContentBlock_Text, TextContent
from wit_world.imports.authorization_types import AuthContext
from wit_world.imports.tools_types import Tool, ListToolsRequest, ListToolsResult, CallToolRequest, CallToolResult
from wit_world.imports.types import (
    OutgoingRequest,
    Fields,
    Scheme_Http,
    Scheme_Https,
    Method_Get,
)


class Tools:
    """Handle MCP tools methods.
    
    This class bridges synchronous WIT interfaces with Python's async HTTP.
    The Component Model calls our methods synchronously, but we need async
    for concurrent HTTP requests. PollLoop (from componentize-py) provides
    an event loop that integrates with WebAssembly's async model.
    """

    def list_tools(self, request: ListToolsRequest) -> ListToolsResult:
        """List available tools.
        
        Tools are defined inline rather than in a separate registry.
        The input_schema is a JSON string because WIT's json-object type
        is represented as a string in Python bindings.
        """
        tools = [
            Tool(
                name="echo",
                title="echo",
                description="Echo a message back to the user",
                icons=None,
                input_schema=json.dumps({
                    "type": "object",
                    "properties": {
                        "message": {"type": "string", "description": "Message to echo"}
                    },
                    "required": ["message"]
                }),
                output_schema=None,
                annotations=None
            ),
            Tool(
                name="get_weather",
                title="get_weather",
                description="Get current weather for a location",
                icons=None,
                input_schema=json.dumps({
                    "type": "object",
                    "properties": {
                        "location": {"type": "string", "description": "City name or location"}
                    },
                    "required": ["location"]
                }),
                output_schema=None,
                annotations=None
            ),
            Tool(
                name="multi_weather",
                title="multi_weather",
                description="Get weather for multiple locations concurrently",
                icons=None,
                input_schema=json.dumps({
                    "type": "object",
                    "properties": {
                        "cities": {
                            "type": "array",
                            "description": "List of city names (max 5)",
                            "items": {"type": "string"}
                        }
                    },
                    "required": ["cities"]
                }),
                output_schema=None,
                annotations=None
            ),
        ]

        return ListToolsResult(
            tools=tools,
            next_cursor=None
        )

    def call_tool(
        self, 
        request: CallToolRequest,
        context: Optional[AuthContext]
    ) -> CallToolResult:
        """Execute a tool with the given request.
        
        The context parameter is Optional[AuthContext] mapping to WIT's option<auth-context>.
        This allows authentication to be optional per the MCP protocol.
        """        
        # Parse arguments from JSON string (WIT json-object type)
        args: Dict[str, Any] = {}
        if request.arguments:
            try:
                args = json.loads(request.arguments)
            except json.JSONDecodeError as e:
                return error_result(f"Invalid JSON arguments: {e}")

        # Route to tool handler
        try:
            if request.name == "echo":
                result_text = execute_echo(args)
            elif request.name == "get_weather":
                result_text = execute_weather_sync(args)
            elif request.name == "multi_weather":
                result_text = execute_multi_weather_sync(args)
            else:
                return error_result(f"Unknown tool: {request.name}")
            
            return text_result(result_text)
            
        except Exception as e:
            return error_result(f"Tool execution failed: {str(e)}")

def execute_echo(args: Dict[str, Any]) -> str:
    """Simple synchronous echo tool."""
    message = args.get("message", "")
    return f"Echo: {message}"


def execute_weather_sync(args: Dict[str, Any]) -> str:
    """Get weather for a single location.
    
    This demonstrates the async/sync bridge pattern:
    1. Component Model calls us synchronously
    2. We create a PollLoop (componentize-py's event loop)
    3. Run async HTTP operations to completion
    4. Return synchronous result
    
    PollLoop integrates with WebAssembly's poll-based async model,
    similar to how wasihttp works in Go but with Python's async/await.
    """
    location = args.get("location", "")
    
    # Run async code in PollLoop
    loop = PollLoop()
    asyncio.set_event_loop(loop)
    try:
        weather_data = loop.run_until_complete(fetch_weather(location))
        return format_weather(weather_data)
    finally:
        loop.close()


def execute_multi_weather_sync(args: Dict[str, Any]) -> str:
    """Get weather for multiple cities concurrently."""
    cities = args.get("cities", [])
    
    if not cities:
        return "No cities provided"
    if len(cities) > 5:
        return "Maximum 5 cities allowed"
    
    # Run async code in PollLoop
    loop = PollLoop()
    asyncio.set_event_loop(loop)
    try:
        return loop.run_until_complete(fetch_multi_weather(cities))
    finally:
        loop.close()


async def fetch_multi_weather(cities: List[str]) -> str:
    """Fetch weather for multiple cities concurrently.
    
    Unlike Go which needs special handling for concurrency in WebAssembly,
    Python's async/await works naturally with componentize-py's PollLoop.
    The gather() call here achieves true concurrent HTTP requests through
    the WebAssembly runtime's poll-based I/O.
    """
    tasks = [fetch_weather(city) for city in cities]
    results = await asyncio.gather(*tasks, return_exceptions=True)

    output = "=== Weather Results ===\n\n"
    for city, result in zip(cities, results):
        if isinstance(result, Exception):
            output += f"Error fetching weather for {city}: {result}\n\n"
        elif isinstance(result, dict):
            output += format_weather(result) + "\n\n"
        else:
            output += f"Unexpected result for {city}: {result}\n\n"
    output += "=== All requests completed ==="

    return output


async def fetch_weather(city: str) -> Dict[str, Any]:
    """Fetch weather data for a single city."""
    # Geocode the location
    geo_url = f"https://geocoding-api.open-meteo.com/v1/search?name={urllib.parse.quote(city)}&count=1"
    geo_data = await fetch_json(geo_url)
    
    if not geo_data.get("results"):
        raise Exception(f"Location '{city}' not found")
    
    location = geo_data["results"][0]
    
    # Get weather data
    weather_url = (
        f"https://api.open-meteo.com/v1/forecast?"
        f"latitude={location['latitude']}&longitude={location['longitude']}"
        f"&current=temperature_2m,apparent_temperature,relative_humidity_2m,wind_speed_10m,weather_code"
    )
    weather = await fetch_json(weather_url)
    
    return {
        "name": location["name"],
        "country": location["country"],
        "temperature": weather["current"]["temperature_2m"],
        "apparent_temperature": weather["current"]["apparent_temperature"],
        "humidity": weather["current"]["relative_humidity_2m"],
        "wind_speed": weather["current"]["wind_speed_10m"],
        "weather_code": weather["current"]["weather_code"],
    }


async def fetch_json(url: str) -> Dict[str, Any]:
    """Fetch JSON from a URL using WASI HTTP.
    
    This uses the low-level WASI HTTP types directly rather than a high-level
    HTTP library. The OutgoingRequest and related types are generated from the
    wasi:http/types WIT interface. The async send() function from poll_loop
    integrates with WebAssembly's async I/O model.
    """
    parsed = urllib.parse.urlparse(url)
    
    # Create HTTP request using WIT-generated types
    request = OutgoingRequest(Fields.from_list([]))  # type: ignore[no-untyped-call]
    
    if parsed.scheme == "https":
        request.set_scheme(Scheme_Https())
    else:
        request.set_scheme(Scheme_Http())
    
    request.set_authority(parsed.netloc)
    
    path_with_query = parsed.path
    if parsed.query:
        path_with_query += f"?{parsed.query}"
    request.set_path_with_query(path_with_query)
    
    request.set_method(Method_Get())
    
    # Send request using poll_loop.send
    response = await send(request)
    
    # Check status
    status = response.status()  # type: ignore[no-untyped-call]
    if status < 200 or status >= 300:
        raise Exception(f"HTTP {status} from {url}")
    
    # Read response body
    stream = Stream(response.consume())  # type: ignore[no-untyped-call]
    chunks: List[bytes] = []
    while True:
        chunk = await stream.next()
        if chunk is None:
            break
        chunks.append(chunk)
    
    body = b"".join(chunks)
    return json.loads(body)


def format_weather(data: Dict[str, Any]) -> str:
    """Format weather data as human-readable text."""
    return (
        f"Weather in {data['name']}, {data['country']}:\n"
        f"Temperature: {data['temperature']:.1f}°C "
        f"(feels like {data['apparent_temperature']:.1f}°C)\n"
        f"Conditions: {weather_condition(data['weather_code'])}\n"
        f"Humidity: {data['humidity']}%\n"
        f"Wind: {data['wind_speed']:.1f} km/h"
    )


def weather_condition(code: int) -> str:
    """Convert weather code to human-readable condition."""
    conditions = {
        0: "Clear sky",
        1: "Mainly clear",
        2: "Partly cloudy",
        3: "Overcast",
        45: "Foggy",
        48: "Depositing rime fog",
        51: "Light drizzle",
        53: "Moderate drizzle",
        55: "Dense drizzle",
        61: "Slight rain",
        63: "Moderate rain",
        65: "Heavy rain",
        71: "Slight snow fall",
        73: "Moderate snow fall",
        75: "Heavy snow fall",
        80: "Slight rain showers",
        81: "Moderate rain showers",
        82: "Violent rain showers",
        85: "Slight snow showers",
        86: "Heavy snow showers",
        95: "Thunderstorm",
        96: "Thunderstorm with slight hail",
        99: "Thunderstorm with heavy hail",
    }
    return conditions.get(code, "Unknown")

def text_result(text: str) -> CallToolResult:
    """Create a successful text result."""
    return CallToolResult(
        content=[
            ContentBlock_Text(
                value=TextContent(
                    text=text,
                    annotations=None,
                    meta=None
                )
            )
        ],
        structured_content=None,
        is_error=False,
        meta=None
    )


def error_result(message: str) -> CallToolResult:
    """Create an error result."""
    return CallToolResult(
        content=[
            ContentBlock_Text(
                value=TextContent(
                    text=message,
                    annotations=None,
                    meta=None
                )
            )
        ],
        structured_content=None,
        is_error=True,
        meta=None
    )
