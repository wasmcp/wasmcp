# Component Model Technical Notes for Python

This document explains the technical patterns and constraints in the weather-py example.

## Key Differences from Go

Python's integration with the Component Model is notably smoother than Go's:
- **No explicit Result types** - componentize-py handles WIT's `result<T, E>` transparently
- **Natural async/await** - Works with componentize-py's PollLoop
- **Protocol typing** - PEP 544 provides structural typing that maps well to WIT interfaces
- **Simpler type mapping** - None naturally maps to WIT's `option<T>`

## The Async/Sync Bridge

### The Pattern

```python
def sync_handler(args):
    loop = PollLoop()
    asyncio.set_event_loop(loop)
    try:
        return loop.run_until_complete(async_function(args))
    finally:
        loop.close()
```

**Why this works:**
- Component Model calls are synchronous (no async exports in WIT)
- PollLoop is componentize-py's event loop that integrates with WebAssembly's poll-based I/O
- Similar to wasihttp in Go, but using Python's native async/await

## Protocol Verification

### The TYPE_CHECKING Pattern

```python
if TYPE_CHECKING:
    from wit_world.exports import Lifecycle as LifecycleProtocol
    _lifecycle: LifecycleProtocol = Lifecycle()
```

**What this does:**
- Verifies at build time (via pyright) that our classes match WIT interfaces
- Uses Python's Protocol pattern (PEP 544) for structural typing
- Zero runtime cost - TYPE_CHECKING is False at runtime

## HTTP in WebAssembly

### Using WASI HTTP Types

```python
request = OutgoingRequest(Fields.from_list([]))
response = await send(request)  # poll_loop's send function
stream = Stream(response.consume())
chunk = await stream.next()
```

**Why not use requests/httpx?**
- Standard HTTP libraries don't work in WebAssembly (no socket access)
- Must use WASI HTTP types generated from wasi:http/types
- The `send()` function from poll_loop handles the async I/O

## Type Mappings

| Python Type | WIT Type | Notes |
|------------|----------|-------|
| `None` | `option<T>` (absent) | Natural mapping |
| `value` | `option<T>` (present) | Wrapped automatically |
| `str` (JSON) | `json-object` | JSON as string |
| `Dict`/`List` | records/lists | Direct mapping |
| Exceptions | `result<T, E>` (error) | Handled by componentize-py |

## Component Lifecycle

1. **No main()** - componentize-py creates the component from class exports
2. **Class instantiation** - Classes are instantiated once at component load
3. **Method calls** - The runtime calls methods directly for each request
4. **No persistent state** - Each call is independent (component isolation)

## Concurrency Model

Unlike Go's limitations, Python's async/await works naturally:

```python
# This IS concurrent in Python/WebAssembly:
results = await asyncio.gather(*tasks)
```

The PollLoop integrates with WebAssembly's poll-based I/O, enabling true concurrent HTTP requests without special handling.

## Directory Structure

```
wit_world/          # Generated by componentize-py at build time
├── exports/        # Protocol classes for type checking
└── imports/        # Types from imported WIT interfaces
```

The `wit_world` must be at the project root - this is a componentize-py requirement.

## Build Process

1. `componentize-py` generates Python bindings from WIT
2. `pyright` type-checks against Protocol classes
3. `componentize-py` creates the WebAssembly component
4. `wac` composes with the transport layer

## Further Reading

- [componentize-py Documentation](https://github.com/bytecodealliance/componentize-py)
- [PEP 544 - Protocols](https://www.python.org/dev/peps/pep-0544/)
- [Python Component Model Guide](https://component-model.bytecodealliance.org/language-support/python.html)