interface messages {
    use mcp.{
        error-code,
        log-level,
        uri,
    };
    use context.{
        request-meta,
        result-meta,
        notification-meta,
        error-meta,
    };
    use notifications.{
        client-notification,
        server-notification,
    };
    use initialization.{
        initialize-request,
        initialize-result,
    };
    use tools.{
        list-tools-request,
        list-tools-result,
        call-tool-request,
        call-tool-result,
    };
    use resources.{
        list-resources-request,
        list-resources-result,
        read-resource-request,
        read-resource-result,
        list-resource-templates-request,
        list-resource-templates-result,
    };
    use prompts.{
        list-prompts-request,
        list-prompts-result,
        get-prompt-request,
        get-prompt-result,
    };
    use completions.{
        complete-request,
        complete-result,
    };
    use sampling.{
        sampling-create-message-request,
        sampling-create-message-result,
    };
    use elicitations.{
        elicit-request,
        elicit-result,
    };
    use roots.{
        list-roots-result,
    };

    /// Requests handled by the server
    @since(version = 0.1.0)
    variant server-request {
        initialize(initialize-request),
        tools-list(list-tools-request),
        tools-call(call-tool-request),
        resources-list(list-resources-request),
        resources-read(read-resource-request),
        resources-templates-list(list-resource-templates-request),
        prompts-list(list-prompts-request),
        prompts-get(get-prompt-request),
        completion-complete(complete-request),
        logging-set-level(log-level),
        ping,
        resources-subscribe(uri),
        resources-unsubscribe(uri),
    }

    /// Server responses
    @since(version = 0.1.0)
    variant server-result {
        ping,
        logging-set-level,
        initialize(initialize-result),
        tools-list(list-tools-result),
        tools-call(call-tool-result),
        resources-list(list-resources-result),
        resources-read(read-resource-result),
        resources-templates-list(list-resource-templates-result),
        prompts-list(list-prompts-result),
        prompts-get(get-prompt-result),
        completion-complete(complete-result),
        resources-subscribe,
        resources-unsubscribe,
    }

    /// Requests handled by the client
    @since(version = 0.1.0)
    variant client-request {
        elicitation-create(elicit-request),
        roots-list,
        sampling-create-message(sampling-create-message-request),
        ping,
    }

    /// Client responses (to server requests)
    @since(version = 0.1.0)
    variant client-result {
        elicitation-create(elicit-result),
        roots-list(list-roots-result),
        sampling-create-message(sampling-create-message-result),
        ping,
    }

    variant server-message {
        request(tuple<server-request, request-meta>),
        %result(tuple<client-result, result-meta>),
        error(tuple<error-code, error-meta>),
        notification(tuple<client-notification, notification-meta>),
    }

    variant client-message {
        request(tuple<client-request, request-meta>),
        %result(tuple<server-result, result-meta>),
        error(tuple<error-code, error-meta>),
        notification(tuple<server-notification, notification-meta>),
    }
}

/// Streaming I/O for MCP servers
///
/// This interface enables servers to parse and send MCP messages over streams.
@since(version = 0.1.4)
interface io {
    use wasi:io/streams@0.2.3.{
        input-stream,
        output-stream,
        stream-error,
    };
    use mcp.{
        transport,
    };
    use messages.{
        server-message,
        client-message,
    };

    /// Errors that can occur when sending messages to the client
    @since(version = 0.1.4)
    variant io-error {
        /// An I/O error occurred writing to the output stream
        %stream(stream-error),
        /// Invalid JSON-RPC message
        invalid-jsonrpc(string),
        /// Invalid MCP message
        invalid-mcp(string),
        /// An unexpected error occurred
        unexpected(string),
    }

    /// Read and deserialize an incoming message from the client
    @since(version = 0.1.4)
    parse-message: func(
        /// Input stream to read the bytes from
        input: borrow<input-stream>,
        /// The transport type
        transport: transport,
    ) -> result<server-message, io-error>;

    /// Serialize and write an outgoing message to the client
    @since(version = 0.1.4)
    send-message: func(
        /// Output stream to send the request over
        output: borrow<output-stream>,
        /// The transport type
        transport: transport,
        /// Outgoing message to the client
        message: client-message,
    ) -> result<_, io-error>;
}

/// Decode and validate a JWT
@since(version = 0.1.4)
interface auth {
    use mcp.{
        claims,
        jwt,
    };
    use messages.{
        server-message,
    };

    /// Decode and validate a JWT.
    /// Returns the decoded claims if successful.
    ///
    /// If the token or its signature is invalid or the claims fail validation, it will return an error.
    @since(version = 0.1.4)
    decode: func(
        /// JWT from the Authorization header
        jwt: jwt,
    ) -> result<claims>;

    /// Authorize an incoming message against decoded claims.
    @since(version = 0.1.4)
    authorize: func(
        /// The incoming message
        message: server-message,
        /// Decoded JWT claims
        claims: claims,
    ) -> bool;
}

/// MCP session management and related features
///
/// This interface provides stateful session management for MCP servers, enabling:
/// - Persistent session data storage using WASI key-value stores
/// - Client elicitation (requesting information from clients)
/// - Session lifecycle management (initialize, terminate, delete)
/// - Async operations with pollable futures
///
/// Sessions are identified by unique IDs and can span multiple HTTP requests,
/// allowing servers to maintain state and context across interactions.
///
/// <https://modelcontextprotocol.io/specification/2025-06-18/basic/transports#session-management>
@since(version = 0.1.0)
interface sessions {
    use wasi:io/streams@0.2.8.{
        output-stream,
        stream-error,
    };
    use wasi:io/poll@0.2.8.{
        pollable,
    };
    use elicitations.{
        elicit-request,
        elicit-result,
    };

    /// Errors that can occur during session operations
    @since(version = 0.1.0)
    variant session-error {
        /// An I/O error occurred in communication with the client
        io(stream-error),
        /// An error occurred in the underlying key-value store
        store(string),
        /// The specified session does not exist
        no-such-session,
        /// An unexpected error occurred
        unexpected(string),
    }

    /// A future representing a pending elicit result
    ///
    /// The elicit result is ready when the pollable indicates readiness.
    /// This enables async/await style operations where handlers can request
    /// information from clients and continue processing when the response arrives.
    @since(version = 0.1.0)
    resource future-elicit-result {
        /// Create a pollable to wait for the elicit result
        ///
        /// The pollable becomes ready when the client responds to the elicitation.
        /// Use WASI poll to wait for readiness before calling elicit-result().
        @since(version = 0.1.0)
        subscribe: func() -> pollable;

        /// Get the elicit result
        ///
        /// Precondition: Only call this after subscribe() indicates readiness.
        /// Calling before the result is ready may trap or return invalid data.
        @since(version = 0.1.0)
        elicit-result: func() -> elicit-result;
    }

    /// A bucket-backed session keyed by the Mcp-Session-Id HTTP header
    ///
    /// Sessions provide persistent storage and client communication primitives.
    /// Each session is identified by a cryptographically unique ID that's passed in the Mcp-Session-Id header.
    ///
    /// <https://modelcontextprotocol.io/specification/2025-06-18/basic/transports#session-management>
    @since(version = 0.1.0)
    resource session {
        /// Open an existing session by ID in the given bucket
        ///
        /// This is called when a client provides an Mcp-Session-Id header
        /// to resume a previous session. Returns an error if the session
        /// ID doesn't exist in the bucket.
        ///
        /// The bucket is consumed and owned by the session resource.
        @since(version = 0.1.0)
        open: static func(
            /// The session ID from Mcp-Session-Id header
            session-id: string,
            /// The ID of the session's underlying key-value store
            store-id: string,
        ) -> result<session, session-error>;

        /// Get the session ID
        ///
        /// This ID should be returned to clients in the Mcp-Session-Id header
        /// so they can resume the session in future requests.
        @since(version = 0.1.0)
        id: func() -> string;

        /// Get a persistent session value by key
        ///
        /// Returns None if the key doesn't exist. Session data persists across
        /// HTTP requests as long as the session exists.
        @since(version = 0.1.0)
        get: func(
            /// The key to retrieve
            key: string,
        ) -> result<option<list<u8>>, session-error>;

        /// Set a persistent session value by key
        ///
        /// The value is immediately persisted to the underlying key-value store.
        /// Overwriting an existing key replaces the previous value.
        @since(version = 0.1.0)
        set: func(
            /// The key to store under
            key: string,
            /// The value to store (arbitrary binary data)
            value: list<u8>,
        ) -> result<_, session-error>;

        /// Elicit information from the client
        ///
        /// This sends a request to the client asking for specific information
        /// (roots, sampling, etc.). The result is a future that can be polled
        /// to check when the client responds.
        ///
        /// The request is sent immediately on the provided output stream.
        /// The future should be stored and polled later to retrieve the response.
        ///
        /// <https://modelcontextprotocol.io/specification/2025-06-18/client/elicitation>
        @since(version = 0.1.0)
        elicit: func(
            /// Output stream to send the elicitation request
            client: borrow<output-stream>,
            /// The elicitation request to send
            elicitation: elicit-request,
        ) -> result<future-elicit-result, session-error>;

        /// Terminate the session, optionally providing a reason
        ///
        /// Termination marks the session as ended but does NOT delete session data.
        /// Clients can detect termination and stop sending requests. Use delete()
        /// to remove all session data.
        ///
        /// This operation is idempotent - calling multiple times has no effect.
        @since(version = 0.1.0)
        terminate: func(
            /// Optional reason for termination (shown to client)
            reason: option<string>,
        ) -> result<_, session-error>;
    }
}

/// Transport-layer session lifecycle management interface
///
/// This interface is used by transport components (HTTP, stdio, etc.) to manage
/// session lifecycle. User tools should NOT import this interface - they use
/// the session resource instead.
///
/// Storage format is an implementation detail managed internally by the
/// session-store component and is NOT exposed via this WIT interface.
@since(version = 0.1.4)
interface session-manager {
    use sessions.{session-error};

    /// Initialize a new session
    ///
    /// Creates a new session with generated UUID, stores initial metadata,
    /// and returns the session ID for inclusion in response headers.
    ///
    /// # Arguments
    /// * `store-id` - Name of the WASI KV bucket to use for storage
    ///
    /// # Returns
    /// * `Ok(session-id)` - UUID v4 formatted session identifier
    /// * `Err(session-error)` - Storage or generation error
    ///
    /// @since(version = 0.1.4)
    initialize: func(store-id: string) -> result<string, session-error>;

    /// Validate session exists and is not terminated
    ///
    /// Checks that:
    /// 1. Session exists in storage
    /// 2. Session is not marked as terminated
    ///
    /// # Returns
    /// * `Ok(true)` - Session is valid and active
    /// * `Ok(false)` - Session exists but is terminated
    /// * `Err(no-such-session)` - Session does not exist
    /// * `Err(session-error)` - Storage error
    ///
    /// @since(version = 0.1.4)
    validate: func(session-id: string, store-id: string) -> result<bool, session-error>;

    /// Mark session as terminated (soft delete)
    ///
    /// Updates session metadata to mark as terminated with optional reason.
    /// Data remains in storage but session cannot be used for new requests.
    ///
    /// This is called by:
    /// * Transport layer when client sends termination request
    /// * User tools calling session.terminate()
    ///
    /// # Arguments
    /// * `session-id` - Session to terminate
    /// * `store-id` - WASI KV bucket name
    /// * `reason` - Optional human-readable termination reason
    ///
    /// @since(version = 0.1.4)
    mark-terminated: func(
        session-id: string,
        store-id: string,
        reason: option<string>
    ) -> result<_, session-error>;

    /// Delete session from storage (hard delete)
    ///
    /// Completely removes session and all associated data from storage.
    /// This is a destructive operation that cannot be undone.
    ///
    /// Typically called by transport layer during cleanup, not by user tools.
    ///
    /// @since(version = 0.1.4)
    delete-session: func(session-id: string, store-id: string) -> result<_, session-error>;
}
