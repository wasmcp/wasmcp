/// MCP session management and related features
///
/// This interface provides stateful session management for MCP servers, enabling:
/// - Persistent session data storage using WASI key-value stores
/// - Client elicitation (requesting information from clients)
/// - Session lifecycle management (initialize, terminate, delete)
/// - Async operations with pollable futures
///
/// Sessions are identified by unique IDs and can span multiple HTTP requests,
/// allowing servers to maintain state and context across interactions.
///
/// <https://modelcontextprotocol.io/specification/2025-06-18/basic/transports#session-management>
@since(version = 0.1.0)
interface sessions {
    use wasi:io/streams@0.2.3.{
        output-stream,
        stream-error,
    };
    use wasi:io/poll@0.2.3.{
        pollable,
    };
    use mcp.{
        elicit-request,
        elicit-result,
    };

    /// Errors that can occur during session operations
    @since(version = 0.1.0)
    variant session-error {
        /// An I/O error occurred in communication with the client
        io(stream-error),
        /// An error occurred in the underlying key-value store
        store(string),
        /// The specified session does not exist
        no-such-session,
        /// An unexpected error occurred
        unexpected(string),
    }

    /// A future representing a pending elicit result
    ///
    /// The elicit result is ready when the pollable indicates readiness.
    /// This enables async/await style operations where handlers can request
    /// information from clients and continue processing when the response arrives.
    @since(version = 0.1.0)
    resource future-elicit-result {
        /// Create a pollable to wait for the elicit result
        ///
        /// The pollable becomes ready when the client responds to the elicitation.
        /// Use WASI poll to wait for readiness before calling elicit-result().
        @since(version = 0.1.0)
        subscribe: func() -> pollable;

        /// Get the elicit result
        ///
        /// Precondition: Only call this after subscribe() indicates readiness.
        /// Calling before the result is ready may trap or return invalid data.
        @since(version = 0.1.0)
        elicit-result: func() -> elicit-result;
    }

    /// A bucket-backed session keyed by the Mcp-Session-Id HTTP header
    ///
    /// Sessions provide persistent storage and client communication primitives.
    /// Each session is identified by a cryptographically unique ID that's passed in the Mcp-Session-Id header.
    ///
    /// <https://modelcontextprotocol.io/specification/2025-06-18/basic/transports#session-management>
    @since(version = 0.1.0)
    resource session {
        /// Open an existing session by ID in the given bucket
        ///
        /// This is called when a client provides an Mcp-Session-Id header
        /// to resume a previous session. Returns an error if the session
        /// ID doesn't exist in the bucket.
        ///
        /// The bucket is consumed and owned by the session resource.
        @since(version = 0.1.0)
        open: static func(
            /// The session ID from Mcp-Session-Id header
            session-id: string,
            /// The ID of the session's underlying key-value store
            store-id: string,
        ) -> result<session, session-error>;

        /// Get the session ID
        ///
        /// This ID should be returned to clients in the Mcp-Session-Id header
        /// so they can resume the session in future requests.
        @since(version = 0.1.0)
        id: func() -> string;

        /// Get a persistent session value by key
        ///
        /// Returns None if the key doesn't exist. Session data persists across
        /// HTTP requests as long as the session exists.
        @since(version = 0.1.0)
        get: func(
            /// The key to retrieve
            key: string,
        ) -> result<option<list<u8>>, session-error>;

        /// Set a persistent session value by key
        ///
        /// The value is immediately persisted to the underlying key-value store.
        /// Overwriting an existing key replaces the previous value.
        @since(version = 0.1.0)
        set: func(
            /// The key to store under
            key: string,
            /// The value to store (arbitrary binary data)
            value: list<u8>,
        ) -> result<_, session-error>;

        /// Elicit information from the client
        ///
        /// This sends a request to the client asking for specific information
        /// (roots, sampling, etc.). The result is a future that can be polled
        /// to check when the client responds.
        ///
        /// The request is sent immediately on the provided output stream.
        /// The future should be stored and polled later to retrieve the response.
        ///
        /// <https://modelcontextprotocol.io/specification/2025-06-18/client/elicitation>
        @since(version = 0.1.0)
        elicit: func(
            /// Output stream to send the elicitation request
            client: borrow<output-stream>,
            /// The elicitation request to send
            elicitation: elicit-request,
        ) -> result<future-elicit-result, session-error>;

        /// Terminate the session, optionally providing a reason
        ///
        /// Termination marks the session as ended but does NOT delete session data.
        /// Clients can detect termination and stop sending requests. Use delete()
        /// to remove all session data.
        ///
        /// This operation is idempotent - calling multiple times has no effect.
        @since(version = 0.1.0)
        terminate: func(
            /// Optional reason for termination (shown to client)
            reason: option<string>,
        ) -> result<_, session-error>;
    }
}

/// Transport-layer session lifecycle management interface
///
/// This interface is used by transport components (HTTP, stdio, etc.) to manage
/// session lifecycle. User tools should NOT import this interface - they use
/// the session resource instead.
///
/// Storage format is an implementation detail managed internally by the
/// session-store component and is NOT exposed via this WIT interface.
@since(version = 0.1.4-beta.1)
interface session-manager {
    use sessions.{session-error};

    /// Initialize a new session
    ///
    /// Creates a new session with generated UUID, stores initial metadata,
    /// and returns the session ID for inclusion in response headers.
    ///
    /// # Arguments
    /// * `store-id` - Name of the WASI KV bucket to use for storage
    ///
    /// # Returns
    /// * `Ok(session-id)` - UUID v4 formatted session identifier
    /// * `Err(session-error)` - Storage or generation error
    ///
    /// @since(version = 0.1.4-beta.1)
    initialize: func(store-id: string) -> result<string, session-error>;

    /// Validate session exists and is not terminated
    ///
    /// Checks that:
    /// 1. Session exists in storage
    /// 2. Session is not marked as terminated
    ///
    /// # Returns
    /// * `Ok(true)` - Session is valid and active
    /// * `Ok(false)` - Session exists but is terminated
    /// * `Err(no-such-session)` - Session does not exist
    /// * `Err(session-error)` - Storage error
    ///
    /// @since(version = 0.1.4-beta.1)
    validate: func(session-id: string, store-id: string) -> result<bool, session-error>;

    /// Mark session as terminated (soft delete)
    ///
    /// Updates session metadata to mark as terminated with optional reason.
    /// Data remains in storage but session cannot be used for new requests.
    ///
    /// This is called by:
    /// * Transport layer when client sends termination request
    /// * User tools calling session.terminate()
    ///
    /// # Arguments
    /// * `session-id` - Session to terminate
    /// * `store-id` - WASI KV bucket name
    /// * `reason` - Optional human-readable termination reason
    ///
    /// @since(version = 0.1.4-beta.1)
    mark-terminated: func(
        session-id: string,
        store-id: string,
        reason: option<string>
    ) -> result<_, session-error>;

    /// Delete session from storage (hard delete)
    ///
    /// Completely removes session and all associated data from storage.
    /// This is a destructive operation that cannot be undone.
    ///
    /// Typically called by transport layer during cleanup, not by user tools.
    ///
    /// @since(version = 0.1.4-beta.1)
    delete-session: func(session-id: string, store-id: string) -> result<_, session-error>;
}
