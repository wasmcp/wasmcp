package wasmcp:oauth@0.1.0;

/// JWT Claims Helper Functions
///
/// This interface provides type-safe helper functions for working with JWT claims.
/// These functions handle common authorization checks and claim extraction patterns,
/// making it easier to implement secure authentication and authorization logic.
///
/// Usage Notes:
/// - Claims arrive as structured jwt-claims in MessageContext.identity.claims
/// - No parsing is needed - use these helpers directly on the structured claims!
/// - All time-based checks (expiration, not-before) include optional clock skew
/// - Scope checks handle both space-separated strings and array formats

interface helpers {
    use types.{jwt-claims};

    // ===== Scope Validation =====

    /// Check if claims contain specific scope
    ///
    /// OAuth scopes are stored in the 'scopes' field (parsed from 'scope' or 'scp' claim).
    /// This checks if the specified scope exists in the token.
    ///
    /// Example:
    /// ```
    /// use wasmcp:oauth/helpers.{has-scope};
    ///
    /// if has-scope(claims, "read:users") {
    ///     // User has permission to read users
    /// }
    /// ```
    ///
    /// Security Note: Always validate scopes before performing sensitive operations.
    has-scope: func(claims: jwt-claims, scope: string) -> bool;

    /// Check if claims contain any of the specified scopes
    ///
    /// Returns true if at least one of the requested scopes is present.
    /// Useful for "requires one of these permissions" authorization.
    ///
    /// Example:
    /// ```
    /// if has-any-scope(claims, ["admin", "moderator"]) {
    ///     // User has either admin OR moderator permissions
    /// }
    /// ```
    has-any-scope: func(claims: jwt-claims, scopes: list<string>) -> bool;

    /// Check if claims contain all of the specified scopes
    ///
    /// Returns true only if ALL requested scopes are present.
    /// Useful for "requires all of these permissions" authorization.
    ///
    /// Example:
    /// ```
    /// if has-all-scopes(claims, ["read:data", "write:data"]) {
    ///     // User has both read AND write permissions
    /// }
    /// ```
    has-all-scopes: func(claims: jwt-claims, scopes: list<string>) -> bool;

    /// Get all scopes as list
    ///
    /// Returns the complete list of scopes granted to this token.
    ///
    /// Example:
    /// ```
    /// let scopes = get-scopes(claims);
    /// // ["read:users", "write:users", "admin"]
    /// ```
    get-scopes: func(claims: jwt-claims) -> list<string>;

    // ===== Audience Validation =====

    /// Validate audience claim
    ///
    /// Checks if any of the token's audiences match the expected value.
    /// CRITICAL: Always validate audience to prevent confused deputy attacks.
    ///
    /// The audience claim identifies which resource servers should accept this token.
    /// Accepting tokens intended for other services creates security vulnerabilities.
    ///
    /// Example:
    /// ```
    /// if !has-audience(claims, "https://api.example.com") {
    ///     return error("Token not intended for this service");
    /// }
    /// ```
    ///
    /// RFC Reference: RFC 7519 §4.1.3 (Audience Claim)
    has-audience: func(claims: jwt-claims, audience: string) -> bool;

    /// Get all audiences as list
    ///
    /// Returns the complete list of audiences for this token.
    /// Tokens can have multiple audiences if intended for multiple services.
    ///
    /// Example:
    /// ```
    /// let audiences = get-audiences(claims);
    /// // ["https://api.example.com", "https://admin.example.com"]
    /// ```
    get-audiences: func(claims: jwt-claims) -> list<string>;

    // ===== Time-Based Validation =====

    /// Check if token is expired
    ///
    /// Compares exp claim against current time with optional clock skew tolerance.
    /// Returns true if token has expired, false if still valid or no expiration set.
    ///
    /// Clock skew allows for small time differences between systems (typically 60 seconds).
    /// This prevents tokens from being rejected due to minor clock drift.
    ///
    /// Example:
    /// ```
    /// // Check with 60 second clock skew
    /// if is-expired(claims, Some(60)) {
    ///     return error("Token has expired");
    /// }
    /// ```
    ///
    /// RFC Reference: RFC 7519 §4.1.4 (Expiration Time Claim)
    is-expired: func(claims: jwt-claims, clock-skew-seconds: option<u64>) -> bool;

    /// Check if token time is valid (nbf <= now < exp)
    ///
    /// Validates both not-before (nbf) and expiration (exp) claims.
    /// Returns true if current time is within the valid window, false otherwise.
    ///
    /// This combines two checks:
    /// 1. Token is not being used before its nbf (not before) time
    /// 2. Token has not expired past its exp (expiration) time
    ///
    /// Example:
    /// ```
    /// if !is-valid-time(claims, Some(60)) {
    ///     return error("Token not yet valid or has expired");
    /// }
    /// ```
    ///
    /// RFC Reference: RFC 7519 §4.1.4 (exp), §4.1.5 (nbf)
    is-valid-time: func(claims: jwt-claims, clock-skew-seconds: option<u64>) -> bool;

    // ===== Standard Claim Extraction =====

    /// Get subject (user ID)
    ///
    /// Returns the 'sub' claim, which identifies who the token represents.
    /// For user tokens, this is typically the user ID.
    /// For M2M tokens, this might be a service identifier.
    ///
    /// Example:
    /// ```
    /// let user-id = get-subject(claims);
    /// // "user_123abc"
    /// ```
    ///
    /// RFC Reference: RFC 7519 §4.1.2 (Subject Claim)
    get-subject: func(claims: jwt-claims) -> string;

    /// Get issuer
    ///
    /// Returns the 'iss' claim, which identifies who created and signed the token.
    /// Typically the URL of the authorization server.
    ///
    /// Example:
    /// ```
    /// if let Some(issuer) = get-issuer(claims) {
    ///     // "https://auth.example.com"
    /// }
    /// ```
    ///
    /// RFC Reference: RFC 7519 §4.1.1 (Issuer Claim)
    get-issuer: func(claims: jwt-claims) -> option<string>;

    // ===== Custom Claims =====

    /// Get custom claim value by key
    ///
    /// Returns value if claim exists in custom-claims or standard fields.
    /// Useful for accessing provider-specific claims like org_id, roles, etc.
    ///
    /// Example:
    /// ```
    /// // Get organization ID from custom claims
    /// if let Some(org-id) = get-claim(claims, "org_id") {
    ///     // Use org-id for multi-tenant authorization
    /// }
    /// ```
    ///
    /// Note: Standard claims (sub, iss, aud, exp, etc.) should be accessed
    /// via their dedicated getter functions for type safety.
    get-claim: func(claims: jwt-claims, key: string) -> option<string>;

    /// Convert structured JWT claims to flat format for storage/serialization
    ///
    /// Useful when storing claims in session KV or passing to external systems.
    /// Most tools won't need this - claims are already structured in MessageContext!
    ///
    /// Returns all claims as string key-value pairs, including:
    /// - Standard claims (sub, iss, aud, exp, iat, nbf, jti)
    /// - Scopes as space-separated string
    /// - Custom claims
    ///
    /// Example:
    /// ```
    /// let flat-claims = flatten-claims(claims);
    /// // [("sub", "user_123"), ("iss", "https://auth.example.com"), ...]
    /// ```
    flatten-claims: func(claims: jwt-claims) -> list<tuple<string, string>>;
}
