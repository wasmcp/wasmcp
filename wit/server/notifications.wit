/// MCP notification channel resource
///
/// This resource encapsulates the ability to send notifications to MCP clients.
/// It abstracts the underlying transport mechanism (SSE, stdio, WebSocket, etc.)
/// and provides a type-safe interface for sending various notification types.
///
/// The notification channel is created by the transport and passed through the
/// middleware chain as a borrowed resource, allowing any component to send
/// notifications without needing to import additional interfaces or handle
/// transport-specific formatting.
///
/// <https://spec.modelcontextprotocol.io/specification/basic/notifications>
@since(version = 0.1.0-beta.3)
interface notifications {
    use wasi:io/streams@0.2.3.{
        output-stream,
        stream-error,
    };
    use wasmcp:protocol/mcp@0.1.0-beta.3.{
        progress-token,
        log-level,
        server-request,
        server-lists,
        server-subscriptions,
    };

    /// Errors that can occur when sending notifications
    @since(version = 0.1.0-beta.3)
    variant notification-error {
        /// An I/O error occurred writing to the underlying stream
        io(stream-error),
        /// Failed to serialize the notification to the transport format
        serialization(string),
        /// The channel has been closed or is unavailable
        channel-closed,
        /// An unexpected error occurred
        unexpected(string),
    }

    /// A notification channel that can send various types of notifications to the client.
    ///
    /// This resource is created and owned by the transport layer, which determines
    /// the appropriate serialization format (e.g., SSE for HTTP, newline-delimited
    /// JSON for stdio). Components receive a borrowed reference to this resource
    /// and can call its methods to send notifications.
    ///
    /// All notification methods are non-blocking and errors are non-fatal - if a
    /// notification fails to send, the component should continue processing.
    @since(version = 0.1.0-beta.3)
    resource notification-channel {
        finish: static func(channel: notification-channel) -> output-stream;

        constructor(output: output-stream);

        /// Send a progress notification for long-running operations.
        ///
        /// Progress notifications inform the client about the status of operations
        /// that take significant time to complete.
        ///
        /// Parameters:
        /// - `token`: Identifies the operation (from the original request's progress-token)
        /// - `progress`: Current progress value (interpretation depends on total)
        /// - `total`: Optional total value for percentage calculation (progress/total * 100)
        /// - `message`: Optional human-readable status message
        ///
        /// Example: progress = 45, total = 100 indicates 45% complete
        progress: func(
            token: progress-token,
            progress: f64,
            total: option<f64>,
            message: option<string>,
        ) -> result<_, notification-error>;

        /// Send a log message to the client.
        ///
        /// Servers can send log messages for debugging, monitoring, or informational
        /// purposes. The client determines how to display or store these logs.
        ///
        /// Parameters:
        /// - `message`: The log message content
        /// - `level`: Severity level (debug, info, notice, warning, error, critical, alert, emergency)
        /// - `logger`: Optional logger name for categorization (e.g., "calculator", "database")
        log: func(
            message: string,
            level: log-level,
            logger: option<string>,
        ) -> result<_, notification-error>;

        /// Notify the client that server capability lists have changed.
        ///
        /// When tools, prompts, or resources are added, removed, or modified,
        /// this notification tells the client to re-fetch the affected lists.
        ///
        /// Parameters:
        /// - `changes`: Flags indicating which lists changed (tools, prompts, resources)
        ///
        /// The client should call the corresponding list methods to get updated content.
        list-changed: func(
            changes: server-lists,
        ) -> result<_, notification-error>;

        /// Send updated content for subscribed resources or prompts.
        ///
        /// For resources and prompts that support subscriptions, this pushes
        /// new content to subscribed clients without requiring them to re-fetch.
        ///
        /// Parameters:
        /// - `updates`: The updated resource/prompt content
        ///
        /// Only clients that have explicitly subscribed will receive these updates.
        updated: func(
            updates: server-subscriptions,
        ) -> result<_, notification-error>;

        /// Send a request to the client.
        ///
        /// Servers can request information from clients, such as:
        /// - Sampling/completion requests for LLM operations
        /// - Roots listing for workspace discovery
        /// - Elicitation for user input
        ///
        /// Parameters:
        /// - `request`: The server-initiated request
        ///
        /// Note: Responses arrive through a different mechanism (typically a new
        /// HTTP request in HTTP transport). Use the sessions interface to correlate
        /// responses with requests.
        request: func(
            request: server-request,
        ) -> result<_, notification-error>;
    }
}