/// Model Context Protocol (MCP) is an open protocol that enables seamless integration between LLM applications and external data sources and tools.
/// https://modelcontextprotocol.io/specification/2025-06-18
package wasmcp:mcp@0.2.0-alpha.20;

/// Core type definitions for the Model Context Protocol, shared by other interfaces.
interface mcp-types {
    /// Role in a conversation
    enum role {
        user,
        assistant,
    }

    /// JSON value as a string
    /// This is a JSON-encoded value that should be parsed/validated by implementations
    type json-value = string;

    /// Metadata fields for extensibility
    /// Key-value pairs where values are JSON-encoded strings
    type meta-fields = list<tuple<string, string>>;
    
    /// Annotations provide hints to clients about how to handle data
    record annotations {
        /// Who this data is intended for
        audience: option<list<role>>,
        /// Priority from 0.0 (least) to 1.0 (most important)
        /// Implementations SHOULD validate this is within [0.0, 1.0] range
        priority: option<f64>,
        /// ISO 8601 timestamp of last modification
        /// Format: YYYY-MM-DDTHH:mm:ss[.sss]Z or Â±HH:MM offset
        last-modified: option<string>,
    }

    /// Base metadata pattern used throughout the protocol
    record base-metadata {
        /// Programmatic identifier
        name: string,
        /// Human-readable display name
        title: option<string>,
    }

    /// Content block types that can be included in messages
    variant content-block {
        text(text-content),
        image(image-content),
        audio(audio-content),
        resource-link(resource-link),
        embedded-resource(embedded-resource),
    }

    /// Text content with optional annotations
    record text-content {
        text: string,
        annotations: option<annotations>,
        meta: option<meta-fields>,
    }

    /// Image content as binary data
    record image-content {
        /// Base64-encoded image data
        data: list<u8>,
        /// MIME type (e.g., "image/png", "image/jpeg")
        mime-type: string,
        annotations: option<annotations>,
        meta: option<meta-fields>,
    }

    /// Audio content as binary data
    record audio-content {
        /// Base64-encoded audio data
        data: list<u8>,
        /// MIME type (e.g., "audio/wav", "audio/mp3")
        mime-type: string,
        annotations: option<annotations>,
        meta: option<meta-fields>,
    }

    /// Reference to a resource that the server can read
    /// Resource links included in prompts or tool results may not appear in resources/list
    record resource-link {
        /// URI of the resource
        uri: string,
        /// Programmatic identifier for the resource
        name: string,
        /// Human-readable display title (preferred for UI display)
        title: option<string>,
        /// Description of what this resource represents
        description: option<string>,
        /// MIME type of the resource, if known
        mime-type: option<string>,
        /// Size in bytes (before encoding), if known
        size: option<u64>,
        /// Client hints for handling
        annotations: option<annotations>,
        /// Extension metadata
        meta: option<meta-fields>,
    }

    /// Embedded resource content
    /// The contents of a resource, embedded into a prompt or tool call result
    record embedded-resource {
        /// The actual resource contents (text or binary)
        contents: resource-contents,
        /// Client hints for handling
        annotations: option<annotations>,
        /// Extension metadata
        meta: option<meta-fields>,
    }

    /// Resource contents can be either text or binary
    variant resource-contents {
        text(text-resource-contents),
        blob(blob-resource-contents),
    }

    record text-resource-contents {
        uri: string,
        mime-type: option<string>,
        text: string,
        meta: option<meta-fields>,
    }

    record blob-resource-contents {
        uri: string,
        mime-type: option<string>,
        /// Binary data
        blob: list<u8>,
        meta: option<meta-fields>,
    }

    /// JSON Schema representation
    /// Kept as a string since JSON Schema is complex
    /// and typically validated by specialized libraries
    type json-schema = string;
    

    /// Standard JSON-RPC and MCP error codes
    variant error-code {
        /// JSON-RPC standard errors
        parse-error,           // -32700
        invalid-request,       // -32600
        method-not-found,      // -32601
        invalid-params,        // -32602
        internal-error,        // -32603
        /// MCP-specific errors
        resource-not-found,
        tool-not-found,
        prompt-not-found,
        unauthorized,
        rate-limited,
        timeout,
        cancelled,
        /// Custom error with specific code
        custom-code(s32),
    }

    /// Standard error structure
    record mcp-error {
        code: error-code,
        message: string,
        /// Additional error context (JSON-encoded)
        data: option<string>,
    }

    /// Pagination cursor for list operations
    type cursor = string;

    /// Progress token for tracking long-running operations
    type progress-token = string;
    
    /// JSON-RPC request ID
    /// Can be either a string or number in JSON-RPC
    variant request-id {
        str(string),
        num(s64),
    }
    
    /// Message role for LLM interactions
    enum message-role {
        user,
        assistant,
        system,
    }
    
    /// Model selection preferences for LLM sampling
    record model-preferences {
        /// Hints for model selection
        hints: option<list<model-hint>>,
        /// Priority for cost optimization (0.0-1.0)
        cost-priority: option<f64>,
        /// Priority for speed (0.0-1.0)
        speed-priority: option<f64>,
        /// Priority for intelligence/capability (0.0-1.0)
        intelligence-priority: option<f64>,
    }
    
    /// Hint for model selection
    record model-hint {
        /// Name pattern to match (e.g., "claude", "gpt-4")
        name: option<string>,
    }
}
