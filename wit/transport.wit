use wasi:io/streams@0.2.8;

/// Streaming I/O for MCP servers
///
/// This interface enables servers to parse and send MCP messages over streams.
interface io {
    use streams.{
        input-stream,
        output-stream,
        stream-error,
    };
    use mcp.{
        error-code,
        request-id,
        transport-protocol,
    };
    use notifications.{
        client-notification,
        server-notification,
    };
    use methods.{
        client-method,
        client-result,
        server-method,
        server-result,
    };

    variant incoming-client-message {
        error(tuple<error-code, option<request-id>>),
        notification(client-notification),
        request(tuple<server-method, request-id>),
        %result(tuple<client-result, request-id>),
    }

    variant outgoing-client-message {
        error(tuple<error-code, option<request-id>>),
        notification(server-notification),
        request(tuple<client-method, request-id>),
        %result(tuple<server-result, request-id>),
    }

    /// Errors that can occur when sending messages to the client
    variant io-error {
        /// An I/O error occurred writing to the output stream
        %stream(stream-error),
        /// Invalid JSON-RPC message
        invalid-jsonrpc(string),
        /// Invalid MCP message
        invalid-mcp(string),
        /// An unexpected error occurred
        unexpected(string),
    }

    /// Read and deserialize an incoming message from the client
    parse: func(
        /// Input stream to read the bytes from
        input: borrow<input-stream>,
        /// The transport type
        transport: transport-protocol,
    ) -> result<incoming-client-message, io-error>;

    /// Serialize and write an outgoing message to the client
    send: func(
        /// Output stream to send the request over
        output: borrow<output-stream>,
        /// The transport type
        transport: transport-protocol,
        /// Outgoing message to the client
        message: outgoing-client-message,
    ) -> result<_, io-error>;
}

/// Decode and validate a JWT
interface auth {
    use mcp.{
        claims,
        jwt,
    };
    use io.{
        incoming-client-message,
    };

    /// Decode and validate a JWT.
    /// Returns the decoded claims if successful.
    ///
    /// If the token or its signature is invalid or the claims fail validation, it will return an error.
    decode: func(
        /// JWT from the Authorization header
        jwt: jwt,
    ) -> result<claims>;

    /// Authorize an incoming message against decoded claims.
    authorize: func(
        /// The incoming message
        message: incoming-client-message,
        /// Decoded JWT claims
        claims: claims,
    ) -> bool;
}

/// MCP session management and related features
///
/// This interface provides stateful session management for MCP servers, enabling:
/// - Persistent session data storage using WASI key-value stores
/// - Client elicitation (requesting information from clients)
/// - Session lifecycle management (initialize, terminate, delete)
/// - Async operations with pollable futures
///
/// Sessions are identified by unique IDs and can span multiple HTTP requests,
/// allowing servers to maintain state and context across interactions.
///
/// <https://modelcontextprotocol.io/specification/2025-06-18/basic/transports#session-management>
interface sessions {
    use streams.{
        output-stream,
        stream-error,
    };
    use wasi:io/poll@0.2.8.{
        pollable,
    };
    use elicitations.{
        elicit-params,
        elicit-result,
    };
    use wasmcp:keyvalue/store@0.1.0.{
        typed-value,
    };
    use wasmcp:auth/types@0.1.0.{jwt-claims};

    /// Errors that can occur during session operations
    variant session-error {
        /// An I/O error occurred in communication with the client
        io(stream-error),
        /// An error occurred in the underlying key-value store
        store(string),
        /// The specified session does not exist
        no-such-session,
        /// An unexpected error occurred
        unexpected(string),
    }

    /// A future representing a pending elicit result
    ///
    /// The elicit result is ready when the pollable indicates readiness.
    /// This enables async/await style operations where handlers can request
    /// information from clients and continue processing when the response arrives.
    resource future-elicit-result {
        /// Create a pollable to wait for the elicit result
        ///
        /// The pollable becomes ready when the client responds to the elicitation.
        /// Use WASI poll to wait for readiness before calling elicit-result().
        subscribe: func() -> pollable;

        /// Get the elicit result
        ///
        /// Precondition: Only call this after subscribe() indicates readiness.
        /// Calling before the result is ready may trap or return invalid data.
        elicit-result: func() -> elicit-result;
    }

    /// A bucket-backed session keyed by the Mcp-Session-Id HTTP header
    ///
    /// Sessions provide persistent storage and client communication primitives.
    /// Each session is identified by a cryptographically unique ID that's passed in the Mcp-Session-Id header.
    ///
    /// <https://modelcontextprotocol.io/specification/2025-06-18/basic/transports#session-management>
    resource session {
        /// Open an existing session by ID in the given bucket
        ///
        /// This is called when a client provides an Mcp-Session-Id header
        /// to resume a previous session. Returns an error if the session
        /// ID doesn't exist in the bucket.
        ///
        /// The bucket is consumed and owned by the session resource.
        open: static func(
            /// The session ID from Mcp-Session-Id header
            session-id: string,
            /// The ID of the session's underlying key-value store
            store-id: string,
        ) -> result<session, session-error>;

        /// Get the session ID
        ///
        /// This ID should be returned to clients in the Mcp-Session-Id header
        /// so they can resume the session in future requests.
        id: func() -> string;

        /// Get a persistent session value by key
        ///
        /// Returns the typed value with its type information. Supports string,
        /// JSON, u64, s64, bool, and raw bytes.
        ///
        /// Returns None if the key doesn't exist. Session data persists across
        /// HTTP requests as long as the session exists.
        get: func(
            /// The key to retrieve
            key: string,
        ) -> result<option<typed-value>, session-error>;

        /// Set a persistent session value by key
        ///
        /// Accepts a typed value (string, JSON, u64, s64, bool, or bytes).
        /// The value is immediately persisted to the underlying key-value store
        /// with a type tag for runtime type safety.
        ///
        /// Overwriting an existing key replaces the previous value.
        set: func(
            /// The key to store under
            key: string,
            /// The typed value to store
            value: typed-value,
        ) -> result<_, session-error>;

        /// Elicit information from the client
        ///
        /// This sends a request to the client asking for specific information
        /// (roots, sampling, etc.). The result is a future that can be polled
        /// to check when the client responds.
        ///
        /// The request is sent immediately on the provided output stream.
        /// The future should be stored and polled later to retrieve the response.
        ///
        /// <https://modelcontextprotocol.io/specification/2025-06-18/client/elicitation>
        elicit: func(
            /// Output stream to send the elicitation request
            client: borrow<output-stream>,
            /// The elicitation request to send
            elicitation: elicit-params,
        ) -> result<future-elicit-result, session-error>;

        /// Terminate the session, optionally providing a reason
        ///
        /// Termination marks the session as ended but does NOT delete session data.
        /// Clients can detect termination and stop sending requests. Use delete()
        /// to remove all session data.
        ///
        /// This operation is idempotent - calling multiple times has no effect.
        terminate: func(
            /// Optional reason for termination (shown to client)
            reason: option<string>,
        ) -> result<_, session-error>;
    }
}

/// Transport-layer session lifecycle management interface
///
/// This interface is used by transport components (HTTP, stdio, etc.) to manage
/// session lifecycle. User tools should NOT import this interface - they use
/// the session resource instead.
///
/// Storage format is an implementation detail managed internally by the
/// session-store component and is NOT exposed via this WIT interface.
interface session-manager {
    use sessions.{session-error};

    /// Initialize a new session
    ///
    /// Creates a new session with generated UUID, stores initial metadata,
    /// and returns the session ID for inclusion in response headers.
    ///
    /// # Arguments
    /// * `store-id` - Name of the WASI KV bucket to use for storage
    ///
    /// # Returns
    /// * `Ok(session-id)` - UUID v4 formatted session identifier
    /// * `Err(session-error)` - Storage or generation error
    ///
    initialize: func(store-id: string) -> result<string, session-error>;

    /// Validate session exists and is not terminated
    ///
    /// Checks that:
    /// 1. Session exists in storage
    /// 2. Session is not marked as terminated
    ///
    /// # Returns
    /// * `Ok(true)` - Session is valid and active
    /// * `Ok(false)` - Session exists but is terminated
    /// * `Err(no-such-session)` - Session does not exist
    /// * `Err(session-error)` - Storage error
    ///
    validate: func(session-id: string, store-id: string) -> result<bool, session-error>;

    /// Mark session as terminated (soft delete)
    ///
    /// Updates session metadata to mark as terminated with optional reason.
    /// Data remains in storage but session cannot be used for new requests.
    ///
    /// This is called by:
    /// * Transport layer when client sends termination request
    /// * User tools calling session.terminate()
    ///
    /// # Arguments
    /// * `session-id` - Session to terminate
    /// * `store-id` - WASI KV bucket name
    /// * `reason` - Optional human-readable termination reason
    ///
    mark-terminated: func(
        session-id: string,
        store-id: string,
        reason: option<string>
    ) -> result<_, session-error>;

    /// Delete session from storage (hard delete)
    ///
    /// Completely removes session and all associated data from storage.
    /// This is a destructive operation that cannot be undone.
    ///
    /// Typically called by transport layer during cleanup, not by user tools.
    ///
    delete-session: func(session-id: string, store-id: string) -> result<_, session-error>;

    /// Set session expiration timestamp
    ///
    /// Updates session metadata to expire at the specified Unix timestamp (seconds).
    /// Sessions are automatically invalidated when current time >= expires-at.
    ///
    /// Typically called by transport layer after JWT validation to align session
    /// lifetime with JWT expiration claim.
    ///
    /// # Arguments
    /// * `session-id` - Session to set expiration for
    /// * `store-id` - WASI KV bucket name
    /// * `expires-at` - Unix timestamp in seconds when session should expire
    ///
    set-expiration: func(
        session-id: string,
        store-id: string,
        expires-at: u64
    ) -> result<_, session-error>;
}
