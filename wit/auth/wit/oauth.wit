package wasmcp:auth@0.1.0;

/// Complete OAuth 2.1 error taxonomy covering all error scenarios
/// from RFC 6749, RFC 6750, RFC 7591, RFC 8414, RFC 9728
///
/// This interface provides RFC-compliant error handling for OAuth 2.1
/// Resource Servers, including proper WWW-Authenticate challenges and
/// JSON error responses.

interface errors {
    /// OAuth error with RFC-compliant structure
    /// Used for error responses in token endpoints and resource access
    record oauth-error {
        /// Error code (standard or extension)
        error: error-code,

        /// Human-readable ASCII description for debugging
        /// MUST NOT include non-ASCII characters (RFC 6749 §5.2)
        /// SHOULD NOT include sensitive information in production
        error-description: option<string>,

        /// URI to web page with error information
        /// Helps developers understand and fix the error
        error-uri: option<string>,
    }

    /// Complete error code taxonomy from OAuth specifications
    ///
    /// Organized by context where error occurs:
    /// - Authorization endpoint (RFC 6749 §4.1.2.1)
    /// - Token endpoint (RFC 6749 §5.2)
    /// - Resource access (RFC 6750 §3.1)
    /// - Client registration (RFC 7591 §3.2.2)
    variant error-code {
        // === Authorization Errors (RFC 6749 §4.1.2.1) ===

        /// Request missing required parameter, includes invalid parameter value,
        /// includes duplicate parameter, or is otherwise malformed
        invalid-request,

        /// Client is not authorized to request an authorization code
        /// using this method (e.g., client not registered)
        unauthorized-client,

        /// Resource owner or authorization server denied the request
        /// User explicitly rejected authorization
        access-denied,

        /// Authorization server does not support obtaining an authorization
        /// code using this method (e.g., response_type not supported)
        unsupported-response-type,

        /// Requested scope is invalid, unknown, malformed, or exceeds
        /// the scope granted by the resource owner
        invalid-scope,

        /// Authorization server encountered an unexpected condition
        /// that prevented it from fulfilling the request
        server-error,

        /// Authorization server is currently unable to handle the request
        /// due to temporary overloading or maintenance
        temporarily-unavailable,

        // === Token Endpoint Errors (RFC 6749 §5.2) ===

        /// Client authentication failed (e.g., unknown client, no client
        /// authentication included, or unsupported authentication method)
        invalid-client,

        /// Authorization grant is invalid, expired, revoked, does not match
        /// the redirection URI used in authorization request, or was issued
        /// to another client
        invalid-grant,

        /// Authorization server does not support this authorization grant type
        unsupported-grant-type,

        // === Resource Access Errors (RFC 6750 §3.1) ===

        /// Access token is missing, expired, malformed, or invalid for other reasons
        /// Presented token is not valid for accessing this resource
        invalid-token,

        /// Request requires higher privileges than provided by the access token
        /// Token is valid but does not have required scopes
        insufficient-scope,

        // === Registration Errors (RFC 7591 §3.2.2) ===

        /// One or more redirect_uri values are invalid
        invalid-redirect-uri,

        /// Value of one of the client metadata fields is invalid
        invalid-client-metadata,

        /// Software statement presented is invalid (malformed JWT, signature invalid)
        invalid-software-statement,

        /// Software statement presented is not approved by authorization server
        /// (e.g., from untrusted source or revoked)
        unapproved-software-statement,

        // === Extension Support ===

        /// Custom error code for OAuth extensions
        /// Use for non-standard errors or OpenID Connect extensions
        /// Example: "interaction_required", "login_required", "consent_required"
        extension(string),
    }

    /// Convert error-code to RFC-standard string representation
    ///
    /// Maps variant cases to their RFC-defined string values.
    /// Extension errors return their contained string.
    ///
    /// Example:
    /// ```
    /// let code = error-code::invalid-token;
    /// let str = error-code-to-string(code);
    /// // Returns: "invalid_token"
    /// ```
    error-code-to-string: func(code: error-code) -> string;

    /// Parse RFC-standard error string to error-code
    ///
    /// Returns none if error string is not recognized.
    /// Unrecognized strings can be wrapped in error-code::extension.
    ///
    /// Example:
    /// ```
    /// let code = parse-error-code("insufficient_scope");
    /// // Returns: Some(error-code::insufficient-scope)
    ///
    /// let unknown = parse-error-code("custom_error");
    /// // Returns: None (or could wrap as extension)
    /// ```
    parse-error-code: func(error-string: string) -> option<error-code>;

    /// Create WWW-Authenticate challenge for resource server responses
    ///
    /// Generates RFC 6750 §3 compliant challenge header value for HTTP 401 responses.
    /// Resource servers MUST include this header when rejecting requests due to
    /// authentication/authorization failures.
    ///
    /// Parameters:
    /// - realm: Optional protection space identifier (typically resource URL)
    /// - error: Optional error code describing why request was rejected
    /// - error-description: Optional human-readable error description
    /// - scope: List of scopes required for the resource (space-separated in output)
    ///
    /// Returns: Complete WWW-Authenticate header value
    ///
    /// Example:
    /// ```
    /// let challenge = create-bearer-challenge(
    ///     Some("https://api.example.com"),
    ///     Some(error-code::invalid-token),
    ///     Some("The access token expired"),
    ///     ["read", "write"]
    /// );
    /// // Returns:
    /// // Bearer realm="https://api.example.com",
    /// //        error="invalid_token",
    /// //        error_description="The access token expired",
    /// //        scope="read write"
    ///
    /// // Minimal challenge (no error details):
    /// let minimal = create-bearer-challenge(None, None, None, []);
    /// // Returns: "Bearer"
    /// ```
    ///
    /// Security Note:
    /// - In production, avoid detailed error_description to prevent information leakage
    /// - Always include realm to help clients identify the protection space
    /// - Include scope to help clients request appropriate permissions
    create-bearer-challenge: func(
        realm: option<string>,
        error: option<error-code>,
        error-description: option<string>,
        scope: list<string>,
    ) -> string;

    /// Create error response body for token endpoint
    ///
    /// Generates RFC 6749 §5.2 compliant JSON error response for token endpoint failures.
    /// Returns JSON string to be used as HTTP response body with Content-Type: application/json
    ///
    /// Response format:
    /// ```json
    /// {
    ///   "error": "invalid_grant",
    ///   "error_description": "Authorization code has expired",
    ///   "error_uri": "https://example.com/docs/errors/invalid_grant"
    /// }
    /// ```
    ///
    /// Example:
    /// ```
    /// let error = oauth-error {
    ///     error: error-code::invalid-grant,
    ///     error-description: Some("Authorization code has expired"),
    ///     error-uri: Some("https://example.com/docs/errors"),
    /// };
    ///
    /// let body = create-token-error-response(error);
    /// // Returns JSON string
    ///
    /// // HTTP Response:
    /// // HTTP/1.1 400 Bad Request
    /// // Content-Type: application/json
    /// // Cache-Control: no-store
    /// //
    /// // {"error":"invalid_grant","error_description":"Authorization code has expired","error_uri":"https://example.com/docs/errors"}
    /// ```
    ///
    /// Security Note:
    /// - error_description SHOULD be brief and SHOULD NOT include sensitive information
    /// - In production, consider omitting error_description or using generic messages
    create-token-error-response: func(error: oauth-error) -> string;
}

/// OAuth 2.0 Bearer Token Usage (RFC 6750)
///
/// This interface provides utilities for OAuth 2.1 Resource Servers to
/// extract and validate bearer tokens from HTTP requests.
///
/// RFC 6750 defines three methods for clients to present bearer tokens:
/// 1. Authorization Request Header Field (RECOMMENDED)
/// 2. Form-Encoded Body Parameter (NOT RECOMMENDED)
/// 3. URI Query Parameter (NOT RECOMMENDED - security risk)
///
/// Security Recommendations:
/// - Resource servers SHOULD only accept the Authorization header method
/// - Tokens in query parameters may appear in server logs, referrer headers
/// - Tokens in body parameters are less secure than header method
/// - Always validate token format before attempting to parse/verify

interface bearer {
    use errors.{oauth-error, error-code};

    /// Method by which bearer token was presented in HTTP request
    ///
    /// Based on RFC 6750 §2 - three authentication methods are defined,
    /// but only the header method is recommended for production use.
    enum bearer-method {
        /// Authorization request header field (RFC 6750 §2.1)
        ///
        /// Format: `Authorization: Bearer mF_9.B5f-4.1JqM`
        ///
        /// This is the RECOMMENDED method as it:
        /// - Does not appear in URL (logs, referrer headers)
        /// - Is not cached by proxies
        /// - Has clear authentication semantics
        ///
        /// Resource servers SHOULD only accept this method.
        header,

        /// Form-encoded body parameter (RFC 6750 §2.2)
        ///
        /// Format: `access_token=mF_9.B5f-4.1JqM` in request body
        ///
        /// Requirements:
        /// - Content-Type MUST be `application/x-www-form-urlencoded`
        /// - MUST NOT be used with HTTP GET
        /// - MUST NOT be used if Authorization header present
        ///
        /// NOT RECOMMENDED - use header method instead.
        body,

        /// URI query parameter (RFC 6750 §2.3)
        ///
        /// Format: `?access_token=mF_9.B5f-4.1JqM` in request URL
        ///
        /// Security Concerns:
        /// - Tokens may appear in server logs
        /// - Tokens may appear in referrer headers when following links
        /// - URLs may be cached by proxies
        ///
        /// NOT RECOMMENDED - use header method instead.
        /// MAY be used when header method is not feasible (e.g., HTML forms).
        query,
    }

    /// Extract bearer token from HTTP request
    ///
    /// Examines all three presentation methods (header, body, query) and returns
    /// the token if found. Returns error if token is presented in multiple locations
    /// (RFC 6750 §3.1 - MUST NOT use more than one method).
    ///
    /// This function does NOT validate the token itself (signature, expiration, etc.),
    /// it only extracts and validates the presentation format.
    ///
    /// Parameters:
    /// - headers: HTTP request headers as key-value pairs
    /// - body-params: Optional form-encoded body parameters (for POST requests)
    /// - query-params: Optional URL query parameters
    ///
    /// Returns:
    /// - Ok: (token, method) - extracted token and the method used
    /// - Err: oauth-error with error-code::invalid-request if malformed
    ///
    /// Errors:
    /// - Multiple methods used (token in header AND body/query)
    /// - Malformed Authorization header
    /// - Invalid token format (non-b64token characters)
    ///
    /// Example:
    /// ```
    /// // Request: GET /resource HTTP/1.1
    /// //          Authorization: Bearer abc123xyz
    ///
    /// let headers = [("authorization", "Bearer abc123xyz")];
    /// let result = extract-bearer-token(headers, None, None);
    ///
    /// match result {
    ///     Ok((token, method)) => {
    ///         // token = "abc123xyz"
    ///         // method = bearer-method::header
    ///
    ///         // Now validate token (signature, expiration, etc.)
    ///         validate-jwt(token)?;
    ///     },
    ///     Err(err) => {
    ///         // err.error = error-code::invalid-request
    ///         // err.error-description = "Multiple bearer tokens presented"
    ///         return http-401(err);
    ///     }
    /// }
    /// ```
    ///
    /// Security Note:
    /// After extraction, always:
    /// 1. Verify the bearer-method is allowed (use is-method-allowed)
    /// 2. Validate token signature and expiration
    /// 3. Validate audience and scope
    extract-bearer-token: func(
        headers: list<tuple<string, string>>,
        body-params: option<list<tuple<string, string>>>,
        query-params: option<list<tuple<string, string>>>,
    ) -> result<tuple<string, bearer-method>, oauth-error>;

    /// Check if bearer method is allowed by resource server policy
    ///
    /// Resource servers define which bearer token presentation methods they accept.
    /// RFC 6750 recommends only accepting the Authorization header method.
    ///
    /// Parameters:
    /// - method: The method used to present the token
    /// - allowed-methods: List of methods accepted by this resource server
    ///
    /// Returns: true if method is allowed, false otherwise
    ///
    /// Example:
    /// ```
    /// // Policy: Only accept Authorization header
    /// let allowed = [bearer-method::header];
    ///
    /// let (token, method) = extract-bearer-token(...)?;
    ///
    /// if !is-method-allowed(method, allowed) {
    ///     return Err(oauth-error {
    ///         error: error-code::invalid-request,
    ///         error-description: Some("Only Authorization header accepted"),
    ///         error-uri: None,
    ///     });
    /// }
    ///
    /// // Safe to proceed with token validation
    /// ```
    ///
    /// Recommended Policies:
    /// - Production: [bearer-method::header] (most secure)
    /// - Development: [bearer-method::header, bearer-method::query] (for testing)
    /// - Never recommended: All three methods (reduces security)
    is-method-allowed: func(
        method: bearer-method,
        allowed-methods: list<bearer-method>
    ) -> bool;

    /// Validate bearer token format per RFC 6750
    ///
    /// Checks that token contains only characters allowed in b64token grammar.
    /// Does NOT validate token signature or expiration (use JWT validation for that).
    ///
    /// RFC 6750 §2.1 defines b64token as:
    /// ```
    /// b64token = 1*( ALPHA / DIGIT / "-" / "." / "_" / "~" / "+" / "/" ) *"="
    /// ```
    ///
    /// Parameters:
    /// - token: The bearer token string to validate
    ///
    /// Returns: true if format is valid, false otherwise
    ///
    /// Example:
    /// ```
    /// if !is-valid-bearer-token-format("abc123") {
    ///     return Err(oauth-error {
    ///         error: error-code::invalid-request,
    ///         error-description: Some("Token contains invalid characters"),
    ///         error-uri: None,
    ///     });
    /// }
    ///
    /// // Format is valid, proceed to JWT validation
    /// ```
    ///
    /// Note: This is a lightweight format check. Even if format is valid,
    /// the token may still be:
    /// - Expired (check exp claim)
    /// - Revoked (check with introspection endpoint)
    /// - Invalid signature (verify with JWKS)
    /// - Wrong audience (check aud claim)
    is-valid-bearer-token-format: func(token: string) -> bool;
}

/// OAuth 2.0 Token Introspection (RFC 7662)
///
/// Allows resource servers to query authorization servers about the
/// current state of opaque access tokens. This is essential when:
/// - Tokens are not self-contained JWTs
/// - Real-time revocation status is required
/// - Token metadata needs to be retrieved
///
/// Security Notes:
/// - Introspection endpoint requires client authentication
/// - Results should be cached to reduce latency
/// - Introspection reveals token information to the caller

interface introspection {
    use types.{jwt-claims};
    use errors.{oauth-error};

    /// Token introspection request (RFC 7662 §2.1)
    ///
    /// Sent to the authorization server's introspection endpoint
    /// to query the status and metadata of an access or refresh token.
    record introspection-request {
        /// REQUIRED: The token to introspect
        /// Can be an access token or refresh token (opaque or JWT)
        token: string,

        /// OPTIONAL: Hint about token type
        ///
        /// Values: "access_token" or "refresh_token"
        /// Helps the authorization server optimize token lookup
        /// Server MAY ignore this hint
        ///
        /// Example: If you know it's an access token, set to "access_token"
        token-type-hint: option<string>,
    }

    /// Token introspection response (RFC 7662 §2.2)
    ///
    /// Contains the current state and metadata of the token.
    /// If active=false, all optional fields MUST be omitted.
    /// If active=true, fields describe the token's current state.
    record introspection-response {
        /// REQUIRED: Whether token is currently active
        ///
        /// Returns false if token is:
        /// - Expired (past exp time)
        /// - Revoked
        /// - Invalid
        /// - Unknown to the authorization server
        ///
        /// If false, all fields below MUST be omitted per RFC 7662
        active: bool,

        // ===== Fields below ONLY present if active=true =====

        /// Space-separated scope values authorized for this token
        /// Example: ["read:users", "write:posts"]
        scope: option<list<string>>,

        /// Client identifier this token was issued to
        /// The OAuth 2.0 client_id of the client that requested this token
        client-id: option<string>,

        /// Human-readable username of the resource owner
        /// End-user identifier (not necessarily unique)
        username: option<string>,

        /// Type of token (e.g., "Bearer", "mac")
        /// Indicates how the token should be used
        token-type: option<string>,

        /// Token expiration time (unix timestamp)
        /// Seconds since 1970-01-01T00:00:00Z UTC
        /// Token MUST NOT be accepted after this time
        exp: option<u64>,

        /// Token issued-at time (unix timestamp)
        /// When the token was originally issued
        iat: option<u64>,

        /// Token not-before time (unix timestamp)
        /// Token MUST NOT be accepted before this time
        nbf: option<u64>,

        /// Subject identifier (who the token represents)
        /// Usually the resource owner or end-user identifier
        /// For client_credentials grant, may be the client_id
        sub: option<string>,

        /// Intended audience for this token
        /// Resource servers that should accept this token
        /// Can be a single value or array
        aud: option<list<string>>,

        /// Token issuer identifier
        /// Authorization server that issued the token
        /// Typically an HTTPS URL
        iss: option<string>,

        /// JWT ID - unique identifier for this token
        /// Prevents replay attacks
        jti: option<string>,

        /// Additional extension claims (as JSON strings)
        /// Authorization server-specific metadata
        /// Examples: roles, permissions, tenant_id, etc.
        additional-claims: list<tuple<string, string>>,
    }

    /// Convert introspection response to jwt-claims structure
    ///
    /// Maps the introspection response fields to the standard jwt-claims
    /// record, allowing use of all helpers from wasmcp:auth/helpers.
    ///
    /// Returns none if token is not active.
    ///
    /// Example:
    /// ```
    /// let response = introspect-token(endpoint, request, credentials)?;
    ///
    /// if let Some(claims) = to-jwt-claims(response) {
    ///     // Now use standard helpers
    ///     use helpers.{has-scope, has-audience};
    ///
    ///     if !has-audience(claims, "https://api.example.com") {
    ///         return Err("Wrong audience");
    ///     }
    ///
    ///     if !has-scope(claims, "admin") {
    ///         return Err("Requires admin scope");
    ///     }
    ///
    ///     // Token is valid and authorized
    /// } else {
    ///     // Token is not active (expired, revoked, or invalid)
    ///     return Err(error-code::invalid-token);
    /// }
    /// ```
    to-jwt-claims: func(response: introspection-response) -> option<jwt-claims>;

    /// Make introspection request to authorization server
    ///
    /// Sends a token introspection request to the AS introspection endpoint
    /// and returns the response. Requires client authentication.
    ///
    /// Parameters:
    /// - introspection-endpoint: AS introspection URL (from AS metadata)
    /// - request: Token and optional type hint
    /// - client-credentials: (client_id, client_secret) for authentication
    ///
    /// Returns:
    /// - Ok: introspection-response with token status
    /// - Err: oauth-error if request fails
    ///
    /// HTTP Request Format:
    /// ```
    /// POST /introspect HTTP/1.1
    /// Host: as.example.com
    /// Content-Type: application/x-www-form-urlencoded
    /// Authorization: Basic czZCaGRSa3F0MzpnWDFmQmF0M2JW
    ///
    /// token=mF_9.B5f-4.1JqM&token_type_hint=access_token
    /// ```
    ///
    /// Example:
    /// ```
    /// // After extracting token from Authorization header
    /// let token = "opaque-token-abc123";
    ///
    /// let request = introspection-request {
    ///     token,
    ///     token-type-hint: Some("access_token"),
    /// };
    ///
    /// let response = introspect-token(
    ///     "https://as.example.com/introspect",
    ///     request,
    ///     ("my-resource-server", "secret123")
    /// )?;
    ///
    /// if !response.active {
    ///     return Err("Token is not active");
    /// }
    ///
    /// // Check expiration
    /// if let Some(exp) = response.exp {
    ///     let now = current-unix-timestamp();
    ///     if now >= exp {
    ///         return Err("Token has expired");
    ///     }
    /// }
    ///
    /// // Check scope
    /// if let Some(scopes) = response.scope {
    ///     if !scopes.contains("read") {
    ///         return Err("Insufficient scope");
    ///     }
    /// }
    ///
    /// // Token is valid, proceed with request
    /// ```
    ///
    /// Performance Note:
    /// Introspection adds network latency to every request. Consider:
    /// - Caching introspection responses (with short TTL)
    /// - Using self-contained JWTs instead of opaque tokens
    /// - Rate limiting introspection requests
    ///
    /// Security Note:
    /// - Always use HTTPS for introspection endpoint
    /// - Protect client credentials (store securely)
    /// - Validate the introspection response signature if signed
    introspect-token: func(
        introspection-endpoint: string,
        request: introspection-request,
        client-credentials: tuple<string, string>,
    ) -> result<introspection-response, oauth-error>;
}

/// OAuth 2.0 Protected Resource Metadata (RFC 9728)
///
/// Enables resource servers to publish their capabilities and requirements
/// via a well-known discovery endpoint. This allows:
/// - Clients to discover which authorization servers protect this resource
/// - Automatic configuration of OAuth clients
/// - Publishing supported scopes, bearer methods, and advanced features
///
/// Well-Known URL Pattern:
/// https://resource.example.com/.well-known/oauth-protected-resource
/// https://resource.example.com/.well-known/oauth-protected-resource/resource1

interface resource-metadata {
    /// Protected resource metadata (RFC 9728 §2)
    ///
    /// Published at /.well-known/oauth-protected-resource
    /// Describes the resource server's OAuth capabilities and requirements.
    record protected-resource-metadata {
        /// REQUIRED: Resource identifier
        ///
        /// Must be an HTTPS URL with no fragment component
        /// Identifies this protected resource uniquely
        ///
        /// Example: "https://api.example.com"
        /// JSON field name: "resource"
        %resource: string,

        /// OPTIONAL: List of authorization server issuers
        ///
        /// Array of AS issuer identifiers from RFC 8414
        /// Clients should obtain tokens from one of these servers
        /// Each issuer should have a corresponding AS metadata endpoint
        ///
        /// Example: ["https://auth.example.com", "https://login.example.com"]
        ///
        /// If omitted, clients must discover the AS through other means
        authorization-servers: list<string>,

        /// OPTIONAL: Resource server's JWK Set URL
        ///
        /// Contains public keys for verifying signed responses from this resource
        /// Not used for token validation (use AS jwks_uri for that)
        ///
        /// Example: "https://api.example.com/.well-known/jwks.json"
        jwks-uri: option<string>,

        /// RECOMMENDED: Scopes used for this resource
        ///
        /// Array of OAuth scope values that apply to this resource
        /// Helps clients understand what permissions are available
        ///
        /// Example: ["read:users", "write:users", "admin"]
        scopes-supported: list<string>,

        /// OPTIONAL: Supported bearer token methods
        ///
        /// How this resource accepts bearer tokens (RFC 6750 §2)
        /// Values: "header", "body", "query"
        ///
        /// Example: ["header"] (most secure - recommended)
        ///
        /// Empty array indicates no bearer methods supported
        /// If omitted, clients should assume header method is supported
        bearer-methods-supported: list<string>,

        /// OPTIONAL: Signing algorithms for signed responses
        ///
        /// JWS algorithms supported for signing responses from this resource
        /// Values from IANA JOSE Algorithm registry (RS256, ES256, etc.)
        ///
        /// Example: ["RS256", "ES256"]
        resource-signing-alg-values-supported: list<string>,

        /// OPTIONAL: Human-readable resource name
        ///
        /// Localized name for display to end-users
        /// Can include language tag (e.g., "resource_name#en")
        ///
        /// Example: "Example API", "Example API#en", "API de ejemplo#es"
        resource-name: option<string>,

        /// OPTIONAL: Developer documentation URL
        ///
        /// Link to API documentation for developers
        /// Helps clients understand how to use this resource
        ///
        /// Example: "https://docs.example.com/api"
        resource-documentation: option<string>,

        /// OPTIONAL: Data usage policy URL
        ///
        /// Link to policy describing how data is used/stored
        /// Privacy policy or data handling practices
        ///
        /// Example: "https://example.com/privacy"
        resource-policy-uri: option<string>,

        /// OPTIONAL: Terms of service URL
        ///
        /// Link to legal terms for using this resource
        ///
        /// Example: "https://example.com/terms"
        resource-tos-uri: option<string>,

        /// OPTIONAL: Mutual TLS support (RFC 8705)
        ///
        /// Whether this resource requires/supports mTLS certificate-bound tokens
        /// If true, tokens must include cnf.x5t#S256 claim
        ///
        /// Default: false
        tls-client-certificate-bound-access-tokens: bool,

        /// OPTIONAL: Authorization details types (RFC 9396)
        ///
        /// Rich authorization request types supported by this resource
        /// Enables fine-grained authorization beyond scopes
        ///
        /// Example: ["payment_initiation", "account_information"]
        authorization-details-types-supported: list<string>,

        /// OPTIONAL: DPoP signing algorithms (RFC 9449)
        ///
        /// JWS algorithms supported for DPoP proof validation
        /// If present, resource supports DPoP-bound tokens
        ///
        /// Example: ["RS256", "ES256"]
        dpop-signing-alg-values-supported: list<string>,

        /// OPTIONAL: DPoP requirement
        ///
        /// Whether DPoP-bound tokens are required (not just supported)
        /// If true, tokens without DPoP binding will be rejected
        ///
        /// Default: false
        dpop-bound-access-tokens-required: bool,

        /// OPTIONAL: Signed metadata as JWT
        ///
        /// Self-signed JWT containing this metadata as claims
        /// Enables third-party attestation and offline verification
        /// Must include 'iss' claim matching the resource identifier
        ///
        /// Format: JWS with metadata as payload
        signed-metadata: option<string>,
    }

    /// Fetch resource metadata from well-known location
    ///
    /// Performs HTTP GET to /.well-known/oauth-protected-resource
    /// and parses the JSON response.
    ///
    /// Parameters:
    /// - resource-url: Base URL of the resource server
    ///
    /// Returns:
    /// - Ok: parsed protected-resource-metadata
    /// - Err: error message if fetch or parse fails
    ///
    /// Example:
    /// ```
    /// let metadata = fetch-metadata("https://api.example.com")?;
    ///
    /// // Check which authorization servers are accepted
    /// for as_issuer in metadata.authorization-servers {
    ///     println!("Accepted AS: {}", as_issuer);
    ///     // as_issuer = "https://auth.example.com"
    /// }
    ///
    /// // Check supported scopes
    /// println!("Available scopes: {:?}", metadata.scopes-supported);
    ///
    /// // Check bearer methods
    /// if metadata.bearer-methods-supported.contains("header") {
    ///     println!("Use Authorization: Bearer header");
    /// }
    /// ```
    ///
    /// HTTP Request:
    /// ```
    /// GET /.well-known/oauth-protected-resource HTTP/1.1
    /// Host: api.example.com
    /// Accept: application/json
    /// ```
    ///
    /// HTTP Response:
    /// ```
    /// HTTP/1.1 200 OK
    /// Content-Type: application/json
    ///
    /// {
    ///   "resource": "https://api.example.com",
    ///   "authorization_servers": ["https://auth.example.com"],
    ///   "scopes_supported": ["read", "write", "admin"],
    ///   "bearer_methods_supported": ["header"]
    /// }
    /// ```
    fetch-metadata: func(
        resource-url: string
    ) -> result<protected-resource-metadata, string>;

    /// Validate resource metadata
    ///
    /// Ensures metadata is valid and matches expected resource identifier.
    /// Critical security check per RFC 9728 §3.3 - prevents metadata confusion.
    ///
    /// Checks:
    /// - 'resource' field is present
    /// - 'resource' matches expected value
    /// - 'resource' is HTTPS URL
    /// - 'resource' has no fragment
    ///
    /// Parameters:
    /// - metadata: Fetched metadata to validate
    /// - expected-resource: Resource identifier we expect
    ///
    /// Returns:
    /// - Ok: metadata is valid
    /// - Err: validation error message
    ///
    /// Example:
    /// ```
    /// let resource_url = "https://api.example.com";
    /// let metadata = fetch-metadata(resource_url)?;
    ///
    /// validate-metadata(metadata, resource_url)?;
    /// // Safe to use metadata now
    ///
    /// // Store for configuration
    /// if !metadata.authorization-servers.is-empty() {
    ///     let as_url = metadata.authorization-servers[0];
    ///     // Fetch AS metadata from as_url
    /// }
    /// ```
    ///
    /// Security Note:
    /// ALWAYS validate metadata before using it. Attackers could serve
    /// malicious metadata pointing to rogue authorization servers.
    validate-metadata: func(
        metadata: protected-resource-metadata,
        expected-resource: string
    ) -> result<_, string>;

    /// Parse WWW-Authenticate header for resource metadata URL
    ///
    /// Extracts the resource_metadata parameter from a Bearer challenge.
    /// Resource servers use this to advertise their metadata URL dynamically.
    ///
    /// Per RFC 9728 §5, resource servers MAY include resource_metadata in
    /// WWW-Authenticate headers to signal metadata changes.
    ///
    /// Parameters:
    /// - www-authenticate-header: Value of WWW-Authenticate header
    ///
    /// Returns: Metadata URL if present, none otherwise
    ///
    /// Example:
    /// ```
    /// // HTTP Response:
    /// // HTTP/1.1 401 Unauthorized
    /// // WWW-Authenticate: Bearer realm="https://api.example.com",
    /// //                           resource_metadata="https://api.example.com/.well-known/oauth-protected-resource",
    /// //                           error="invalid_token"
    ///
    /// let header = "Bearer realm=\"https://api.example.com\", resource_metadata=\"https://api.example.com/.well-known/oauth-protected-resource\", error=\"invalid_token\"";
    ///
    /// if let Some(metadata_url) = parse-www-authenticate-metadata(header) {
    ///     // metadata_url = "https://api.example.com/.well-known/oauth-protected-resource"
    ///
    ///     // Fetch updated metadata
    ///     let metadata = fetch-metadata-from-url(metadata_url)?;
    ///
    ///     // Check if authorization servers changed
    ///     if metadata.authorization-servers != old_metadata.authorization-servers {
    ///         println!("Authorization servers updated!");
    ///     }
    /// }
    /// ```
    ///
    /// Use Case:
    /// Resource servers can signal metadata changes without clients
    /// having to poll the well-known endpoint. When clients receive
    /// this header, they should re-fetch and cache the metadata.
    parse-www-authenticate-metadata: func(
        www-authenticate-header: string
    ) -> option<string>;
}

/// Complete OAuth 2.1 Resource Server implementation.
///
/// Use this world for components that implement OAuth-protected
/// endpoints with full protocol support.
///
/// Includes:
/// - JWT validation (types & helpers from jwt.wit)
/// - bearer: RFC 6750 bearer token extraction
/// - introspection: RFC 7662 token introspection
/// - resource-metadata: RFC 9728 resource server metadata
/// - errors: OAuth error codes and WWW-Authenticate challenges
///
/// Example use cases:
/// - OAuth 2.1 resource servers
/// - API gateways with OAuth validation
/// - MCP servers with authentication
world oauth {
    include jwt;
    export bearer;
    export introspection;
    export resource-metadata;
    export errors;
}
