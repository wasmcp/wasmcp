use std::sync::OnceLock;

use anyhow::Result;
use serde_json::{json, Value};
use spin_sdk::http::{IntoResponse, Request, Response};

// Bindings are generated by cargo-component
#[allow(warnings)]
mod bindings;

use bindings::wasmcp::mcp::authorization;
use bindings::wasmcp::mcp::authorization_types::ProviderAuthConfig;

mod capabilities;
mod auth;
mod error;
mod constants;
use error::{ErrorCode, ErrorCodeExt, McpError};
use constants::{methods, oauth};
use auth::AuthContext;

/// Static storage for auth configuration
static AUTH_CONFIG: OnceLock<Option<ProviderAuthConfig>> = OnceLock::new();

/// Get the cached auth configuration
/// Returns None if provider doesn't require auth
fn get_auth_config() -> &'static Option<ProviderAuthConfig> {
    AUTH_CONFIG.get_or_init(|| {
        // Provider can return None to disable auth
        authorization::get_auth_config()
    })
}

/// Check if auth is enabled (provider returned Some config)
fn is_auth_enabled() -> bool {
    get_auth_config().is_some()
}

#[spin_sdk::http_component]
async fn handle_request(req: Request) -> Result<impl IntoResponse> {
    let path = req.path();

    // Handle OAuth discovery endpoints iff auth is enabled
    if is_auth_enabled() {
        let provider_config = get_auth_config()
            .as_ref()
            .expect("auth is enabled but config is None");

        if path == oauth::WELL_KNOWN_RESOURCE_METADATA {
            return auth::handle_resource_metadata(req.uri(), provider_config);
        }
        if path == oauth::WELL_KNOWN_SERVER_METADATA {
            // For compatibility with clients that don't support resource metadata,
            // we provide the authorization server metadata directly
            return auth::handle_server_metadata(provider_config);
        }
    }

    // Apply authorization iff auth is enabled
    let auth_context = if is_auth_enabled() {
        let provider_config = get_auth_config()
            .as_ref()
            .expect("auth is enabled but config is None");
        
        match auth::authorize_request(&req, provider_config).await {
            Ok(context) => Some(context),
            Err(auth_error) => return Ok(auth::create_auth_error_response(auth_error)),
        }
    } else {
        None
    };

    // Handle standard JSON-RPC endpoint
    let body = req.body();
    let request_str = std::str::from_utf8(body)?;

    // Parse JSON-RPC request
    let json_request: Value = serde_json::from_str(request_str)?;

    // Extract method and params
    let method = json_request["method"]
        .as_str()
        .ok_or_else(|| anyhow::anyhow!("Missing method"))?;
    let params = json_request.get("params").cloned();
    let id = json_request.get("id").cloned();

    // Route to appropriate handler
    match route_method(method, params, auth_context).await {
        Ok(result) => {
            let response = if let Some(id) = id {
                json!({
                    "jsonrpc": "2.0",
                    "result": result,
                    "id": id
                })
            } else {
                // Notification (no id) - no response expected
                return Ok(Response::builder()
                    .status(204)
                    .header("content-type", "application/json")
                    .body(())
                    .build());
            };

            Ok(Response::builder()
                .status(200)
                .header("content-type", "application/json")
                .body(response.to_string())
                .build())
        }
        Err(error) => {
            let error_response = json!({
                "jsonrpc": "2.0",
                "error": {
                    "code": error.code.to_code(),
                    "message": error.message,
                    "data": error.data
                },
                "id": id
            });

            Ok(Response::builder()
                .status(200)
                .header("content-type", "application/json")
                .body(error_response.to_string())
                .build())
        }
    }
}

/// Route method calls to appropriate handlers
/// Auth context is None if auth is disabled by provider
async fn route_method(
    method: &str,
    params: Option<Value>,
    auth_context: Option<AuthContext>,
) -> Result<Value, McpError> {
    match method {
        // Core lifecycle methods - always available
        methods::INITIALIZE => capabilities::lifecycle::initialize(params),
        methods::INITIALIZED => capabilities::lifecycle::client_initialized(),
        methods::PING => Ok(json!({})), // Simple ping response
        methods::SHUTDOWN => capabilities::lifecycle::shutdown(),

        // Tools methods - only if feature enabled
        #[cfg(feature = "tools")]
        methods::TOOLS_LIST => capabilities::tools::list_tools(params),
        #[cfg(feature = "tools")]
        methods::TOOLS_CALL => capabilities::tools::call_tool(params, auth_context.as_ref()),

        // Resources methods - only if feature enabled
        #[cfg(feature = "resources")]
        methods::RESOURCES_LIST => capabilities::resources::list_resources(params),
        #[cfg(feature = "resources")]
        methods::RESOURCES_READ => capabilities::resources::read_resource(params),

        // Prompts methods - only if feature enabled
        #[cfg(feature = "prompts")]
        methods::PROMPTS_LIST => capabilities::prompts::list_prompts(params),
        #[cfg(feature = "prompts")]
        methods::PROMPTS_GET => capabilities::prompts::get_prompt(params),

        // Completion methods - only if feature enabled
        #[cfg(feature = "completion")]
        methods::COMPLETION_COMPLETE => capabilities::completion::complete(params),

        _ => Err(McpError {
            code: ErrorCode::MethodNotFound,
            message: format!("Method '{method}' not found"),
            data: None,
        }),
    }
}