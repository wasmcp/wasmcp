// Generated by `wit-bindgen` 0.41.0. DO NOT EDIT!
// Options used:
//   * runtime_path: "wit_bindgen_rt"
//   * additional derives ["Clone"]
#[rustfmt::skip]
#[allow(dead_code, clippy::all)]
pub mod wasi {
    pub mod clocks {
        /// WASI Wall Clock is a clock API intended to let users query the current
        /// time. The name "wall" makes an analogy to a "clock on the wall", which
        /// is not necessarily monotonic as it may be reset.
        ///
        /// It is intended to be portable at least between Unix-family platforms and
        /// Windows.
        ///
        /// A wall clock is a clock which measures the date and time according to
        /// some external reference.
        ///
        /// External references may be reset, so this clock is not necessarily
        /// monotonic, making it unsuitable for measuring elapsed time.
        ///
        /// It is intended for reporting the current date and time for humans.
        #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
        pub mod wall_clock {
            #[used]
            #[doc(hidden)]
            static __FORCE_SECTION_REF: fn() = super::super::super::__link_custom_section_describing_imports;
            /// A time and date in seconds plus nanoseconds.
            #[repr(C)]
            #[derive(Clone, Copy)]
            pub struct Datetime {
                pub seconds: u64,
                pub nanoseconds: u32,
            }
            impl ::core::fmt::Debug for Datetime {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("Datetime")
                        .field("seconds", &self.seconds)
                        .field("nanoseconds", &self.nanoseconds)
                        .finish()
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            /// Read the current value of the clock.
            ///
            /// This clock is not monotonic, therefore calling this function repeatedly
            /// will not necessarily produce a sequence of non-decreasing values.
            ///
            /// The returned timestamps represent the number of seconds since
            /// 1970-01-01T00:00:00Z, also known as [POSIX's Seconds Since the Epoch],
            /// also known as [Unix Time].
            ///
            /// The nanoseconds field of the output is always less than 1000000000.
            ///
            /// [POSIX's Seconds Since the Epoch]: https://pubs.opengroup.org/onlinepubs/9699919799/xrat/V4_xbd_chap04.html#tag_21_04_16
            /// [Unix Time]: https://en.wikipedia.org/wiki/Unix_time
            pub fn now() -> Datetime {
                unsafe {
                    #[repr(align(8))]
                    struct RetArea([::core::mem::MaybeUninit<u8>; 16]);
                    let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 16]);
                    let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "wasi:clocks/wall-clock@0.2.0")]
                    unsafe extern "C" {
                        #[link_name = "now"]
                        fn wit_import1(_: *mut u8);
                    }
                    #[cfg(not(target_arch = "wasm32"))]
                    unsafe extern "C" fn wit_import1(_: *mut u8) {
                        unreachable!()
                    }
                    unsafe { wit_import1(ptr0) };
                    let l2 = *ptr0.add(0).cast::<i64>();
                    let l3 = *ptr0.add(8).cast::<i32>();
                    let result4 = Datetime {
                        seconds: l2 as u64,
                        nanoseconds: l3 as u32,
                    };
                    result4
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            /// Query the resolution of the clock.
            ///
            /// The nanoseconds field of the output is always less than 1000000000.
            pub fn resolution() -> Datetime {
                unsafe {
                    #[repr(align(8))]
                    struct RetArea([::core::mem::MaybeUninit<u8>; 16]);
                    let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 16]);
                    let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "wasi:clocks/wall-clock@0.2.0")]
                    unsafe extern "C" {
                        #[link_name = "resolution"]
                        fn wit_import1(_: *mut u8);
                    }
                    #[cfg(not(target_arch = "wasm32"))]
                    unsafe extern "C" fn wit_import1(_: *mut u8) {
                        unreachable!()
                    }
                    unsafe { wit_import1(ptr0) };
                    let l2 = *ptr0.add(0).cast::<i64>();
                    let l3 = *ptr0.add(8).cast::<i32>();
                    let result4 = Datetime {
                        seconds: l2 as u64,
                        nanoseconds: l3 as u32,
                    };
                    result4
                }
            }
        }
    }
    pub mod otel {
        #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
        pub mod tracing {
            #[used]
            #[doc(hidden)]
            static __FORCE_SECTION_REF: fn() = super::super::super::__link_custom_section_describing_imports;
            use super::super::super::_rt;
            pub type Datetime = super::super::super::wasi::clocks::wall_clock::Datetime;
            /// The trace that this `span-context` belongs to.
            ///
            /// 16 bytes encoded as a hexadecimal string.
            pub type TraceId = _rt::String;
            /// The id of this `span-context`.
            ///
            /// 8 bytes encoded as a hexadecimal string.
            pub type SpanId = _rt::String;
            wit_bindgen_rt::bitflags::bitflags! {
                #[doc = " Flags that can be set on a `span-context`."]
                #[derive(PartialEq, Eq, PartialOrd, Ord, Hash, Debug, Clone, Copy)] pub
                struct TraceFlags : u8 { #[doc =
                " Whether the `span` should be sampled or not."] const SAMPLED = 1 << 0;
                }
            }
            /// Carries system-specific configuration data, represented as a list of key-value pairs. `trace-state` allows multiple tracing systems to participate in the same trace.
            ///
            /// If any invalid keys or values are provided then the `trace-state` will be treated as an empty list.
            pub type TraceState = _rt::Vec<(_rt::String, _rt::String)>;
            /// Identifying trace information about a span that can be serialized and propagated.
            #[derive(Clone)]
            pub struct SpanContext {
                /// The `trace-id` for this `span-context`.
                pub trace_id: TraceId,
                /// The `span-id` for this `span-context`.
                pub span_id: SpanId,
                /// The `trace-flags` for this `span-context`.
                pub trace_flags: TraceFlags,
                /// Whether this `span-context` was propagated from a remote parent.
                pub is_remote: bool,
                /// The `trace-state` for this `span-context`.
                pub trace_state: TraceState,
            }
            impl ::core::fmt::Debug for SpanContext {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("SpanContext")
                        .field("trace-id", &self.trace_id)
                        .field("span-id", &self.span_id)
                        .field("trace-flags", &self.trace_flags)
                        .field("is-remote", &self.is_remote)
                        .field("trace-state", &self.trace_state)
                        .finish()
                }
            }
            /// Describes the relationship between the Span, its parents, and its children in a trace.
            #[repr(u8)]
            #[derive(Clone, Copy, Eq, Ord, PartialEq, PartialOrd)]
            pub enum SpanKind {
                /// Indicates that the span describes a request to some remote service. This span is usually the parent of a remote server span and does not end until the response is received.
                Client,
                /// Indicates that the span covers server-side handling of a synchronous RPC or other remote request. This span is often the child of a remote client span that was expected to wait for a response.
                Server,
                /// Indicates that the span describes the initiators of an asynchronous request. This parent span will often end before the corresponding child consumer span, possibly even before the child span starts. In messaging scenarios with batching, tracing individual messages requires a new producer span per message to be created.
                Producer,
                /// Indicates that the span describes a child of an asynchronous consumer request.
                Consumer,
                /// Default value. Indicates that the span represents an internal operation within an application, as opposed to an operations with remote parents or children.
                Internal,
            }
            impl ::core::fmt::Debug for SpanKind {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    match self {
                        SpanKind::Client => f.debug_tuple("SpanKind::Client").finish(),
                        SpanKind::Server => f.debug_tuple("SpanKind::Server").finish(),
                        SpanKind::Producer => {
                            f.debug_tuple("SpanKind::Producer").finish()
                        }
                        SpanKind::Consumer => {
                            f.debug_tuple("SpanKind::Consumer").finish()
                        }
                        SpanKind::Internal => {
                            f.debug_tuple("SpanKind::Internal").finish()
                        }
                    }
                }
            }
            impl SpanKind {
                #[doc(hidden)]
                pub unsafe fn _lift(val: u8) -> SpanKind {
                    if !cfg!(debug_assertions) {
                        return ::core::mem::transmute(val);
                    }
                    match val {
                        0 => SpanKind::Client,
                        1 => SpanKind::Server,
                        2 => SpanKind::Producer,
                        3 => SpanKind::Consumer,
                        4 => SpanKind::Internal,
                        _ => panic!("invalid enum discriminant"),
                    }
                }
            }
            /// The key part of attribute `key-value` pairs.
            pub type Key = _rt::String;
            /// The value part of attribute `key-value` pairs.
            #[derive(Clone)]
            pub enum Value {
                /// A string value.
                String(_rt::String),
                /// A boolean value.
                Bool(bool),
                /// A double precision floating point value.
                F64(f64),
                /// A signed 64 bit integer value.
                S64(i64),
                /// A homogeneous array of string values.
                StringArray(_rt::Vec<_rt::String>),
                /// A homogeneous array of boolean values.
                BoolArray(_rt::Vec<bool>),
                /// A homogeneous array of double precision floating point values.
                F64Array(_rt::Vec<f64>),
                /// A homogeneous array of 64 bit integer values.
                S64Array(_rt::Vec<i64>),
            }
            impl ::core::fmt::Debug for Value {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    match self {
                        Value::String(e) => {
                            f.debug_tuple("Value::String").field(e).finish()
                        }
                        Value::Bool(e) => f.debug_tuple("Value::Bool").field(e).finish(),
                        Value::F64(e) => f.debug_tuple("Value::F64").field(e).finish(),
                        Value::S64(e) => f.debug_tuple("Value::S64").field(e).finish(),
                        Value::StringArray(e) => {
                            f.debug_tuple("Value::StringArray").field(e).finish()
                        }
                        Value::BoolArray(e) => {
                            f.debug_tuple("Value::BoolArray").field(e).finish()
                        }
                        Value::F64Array(e) => {
                            f.debug_tuple("Value::F64Array").field(e).finish()
                        }
                        Value::S64Array(e) => {
                            f.debug_tuple("Value::S64Array").field(e).finish()
                        }
                    }
                }
            }
            /// A key-value pair describing an attribute.
            #[derive(Clone)]
            pub struct KeyValue {
                /// The attribute name.
                pub key: Key,
                /// The attribute value.
                pub value: Value,
            }
            impl ::core::fmt::Debug for KeyValue {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("KeyValue")
                        .field("key", &self.key)
                        .field("value", &self.value)
                        .finish()
                }
            }
            /// An event describing a specific moment in time on a span and associated attributes.
            #[derive(Clone)]
            pub struct Event {
                /// Event name.
                pub name: _rt::String,
                /// Event time.
                pub time: Datetime,
                /// Event attributes.
                pub attributes: _rt::Vec<KeyValue>,
            }
            impl ::core::fmt::Debug for Event {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("Event")
                        .field("name", &self.name)
                        .field("time", &self.time)
                        .field("attributes", &self.attributes)
                        .finish()
                }
            }
            /// Describes a relationship to another `span`.
            #[derive(Clone)]
            pub struct Link {
                /// Denotes which `span` to link to.
                pub span_context: SpanContext,
                /// Attributes describing the link.
                pub attributes: _rt::Vec<KeyValue>,
            }
            impl ::core::fmt::Debug for Link {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("Link")
                        .field("span-context", &self.span_context)
                        .field("attributes", &self.attributes)
                        .finish()
                }
            }
            /// The `status` of a `span`.
            #[derive(Clone)]
            pub enum Status {
                /// The default status.
                Unset,
                /// The operation has been validated by an Application developer or Operator to have completed successfully.
                Ok,
                /// The operation contains an error with a description.
                Error(_rt::String),
            }
            impl ::core::fmt::Debug for Status {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    match self {
                        Status::Unset => f.debug_tuple("Status::Unset").finish(),
                        Status::Ok => f.debug_tuple("Status::Ok").finish(),
                        Status::Error(e) => {
                            f.debug_tuple("Status::Error").field(e).finish()
                        }
                    }
                }
            }
            /// Describes the instrumentation scope that produced a span.
            #[derive(Clone)]
            pub struct InstrumentationScope {
                /// Name of the instrumentation scope.
                pub name: _rt::String,
                /// The library version.
                pub version: Option<_rt::String>,
                /// Schema URL used by this library.
                /// https://github.com/open-telemetry/opentelemetry-specification/blob/v1.9.0/specification/schemas/overview.md#schema-url
                pub schema_url: Option<_rt::String>,
                /// Specifies the instrumentation scope attributes to associate with emitted telemetry.
                pub attributes: _rt::Vec<KeyValue>,
            }
            impl ::core::fmt::Debug for InstrumentationScope {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("InstrumentationScope")
                        .field("name", &self.name)
                        .field("version", &self.version)
                        .field("schema-url", &self.schema_url)
                        .field("attributes", &self.attributes)
                        .finish()
                }
            }
            /// The data associated with a span.
            #[derive(Clone)]
            pub struct SpanData {
                /// Span context.
                pub span_context: SpanContext,
                /// Span parent id.
                pub parent_span_id: _rt::String,
                /// Span kind.
                pub span_kind: SpanKind,
                /// Span name.
                pub name: _rt::String,
                /// Span start time.
                pub start_time: Datetime,
                /// Span end time.
                pub end_time: Datetime,
                /// Span attributes.
                pub attributes: _rt::Vec<KeyValue>,
                /// Span events.
                pub events: _rt::Vec<Event>,
                /// Span Links.
                pub links: _rt::Vec<Link>,
                /// Span status.
                pub status: Status,
                /// Instrumentation scope that produced this span.
                pub instrumentation_scope: InstrumentationScope,
                /// Number of attributes dropped by the span due to limits being reached.
                pub dropped_attributes: u32,
                /// Number of events dropped by the span due to limits being reached.
                pub dropped_events: u32,
                /// Number of links dropped by the span due to limits being reached.
                pub dropped_links: u32,
            }
            impl ::core::fmt::Debug for SpanData {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("SpanData")
                        .field("span-context", &self.span_context)
                        .field("parent-span-id", &self.parent_span_id)
                        .field("span-kind", &self.span_kind)
                        .field("name", &self.name)
                        .field("start-time", &self.start_time)
                        .field("end-time", &self.end_time)
                        .field("attributes", &self.attributes)
                        .field("events", &self.events)
                        .field("links", &self.links)
                        .field("status", &self.status)
                        .field("instrumentation-scope", &self.instrumentation_scope)
                        .field("dropped-attributes", &self.dropped_attributes)
                        .field("dropped-events", &self.dropped_events)
                        .field("dropped-links", &self.dropped_links)
                        .finish()
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            /// Called when a span is started.
            pub fn on_start(span: &SpanData, parent: &SpanContext) -> () {
                unsafe {
                    let mut cleanup_list = _rt::Vec::new();
                    #[repr(align(8))]
                    struct RetArea(
                        [::core::mem::MaybeUninit<
                            u8,
                        >; 48 + 38 * ::core::mem::size_of::<*const u8>()],
                    );
                    let mut ret_area = RetArea(
                        [::core::mem::MaybeUninit::uninit(); 48
                            + 38 * ::core::mem::size_of::<*const u8>()],
                    );
                    let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                    let SpanData {
                        span_context: span_context1,
                        parent_span_id: parent_span_id1,
                        span_kind: span_kind1,
                        name: name1,
                        start_time: start_time1,
                        end_time: end_time1,
                        attributes: attributes1,
                        events: events1,
                        links: links1,
                        status: status1,
                        instrumentation_scope: instrumentation_scope1,
                        dropped_attributes: dropped_attributes1,
                        dropped_events: dropped_events1,
                        dropped_links: dropped_links1,
                    } = span;
                    let SpanContext {
                        trace_id: trace_id2,
                        span_id: span_id2,
                        trace_flags: trace_flags2,
                        is_remote: is_remote2,
                        trace_state: trace_state2,
                    } = span_context1;
                    let vec3 = trace_id2;
                    let ptr3 = vec3.as_ptr().cast::<u8>();
                    let len3 = vec3.len();
                    *ptr0.add(::core::mem::size_of::<*const u8>()).cast::<usize>() = len3;
                    *ptr0.add(0).cast::<*mut u8>() = ptr3.cast_mut();
                    let vec4 = span_id2;
                    let ptr4 = vec4.as_ptr().cast::<u8>();
                    let len4 = vec4.len();
                    *ptr0.add(3 * ::core::mem::size_of::<*const u8>()).cast::<usize>() = len4;
                    *ptr0
                        .add(2 * ::core::mem::size_of::<*const u8>())
                        .cast::<*mut u8>() = ptr4.cast_mut();
                    let flags5 = trace_flags2;
                    *ptr0.add(4 * ::core::mem::size_of::<*const u8>()).cast::<u8>() = ((flags5
                        .bits() >> 0) as i32) as u8;
                    *ptr0
                        .add(1 + 4 * ::core::mem::size_of::<*const u8>())
                        .cast::<u8>() = (match is_remote2 {
                        true => 1,
                        false => 0,
                    }) as u8;
                    let vec9 = trace_state2;
                    let len9 = vec9.len();
                    let layout9 = _rt::alloc::Layout::from_size_align_unchecked(
                        vec9.len() * (4 * ::core::mem::size_of::<*const u8>()),
                        ::core::mem::size_of::<*const u8>(),
                    );
                    let result9 = if layout9.size() != 0 {
                        let ptr = _rt::alloc::alloc(layout9).cast::<u8>();
                        if ptr.is_null() {
                            _rt::alloc::handle_alloc_error(layout9);
                        }
                        ptr
                    } else {
                        ::core::ptr::null_mut()
                    };
                    for (i, e) in vec9.into_iter().enumerate() {
                        let base = result9
                            .add(i * (4 * ::core::mem::size_of::<*const u8>()));
                        {
                            let (t6_0, t6_1) = e;
                            let vec7 = t6_0;
                            let ptr7 = vec7.as_ptr().cast::<u8>();
                            let len7 = vec7.len();
                            *base
                                .add(::core::mem::size_of::<*const u8>())
                                .cast::<usize>() = len7;
                            *base.add(0).cast::<*mut u8>() = ptr7.cast_mut();
                            let vec8 = t6_1;
                            let ptr8 = vec8.as_ptr().cast::<u8>();
                            let len8 = vec8.len();
                            *base
                                .add(3 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>() = len8;
                            *base
                                .add(2 * ::core::mem::size_of::<*const u8>())
                                .cast::<*mut u8>() = ptr8.cast_mut();
                        }
                    }
                    *ptr0.add(6 * ::core::mem::size_of::<*const u8>()).cast::<usize>() = len9;
                    *ptr0
                        .add(5 * ::core::mem::size_of::<*const u8>())
                        .cast::<*mut u8>() = result9;
                    let vec10 = parent_span_id1;
                    let ptr10 = vec10.as_ptr().cast::<u8>();
                    let len10 = vec10.len();
                    *ptr0.add(8 * ::core::mem::size_of::<*const u8>()).cast::<usize>() = len10;
                    *ptr0
                        .add(7 * ::core::mem::size_of::<*const u8>())
                        .cast::<*mut u8>() = ptr10.cast_mut();
                    *ptr0.add(9 * ::core::mem::size_of::<*const u8>()).cast::<u8>() = (span_kind1
                        .clone() as i32) as u8;
                    let vec11 = name1;
                    let ptr11 = vec11.as_ptr().cast::<u8>();
                    let len11 = vec11.len();
                    *ptr0
                        .add(11 * ::core::mem::size_of::<*const u8>())
                        .cast::<usize>() = len11;
                    *ptr0
                        .add(10 * ::core::mem::size_of::<*const u8>())
                        .cast::<*mut u8>() = ptr11.cast_mut();
                    let super::super::super::wasi::clocks::wall_clock::Datetime {
                        seconds: seconds12,
                        nanoseconds: nanoseconds12,
                    } = start_time1;
                    *ptr0.add(12 * ::core::mem::size_of::<*const u8>()).cast::<i64>() = _rt::as_i64(
                        seconds12,
                    );
                    *ptr0
                        .add(8 + 12 * ::core::mem::size_of::<*const u8>())
                        .cast::<i32>() = _rt::as_i32(nanoseconds12);
                    let super::super::super::wasi::clocks::wall_clock::Datetime {
                        seconds: seconds13,
                        nanoseconds: nanoseconds13,
                    } = end_time1;
                    *ptr0
                        .add(16 + 12 * ::core::mem::size_of::<*const u8>())
                        .cast::<i64>() = _rt::as_i64(seconds13);
                    *ptr0
                        .add(24 + 12 * ::core::mem::size_of::<*const u8>())
                        .cast::<i32>() = _rt::as_i32(nanoseconds13);
                    let vec22 = attributes1;
                    let len22 = vec22.len();
                    let layout22 = _rt::alloc::Layout::from_size_align_unchecked(
                        vec22.len() * (8 + 4 * ::core::mem::size_of::<*const u8>()),
                        8,
                    );
                    let result22 = if layout22.size() != 0 {
                        let ptr = _rt::alloc::alloc(layout22).cast::<u8>();
                        if ptr.is_null() {
                            _rt::alloc::handle_alloc_error(layout22);
                        }
                        ptr
                    } else {
                        ::core::ptr::null_mut()
                    };
                    for (i, e) in vec22.into_iter().enumerate() {
                        let base = result22
                            .add(i * (8 + 4 * ::core::mem::size_of::<*const u8>()));
                        {
                            let KeyValue { key: key14, value: value14 } = e;
                            let vec15 = key14;
                            let ptr15 = vec15.as_ptr().cast::<u8>();
                            let len15 = vec15.len();
                            *base
                                .add(::core::mem::size_of::<*const u8>())
                                .cast::<usize>() = len15;
                            *base.add(0).cast::<*mut u8>() = ptr15.cast_mut();
                            match value14 {
                                Value::String(e) => {
                                    *base
                                        .add(2 * ::core::mem::size_of::<*const u8>())
                                        .cast::<u8>() = (0i32) as u8;
                                    let vec16 = e;
                                    let ptr16 = vec16.as_ptr().cast::<u8>();
                                    let len16 = vec16.len();
                                    *base
                                        .add(8 + 3 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len16;
                                    *base
                                        .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                        .cast::<*mut u8>() = ptr16.cast_mut();
                                }
                                Value::Bool(e) => {
                                    *base
                                        .add(2 * ::core::mem::size_of::<*const u8>())
                                        .cast::<u8>() = (1i32) as u8;
                                    *base
                                        .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                        .cast::<u8>() = (match e {
                                        true => 1,
                                        false => 0,
                                    }) as u8;
                                }
                                Value::F64(e) => {
                                    *base
                                        .add(2 * ::core::mem::size_of::<*const u8>())
                                        .cast::<u8>() = (2i32) as u8;
                                    *base
                                        .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                        .cast::<f64>() = _rt::as_f64(e);
                                }
                                Value::S64(e) => {
                                    *base
                                        .add(2 * ::core::mem::size_of::<*const u8>())
                                        .cast::<u8>() = (3i32) as u8;
                                    *base
                                        .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                        .cast::<i64>() = _rt::as_i64(e);
                                }
                                Value::StringArray(e) => {
                                    *base
                                        .add(2 * ::core::mem::size_of::<*const u8>())
                                        .cast::<u8>() = (4i32) as u8;
                                    let vec18 = e;
                                    let len18 = vec18.len();
                                    let layout18 = _rt::alloc::Layout::from_size_align_unchecked(
                                        vec18.len() * (2 * ::core::mem::size_of::<*const u8>()),
                                        ::core::mem::size_of::<*const u8>(),
                                    );
                                    let result18 = if layout18.size() != 0 {
                                        let ptr = _rt::alloc::alloc(layout18).cast::<u8>();
                                        if ptr.is_null() {
                                            _rt::alloc::handle_alloc_error(layout18);
                                        }
                                        ptr
                                    } else {
                                        ::core::ptr::null_mut()
                                    };
                                    for (i, e) in vec18.into_iter().enumerate() {
                                        let base = result18
                                            .add(i * (2 * ::core::mem::size_of::<*const u8>()));
                                        {
                                            let vec17 = e;
                                            let ptr17 = vec17.as_ptr().cast::<u8>();
                                            let len17 = vec17.len();
                                            *base
                                                .add(::core::mem::size_of::<*const u8>())
                                                .cast::<usize>() = len17;
                                            *base.add(0).cast::<*mut u8>() = ptr17.cast_mut();
                                        }
                                    }
                                    *base
                                        .add(8 + 3 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len18;
                                    *base
                                        .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                        .cast::<*mut u8>() = result18;
                                    cleanup_list.extend_from_slice(&[(result18, layout18)]);
                                }
                                Value::BoolArray(e) => {
                                    *base
                                        .add(2 * ::core::mem::size_of::<*const u8>())
                                        .cast::<u8>() = (5i32) as u8;
                                    let vec19 = e;
                                    let len19 = vec19.len();
                                    let layout19 = _rt::alloc::Layout::from_size_align_unchecked(
                                        vec19.len() * 1,
                                        1,
                                    );
                                    let result19 = if layout19.size() != 0 {
                                        let ptr = _rt::alloc::alloc(layout19).cast::<u8>();
                                        if ptr.is_null() {
                                            _rt::alloc::handle_alloc_error(layout19);
                                        }
                                        ptr
                                    } else {
                                        ::core::ptr::null_mut()
                                    };
                                    for (i, e) in vec19.into_iter().enumerate() {
                                        let base = result19.add(i * 1);
                                        {
                                            *base.add(0).cast::<u8>() = (match e {
                                                true => 1,
                                                false => 0,
                                            }) as u8;
                                        }
                                    }
                                    *base
                                        .add(8 + 3 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len19;
                                    *base
                                        .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                        .cast::<*mut u8>() = result19;
                                    cleanup_list.extend_from_slice(&[(result19, layout19)]);
                                }
                                Value::F64Array(e) => {
                                    *base
                                        .add(2 * ::core::mem::size_of::<*const u8>())
                                        .cast::<u8>() = (6i32) as u8;
                                    let vec20 = e;
                                    let ptr20 = vec20.as_ptr().cast::<u8>();
                                    let len20 = vec20.len();
                                    *base
                                        .add(8 + 3 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len20;
                                    *base
                                        .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                        .cast::<*mut u8>() = ptr20.cast_mut();
                                }
                                Value::S64Array(e) => {
                                    *base
                                        .add(2 * ::core::mem::size_of::<*const u8>())
                                        .cast::<u8>() = (7i32) as u8;
                                    let vec21 = e;
                                    let ptr21 = vec21.as_ptr().cast::<u8>();
                                    let len21 = vec21.len();
                                    *base
                                        .add(8 + 3 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len21;
                                    *base
                                        .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                        .cast::<*mut u8>() = ptr21.cast_mut();
                                }
                            }
                        }
                    }
                    *ptr0
                        .add(32 + 13 * ::core::mem::size_of::<*const u8>())
                        .cast::<usize>() = len22;
                    *ptr0
                        .add(32 + 12 * ::core::mem::size_of::<*const u8>())
                        .cast::<*mut u8>() = result22;
                    let vec35 = events1;
                    let len35 = vec35.len();
                    let layout35 = _rt::alloc::Layout::from_size_align_unchecked(
                        vec35.len() * (16 + 4 * ::core::mem::size_of::<*const u8>()),
                        8,
                    );
                    let result35 = if layout35.size() != 0 {
                        let ptr = _rt::alloc::alloc(layout35).cast::<u8>();
                        if ptr.is_null() {
                            _rt::alloc::handle_alloc_error(layout35);
                        }
                        ptr
                    } else {
                        ::core::ptr::null_mut()
                    };
                    for (i, e) in vec35.into_iter().enumerate() {
                        let base = result35
                            .add(i * (16 + 4 * ::core::mem::size_of::<*const u8>()));
                        {
                            let Event {
                                name: name23,
                                time: time23,
                                attributes: attributes23,
                            } = e;
                            let vec24 = name23;
                            let ptr24 = vec24.as_ptr().cast::<u8>();
                            let len24 = vec24.len();
                            *base
                                .add(::core::mem::size_of::<*const u8>())
                                .cast::<usize>() = len24;
                            *base.add(0).cast::<*mut u8>() = ptr24.cast_mut();
                            let super::super::super::wasi::clocks::wall_clock::Datetime {
                                seconds: seconds25,
                                nanoseconds: nanoseconds25,
                            } = time23;
                            *base
                                .add(2 * ::core::mem::size_of::<*const u8>())
                                .cast::<i64>() = _rt::as_i64(seconds25);
                            *base
                                .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                .cast::<i32>() = _rt::as_i32(nanoseconds25);
                            let vec34 = attributes23;
                            let len34 = vec34.len();
                            let layout34 = _rt::alloc::Layout::from_size_align_unchecked(
                                vec34.len() * (8 + 4 * ::core::mem::size_of::<*const u8>()),
                                8,
                            );
                            let result34 = if layout34.size() != 0 {
                                let ptr = _rt::alloc::alloc(layout34).cast::<u8>();
                                if ptr.is_null() {
                                    _rt::alloc::handle_alloc_error(layout34);
                                }
                                ptr
                            } else {
                                ::core::ptr::null_mut()
                            };
                            for (i, e) in vec34.into_iter().enumerate() {
                                let base = result34
                                    .add(i * (8 + 4 * ::core::mem::size_of::<*const u8>()));
                                {
                                    let KeyValue { key: key26, value: value26 } = e;
                                    let vec27 = key26;
                                    let ptr27 = vec27.as_ptr().cast::<u8>();
                                    let len27 = vec27.len();
                                    *base
                                        .add(::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len27;
                                    *base.add(0).cast::<*mut u8>() = ptr27.cast_mut();
                                    match value26 {
                                        Value::String(e) => {
                                            *base
                                                .add(2 * ::core::mem::size_of::<*const u8>())
                                                .cast::<u8>() = (0i32) as u8;
                                            let vec28 = e;
                                            let ptr28 = vec28.as_ptr().cast::<u8>();
                                            let len28 = vec28.len();
                                            *base
                                                .add(8 + 3 * ::core::mem::size_of::<*const u8>())
                                                .cast::<usize>() = len28;
                                            *base
                                                .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                .cast::<*mut u8>() = ptr28.cast_mut();
                                        }
                                        Value::Bool(e) => {
                                            *base
                                                .add(2 * ::core::mem::size_of::<*const u8>())
                                                .cast::<u8>() = (1i32) as u8;
                                            *base
                                                .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                .cast::<u8>() = (match e {
                                                true => 1,
                                                false => 0,
                                            }) as u8;
                                        }
                                        Value::F64(e) => {
                                            *base
                                                .add(2 * ::core::mem::size_of::<*const u8>())
                                                .cast::<u8>() = (2i32) as u8;
                                            *base
                                                .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                .cast::<f64>() = _rt::as_f64(e);
                                        }
                                        Value::S64(e) => {
                                            *base
                                                .add(2 * ::core::mem::size_of::<*const u8>())
                                                .cast::<u8>() = (3i32) as u8;
                                            *base
                                                .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                .cast::<i64>() = _rt::as_i64(e);
                                        }
                                        Value::StringArray(e) => {
                                            *base
                                                .add(2 * ::core::mem::size_of::<*const u8>())
                                                .cast::<u8>() = (4i32) as u8;
                                            let vec30 = e;
                                            let len30 = vec30.len();
                                            let layout30 = _rt::alloc::Layout::from_size_align_unchecked(
                                                vec30.len() * (2 * ::core::mem::size_of::<*const u8>()),
                                                ::core::mem::size_of::<*const u8>(),
                                            );
                                            let result30 = if layout30.size() != 0 {
                                                let ptr = _rt::alloc::alloc(layout30).cast::<u8>();
                                                if ptr.is_null() {
                                                    _rt::alloc::handle_alloc_error(layout30);
                                                }
                                                ptr
                                            } else {
                                                ::core::ptr::null_mut()
                                            };
                                            for (i, e) in vec30.into_iter().enumerate() {
                                                let base = result30
                                                    .add(i * (2 * ::core::mem::size_of::<*const u8>()));
                                                {
                                                    let vec29 = e;
                                                    let ptr29 = vec29.as_ptr().cast::<u8>();
                                                    let len29 = vec29.len();
                                                    *base
                                                        .add(::core::mem::size_of::<*const u8>())
                                                        .cast::<usize>() = len29;
                                                    *base.add(0).cast::<*mut u8>() = ptr29.cast_mut();
                                                }
                                            }
                                            *base
                                                .add(8 + 3 * ::core::mem::size_of::<*const u8>())
                                                .cast::<usize>() = len30;
                                            *base
                                                .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                .cast::<*mut u8>() = result30;
                                            cleanup_list.extend_from_slice(&[(result30, layout30)]);
                                        }
                                        Value::BoolArray(e) => {
                                            *base
                                                .add(2 * ::core::mem::size_of::<*const u8>())
                                                .cast::<u8>() = (5i32) as u8;
                                            let vec31 = e;
                                            let len31 = vec31.len();
                                            let layout31 = _rt::alloc::Layout::from_size_align_unchecked(
                                                vec31.len() * 1,
                                                1,
                                            );
                                            let result31 = if layout31.size() != 0 {
                                                let ptr = _rt::alloc::alloc(layout31).cast::<u8>();
                                                if ptr.is_null() {
                                                    _rt::alloc::handle_alloc_error(layout31);
                                                }
                                                ptr
                                            } else {
                                                ::core::ptr::null_mut()
                                            };
                                            for (i, e) in vec31.into_iter().enumerate() {
                                                let base = result31.add(i * 1);
                                                {
                                                    *base.add(0).cast::<u8>() = (match e {
                                                        true => 1,
                                                        false => 0,
                                                    }) as u8;
                                                }
                                            }
                                            *base
                                                .add(8 + 3 * ::core::mem::size_of::<*const u8>())
                                                .cast::<usize>() = len31;
                                            *base
                                                .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                .cast::<*mut u8>() = result31;
                                            cleanup_list.extend_from_slice(&[(result31, layout31)]);
                                        }
                                        Value::F64Array(e) => {
                                            *base
                                                .add(2 * ::core::mem::size_of::<*const u8>())
                                                .cast::<u8>() = (6i32) as u8;
                                            let vec32 = e;
                                            let ptr32 = vec32.as_ptr().cast::<u8>();
                                            let len32 = vec32.len();
                                            *base
                                                .add(8 + 3 * ::core::mem::size_of::<*const u8>())
                                                .cast::<usize>() = len32;
                                            *base
                                                .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                .cast::<*mut u8>() = ptr32.cast_mut();
                                        }
                                        Value::S64Array(e) => {
                                            *base
                                                .add(2 * ::core::mem::size_of::<*const u8>())
                                                .cast::<u8>() = (7i32) as u8;
                                            let vec33 = e;
                                            let ptr33 = vec33.as_ptr().cast::<u8>();
                                            let len33 = vec33.len();
                                            *base
                                                .add(8 + 3 * ::core::mem::size_of::<*const u8>())
                                                .cast::<usize>() = len33;
                                            *base
                                                .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                .cast::<*mut u8>() = ptr33.cast_mut();
                                        }
                                    }
                                }
                            }
                            *base
                                .add(16 + 3 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>() = len34;
                            *base
                                .add(16 + 2 * ::core::mem::size_of::<*const u8>())
                                .cast::<*mut u8>() = result34;
                            cleanup_list.extend_from_slice(&[(result34, layout34)]);
                        }
                    }
                    *ptr0
                        .add(32 + 15 * ::core::mem::size_of::<*const u8>())
                        .cast::<usize>() = len35;
                    *ptr0
                        .add(32 + 14 * ::core::mem::size_of::<*const u8>())
                        .cast::<*mut u8>() = result35;
                    let vec54 = links1;
                    let len54 = vec54.len();
                    let layout54 = _rt::alloc::Layout::from_size_align_unchecked(
                        vec54.len() * (9 * ::core::mem::size_of::<*const u8>()),
                        ::core::mem::size_of::<*const u8>(),
                    );
                    let result54 = if layout54.size() != 0 {
                        let ptr = _rt::alloc::alloc(layout54).cast::<u8>();
                        if ptr.is_null() {
                            _rt::alloc::handle_alloc_error(layout54);
                        }
                        ptr
                    } else {
                        ::core::ptr::null_mut()
                    };
                    for (i, e) in vec54.into_iter().enumerate() {
                        let base = result54
                            .add(i * (9 * ::core::mem::size_of::<*const u8>()));
                        {
                            let Link {
                                span_context: span_context36,
                                attributes: attributes36,
                            } = e;
                            let SpanContext {
                                trace_id: trace_id37,
                                span_id: span_id37,
                                trace_flags: trace_flags37,
                                is_remote: is_remote37,
                                trace_state: trace_state37,
                            } = span_context36;
                            let vec38 = trace_id37;
                            let ptr38 = vec38.as_ptr().cast::<u8>();
                            let len38 = vec38.len();
                            *base
                                .add(::core::mem::size_of::<*const u8>())
                                .cast::<usize>() = len38;
                            *base.add(0).cast::<*mut u8>() = ptr38.cast_mut();
                            let vec39 = span_id37;
                            let ptr39 = vec39.as_ptr().cast::<u8>();
                            let len39 = vec39.len();
                            *base
                                .add(3 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>() = len39;
                            *base
                                .add(2 * ::core::mem::size_of::<*const u8>())
                                .cast::<*mut u8>() = ptr39.cast_mut();
                            let flags40 = trace_flags37;
                            *base
                                .add(4 * ::core::mem::size_of::<*const u8>())
                                .cast::<u8>() = ((flags40.bits() >> 0) as i32) as u8;
                            *base
                                .add(1 + 4 * ::core::mem::size_of::<*const u8>())
                                .cast::<u8>() = (match is_remote37 {
                                true => 1,
                                false => 0,
                            }) as u8;
                            let vec44 = trace_state37;
                            let len44 = vec44.len();
                            let layout44 = _rt::alloc::Layout::from_size_align_unchecked(
                                vec44.len() * (4 * ::core::mem::size_of::<*const u8>()),
                                ::core::mem::size_of::<*const u8>(),
                            );
                            let result44 = if layout44.size() != 0 {
                                let ptr = _rt::alloc::alloc(layout44).cast::<u8>();
                                if ptr.is_null() {
                                    _rt::alloc::handle_alloc_error(layout44);
                                }
                                ptr
                            } else {
                                ::core::ptr::null_mut()
                            };
                            for (i, e) in vec44.into_iter().enumerate() {
                                let base = result44
                                    .add(i * (4 * ::core::mem::size_of::<*const u8>()));
                                {
                                    let (t41_0, t41_1) = e;
                                    let vec42 = t41_0;
                                    let ptr42 = vec42.as_ptr().cast::<u8>();
                                    let len42 = vec42.len();
                                    *base
                                        .add(::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len42;
                                    *base.add(0).cast::<*mut u8>() = ptr42.cast_mut();
                                    let vec43 = t41_1;
                                    let ptr43 = vec43.as_ptr().cast::<u8>();
                                    let len43 = vec43.len();
                                    *base
                                        .add(3 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len43;
                                    *base
                                        .add(2 * ::core::mem::size_of::<*const u8>())
                                        .cast::<*mut u8>() = ptr43.cast_mut();
                                }
                            }
                            *base
                                .add(6 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>() = len44;
                            *base
                                .add(5 * ::core::mem::size_of::<*const u8>())
                                .cast::<*mut u8>() = result44;
                            let vec53 = attributes36;
                            let len53 = vec53.len();
                            let layout53 = _rt::alloc::Layout::from_size_align_unchecked(
                                vec53.len() * (8 + 4 * ::core::mem::size_of::<*const u8>()),
                                8,
                            );
                            let result53 = if layout53.size() != 0 {
                                let ptr = _rt::alloc::alloc(layout53).cast::<u8>();
                                if ptr.is_null() {
                                    _rt::alloc::handle_alloc_error(layout53);
                                }
                                ptr
                            } else {
                                ::core::ptr::null_mut()
                            };
                            for (i, e) in vec53.into_iter().enumerate() {
                                let base = result53
                                    .add(i * (8 + 4 * ::core::mem::size_of::<*const u8>()));
                                {
                                    let KeyValue { key: key45, value: value45 } = e;
                                    let vec46 = key45;
                                    let ptr46 = vec46.as_ptr().cast::<u8>();
                                    let len46 = vec46.len();
                                    *base
                                        .add(::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len46;
                                    *base.add(0).cast::<*mut u8>() = ptr46.cast_mut();
                                    match value45 {
                                        Value::String(e) => {
                                            *base
                                                .add(2 * ::core::mem::size_of::<*const u8>())
                                                .cast::<u8>() = (0i32) as u8;
                                            let vec47 = e;
                                            let ptr47 = vec47.as_ptr().cast::<u8>();
                                            let len47 = vec47.len();
                                            *base
                                                .add(8 + 3 * ::core::mem::size_of::<*const u8>())
                                                .cast::<usize>() = len47;
                                            *base
                                                .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                .cast::<*mut u8>() = ptr47.cast_mut();
                                        }
                                        Value::Bool(e) => {
                                            *base
                                                .add(2 * ::core::mem::size_of::<*const u8>())
                                                .cast::<u8>() = (1i32) as u8;
                                            *base
                                                .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                .cast::<u8>() = (match e {
                                                true => 1,
                                                false => 0,
                                            }) as u8;
                                        }
                                        Value::F64(e) => {
                                            *base
                                                .add(2 * ::core::mem::size_of::<*const u8>())
                                                .cast::<u8>() = (2i32) as u8;
                                            *base
                                                .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                .cast::<f64>() = _rt::as_f64(e);
                                        }
                                        Value::S64(e) => {
                                            *base
                                                .add(2 * ::core::mem::size_of::<*const u8>())
                                                .cast::<u8>() = (3i32) as u8;
                                            *base
                                                .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                .cast::<i64>() = _rt::as_i64(e);
                                        }
                                        Value::StringArray(e) => {
                                            *base
                                                .add(2 * ::core::mem::size_of::<*const u8>())
                                                .cast::<u8>() = (4i32) as u8;
                                            let vec49 = e;
                                            let len49 = vec49.len();
                                            let layout49 = _rt::alloc::Layout::from_size_align_unchecked(
                                                vec49.len() * (2 * ::core::mem::size_of::<*const u8>()),
                                                ::core::mem::size_of::<*const u8>(),
                                            );
                                            let result49 = if layout49.size() != 0 {
                                                let ptr = _rt::alloc::alloc(layout49).cast::<u8>();
                                                if ptr.is_null() {
                                                    _rt::alloc::handle_alloc_error(layout49);
                                                }
                                                ptr
                                            } else {
                                                ::core::ptr::null_mut()
                                            };
                                            for (i, e) in vec49.into_iter().enumerate() {
                                                let base = result49
                                                    .add(i * (2 * ::core::mem::size_of::<*const u8>()));
                                                {
                                                    let vec48 = e;
                                                    let ptr48 = vec48.as_ptr().cast::<u8>();
                                                    let len48 = vec48.len();
                                                    *base
                                                        .add(::core::mem::size_of::<*const u8>())
                                                        .cast::<usize>() = len48;
                                                    *base.add(0).cast::<*mut u8>() = ptr48.cast_mut();
                                                }
                                            }
                                            *base
                                                .add(8 + 3 * ::core::mem::size_of::<*const u8>())
                                                .cast::<usize>() = len49;
                                            *base
                                                .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                .cast::<*mut u8>() = result49;
                                            cleanup_list.extend_from_slice(&[(result49, layout49)]);
                                        }
                                        Value::BoolArray(e) => {
                                            *base
                                                .add(2 * ::core::mem::size_of::<*const u8>())
                                                .cast::<u8>() = (5i32) as u8;
                                            let vec50 = e;
                                            let len50 = vec50.len();
                                            let layout50 = _rt::alloc::Layout::from_size_align_unchecked(
                                                vec50.len() * 1,
                                                1,
                                            );
                                            let result50 = if layout50.size() != 0 {
                                                let ptr = _rt::alloc::alloc(layout50).cast::<u8>();
                                                if ptr.is_null() {
                                                    _rt::alloc::handle_alloc_error(layout50);
                                                }
                                                ptr
                                            } else {
                                                ::core::ptr::null_mut()
                                            };
                                            for (i, e) in vec50.into_iter().enumerate() {
                                                let base = result50.add(i * 1);
                                                {
                                                    *base.add(0).cast::<u8>() = (match e {
                                                        true => 1,
                                                        false => 0,
                                                    }) as u8;
                                                }
                                            }
                                            *base
                                                .add(8 + 3 * ::core::mem::size_of::<*const u8>())
                                                .cast::<usize>() = len50;
                                            *base
                                                .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                .cast::<*mut u8>() = result50;
                                            cleanup_list.extend_from_slice(&[(result50, layout50)]);
                                        }
                                        Value::F64Array(e) => {
                                            *base
                                                .add(2 * ::core::mem::size_of::<*const u8>())
                                                .cast::<u8>() = (6i32) as u8;
                                            let vec51 = e;
                                            let ptr51 = vec51.as_ptr().cast::<u8>();
                                            let len51 = vec51.len();
                                            *base
                                                .add(8 + 3 * ::core::mem::size_of::<*const u8>())
                                                .cast::<usize>() = len51;
                                            *base
                                                .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                .cast::<*mut u8>() = ptr51.cast_mut();
                                        }
                                        Value::S64Array(e) => {
                                            *base
                                                .add(2 * ::core::mem::size_of::<*const u8>())
                                                .cast::<u8>() = (7i32) as u8;
                                            let vec52 = e;
                                            let ptr52 = vec52.as_ptr().cast::<u8>();
                                            let len52 = vec52.len();
                                            *base
                                                .add(8 + 3 * ::core::mem::size_of::<*const u8>())
                                                .cast::<usize>() = len52;
                                            *base
                                                .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                .cast::<*mut u8>() = ptr52.cast_mut();
                                        }
                                    }
                                }
                            }
                            *base
                                .add(8 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>() = len53;
                            *base
                                .add(7 * ::core::mem::size_of::<*const u8>())
                                .cast::<*mut u8>() = result53;
                            cleanup_list
                                .extend_from_slice(
                                    &[(result44, layout44), (result53, layout53)],
                                );
                        }
                    }
                    *ptr0
                        .add(32 + 17 * ::core::mem::size_of::<*const u8>())
                        .cast::<usize>() = len54;
                    *ptr0
                        .add(32 + 16 * ::core::mem::size_of::<*const u8>())
                        .cast::<*mut u8>() = result54;
                    match status1 {
                        Status::Unset => {
                            *ptr0
                                .add(32 + 18 * ::core::mem::size_of::<*const u8>())
                                .cast::<u8>() = (0i32) as u8;
                        }
                        Status::Ok => {
                            *ptr0
                                .add(32 + 18 * ::core::mem::size_of::<*const u8>())
                                .cast::<u8>() = (1i32) as u8;
                        }
                        Status::Error(e) => {
                            *ptr0
                                .add(32 + 18 * ::core::mem::size_of::<*const u8>())
                                .cast::<u8>() = (2i32) as u8;
                            let vec55 = e;
                            let ptr55 = vec55.as_ptr().cast::<u8>();
                            let len55 = vec55.len();
                            *ptr0
                                .add(32 + 20 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>() = len55;
                            *ptr0
                                .add(32 + 19 * ::core::mem::size_of::<*const u8>())
                                .cast::<*mut u8>() = ptr55.cast_mut();
                        }
                    }
                    let InstrumentationScope {
                        name: name56,
                        version: version56,
                        schema_url: schema_url56,
                        attributes: attributes56,
                    } = instrumentation_scope1;
                    let vec57 = name56;
                    let ptr57 = vec57.as_ptr().cast::<u8>();
                    let len57 = vec57.len();
                    *ptr0
                        .add(32 + 22 * ::core::mem::size_of::<*const u8>())
                        .cast::<usize>() = len57;
                    *ptr0
                        .add(32 + 21 * ::core::mem::size_of::<*const u8>())
                        .cast::<*mut u8>() = ptr57.cast_mut();
                    match version56 {
                        Some(e) => {
                            *ptr0
                                .add(32 + 23 * ::core::mem::size_of::<*const u8>())
                                .cast::<u8>() = (1i32) as u8;
                            let vec58 = e;
                            let ptr58 = vec58.as_ptr().cast::<u8>();
                            let len58 = vec58.len();
                            *ptr0
                                .add(32 + 25 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>() = len58;
                            *ptr0
                                .add(32 + 24 * ::core::mem::size_of::<*const u8>())
                                .cast::<*mut u8>() = ptr58.cast_mut();
                        }
                        None => {
                            *ptr0
                                .add(32 + 23 * ::core::mem::size_of::<*const u8>())
                                .cast::<u8>() = (0i32) as u8;
                        }
                    };
                    match schema_url56 {
                        Some(e) => {
                            *ptr0
                                .add(32 + 26 * ::core::mem::size_of::<*const u8>())
                                .cast::<u8>() = (1i32) as u8;
                            let vec59 = e;
                            let ptr59 = vec59.as_ptr().cast::<u8>();
                            let len59 = vec59.len();
                            *ptr0
                                .add(32 + 28 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>() = len59;
                            *ptr0
                                .add(32 + 27 * ::core::mem::size_of::<*const u8>())
                                .cast::<*mut u8>() = ptr59.cast_mut();
                        }
                        None => {
                            *ptr0
                                .add(32 + 26 * ::core::mem::size_of::<*const u8>())
                                .cast::<u8>() = (0i32) as u8;
                        }
                    };
                    let vec68 = attributes56;
                    let len68 = vec68.len();
                    let layout68 = _rt::alloc::Layout::from_size_align_unchecked(
                        vec68.len() * (8 + 4 * ::core::mem::size_of::<*const u8>()),
                        8,
                    );
                    let result68 = if layout68.size() != 0 {
                        let ptr = _rt::alloc::alloc(layout68).cast::<u8>();
                        if ptr.is_null() {
                            _rt::alloc::handle_alloc_error(layout68);
                        }
                        ptr
                    } else {
                        ::core::ptr::null_mut()
                    };
                    for (i, e) in vec68.into_iter().enumerate() {
                        let base = result68
                            .add(i * (8 + 4 * ::core::mem::size_of::<*const u8>()));
                        {
                            let KeyValue { key: key60, value: value60 } = e;
                            let vec61 = key60;
                            let ptr61 = vec61.as_ptr().cast::<u8>();
                            let len61 = vec61.len();
                            *base
                                .add(::core::mem::size_of::<*const u8>())
                                .cast::<usize>() = len61;
                            *base.add(0).cast::<*mut u8>() = ptr61.cast_mut();
                            match value60 {
                                Value::String(e) => {
                                    *base
                                        .add(2 * ::core::mem::size_of::<*const u8>())
                                        .cast::<u8>() = (0i32) as u8;
                                    let vec62 = e;
                                    let ptr62 = vec62.as_ptr().cast::<u8>();
                                    let len62 = vec62.len();
                                    *base
                                        .add(8 + 3 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len62;
                                    *base
                                        .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                        .cast::<*mut u8>() = ptr62.cast_mut();
                                }
                                Value::Bool(e) => {
                                    *base
                                        .add(2 * ::core::mem::size_of::<*const u8>())
                                        .cast::<u8>() = (1i32) as u8;
                                    *base
                                        .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                        .cast::<u8>() = (match e {
                                        true => 1,
                                        false => 0,
                                    }) as u8;
                                }
                                Value::F64(e) => {
                                    *base
                                        .add(2 * ::core::mem::size_of::<*const u8>())
                                        .cast::<u8>() = (2i32) as u8;
                                    *base
                                        .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                        .cast::<f64>() = _rt::as_f64(e);
                                }
                                Value::S64(e) => {
                                    *base
                                        .add(2 * ::core::mem::size_of::<*const u8>())
                                        .cast::<u8>() = (3i32) as u8;
                                    *base
                                        .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                        .cast::<i64>() = _rt::as_i64(e);
                                }
                                Value::StringArray(e) => {
                                    *base
                                        .add(2 * ::core::mem::size_of::<*const u8>())
                                        .cast::<u8>() = (4i32) as u8;
                                    let vec64 = e;
                                    let len64 = vec64.len();
                                    let layout64 = _rt::alloc::Layout::from_size_align_unchecked(
                                        vec64.len() * (2 * ::core::mem::size_of::<*const u8>()),
                                        ::core::mem::size_of::<*const u8>(),
                                    );
                                    let result64 = if layout64.size() != 0 {
                                        let ptr = _rt::alloc::alloc(layout64).cast::<u8>();
                                        if ptr.is_null() {
                                            _rt::alloc::handle_alloc_error(layout64);
                                        }
                                        ptr
                                    } else {
                                        ::core::ptr::null_mut()
                                    };
                                    for (i, e) in vec64.into_iter().enumerate() {
                                        let base = result64
                                            .add(i * (2 * ::core::mem::size_of::<*const u8>()));
                                        {
                                            let vec63 = e;
                                            let ptr63 = vec63.as_ptr().cast::<u8>();
                                            let len63 = vec63.len();
                                            *base
                                                .add(::core::mem::size_of::<*const u8>())
                                                .cast::<usize>() = len63;
                                            *base.add(0).cast::<*mut u8>() = ptr63.cast_mut();
                                        }
                                    }
                                    *base
                                        .add(8 + 3 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len64;
                                    *base
                                        .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                        .cast::<*mut u8>() = result64;
                                    cleanup_list.extend_from_slice(&[(result64, layout64)]);
                                }
                                Value::BoolArray(e) => {
                                    *base
                                        .add(2 * ::core::mem::size_of::<*const u8>())
                                        .cast::<u8>() = (5i32) as u8;
                                    let vec65 = e;
                                    let len65 = vec65.len();
                                    let layout65 = _rt::alloc::Layout::from_size_align_unchecked(
                                        vec65.len() * 1,
                                        1,
                                    );
                                    let result65 = if layout65.size() != 0 {
                                        let ptr = _rt::alloc::alloc(layout65).cast::<u8>();
                                        if ptr.is_null() {
                                            _rt::alloc::handle_alloc_error(layout65);
                                        }
                                        ptr
                                    } else {
                                        ::core::ptr::null_mut()
                                    };
                                    for (i, e) in vec65.into_iter().enumerate() {
                                        let base = result65.add(i * 1);
                                        {
                                            *base.add(0).cast::<u8>() = (match e {
                                                true => 1,
                                                false => 0,
                                            }) as u8;
                                        }
                                    }
                                    *base
                                        .add(8 + 3 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len65;
                                    *base
                                        .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                        .cast::<*mut u8>() = result65;
                                    cleanup_list.extend_from_slice(&[(result65, layout65)]);
                                }
                                Value::F64Array(e) => {
                                    *base
                                        .add(2 * ::core::mem::size_of::<*const u8>())
                                        .cast::<u8>() = (6i32) as u8;
                                    let vec66 = e;
                                    let ptr66 = vec66.as_ptr().cast::<u8>();
                                    let len66 = vec66.len();
                                    *base
                                        .add(8 + 3 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len66;
                                    *base
                                        .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                        .cast::<*mut u8>() = ptr66.cast_mut();
                                }
                                Value::S64Array(e) => {
                                    *base
                                        .add(2 * ::core::mem::size_of::<*const u8>())
                                        .cast::<u8>() = (7i32) as u8;
                                    let vec67 = e;
                                    let ptr67 = vec67.as_ptr().cast::<u8>();
                                    let len67 = vec67.len();
                                    *base
                                        .add(8 + 3 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len67;
                                    *base
                                        .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                        .cast::<*mut u8>() = ptr67.cast_mut();
                                }
                            }
                        }
                    }
                    *ptr0
                        .add(32 + 30 * ::core::mem::size_of::<*const u8>())
                        .cast::<usize>() = len68;
                    *ptr0
                        .add(32 + 29 * ::core::mem::size_of::<*const u8>())
                        .cast::<*mut u8>() = result68;
                    *ptr0
                        .add(32 + 31 * ::core::mem::size_of::<*const u8>())
                        .cast::<i32>() = _rt::as_i32(dropped_attributes1);
                    *ptr0
                        .add(36 + 31 * ::core::mem::size_of::<*const u8>())
                        .cast::<i32>() = _rt::as_i32(dropped_events1);
                    *ptr0
                        .add(40 + 31 * ::core::mem::size_of::<*const u8>())
                        .cast::<i32>() = _rt::as_i32(dropped_links1);
                    let SpanContext {
                        trace_id: trace_id69,
                        span_id: span_id69,
                        trace_flags: trace_flags69,
                        is_remote: is_remote69,
                        trace_state: trace_state69,
                    } = parent;
                    let vec70 = trace_id69;
                    let ptr70 = vec70.as_ptr().cast::<u8>();
                    let len70 = vec70.len();
                    *ptr0
                        .add(40 + 33 * ::core::mem::size_of::<*const u8>())
                        .cast::<usize>() = len70;
                    *ptr0
                        .add(40 + 32 * ::core::mem::size_of::<*const u8>())
                        .cast::<*mut u8>() = ptr70.cast_mut();
                    let vec71 = span_id69;
                    let ptr71 = vec71.as_ptr().cast::<u8>();
                    let len71 = vec71.len();
                    *ptr0
                        .add(40 + 35 * ::core::mem::size_of::<*const u8>())
                        .cast::<usize>() = len71;
                    *ptr0
                        .add(40 + 34 * ::core::mem::size_of::<*const u8>())
                        .cast::<*mut u8>() = ptr71.cast_mut();
                    let flags72 = trace_flags69;
                    *ptr0
                        .add(40 + 36 * ::core::mem::size_of::<*const u8>())
                        .cast::<u8>() = ((flags72.bits() >> 0) as i32) as u8;
                    *ptr0
                        .add(41 + 36 * ::core::mem::size_of::<*const u8>())
                        .cast::<u8>() = (match is_remote69 {
                        true => 1,
                        false => 0,
                    }) as u8;
                    let vec76 = trace_state69;
                    let len76 = vec76.len();
                    let layout76 = _rt::alloc::Layout::from_size_align_unchecked(
                        vec76.len() * (4 * ::core::mem::size_of::<*const u8>()),
                        ::core::mem::size_of::<*const u8>(),
                    );
                    let result76 = if layout76.size() != 0 {
                        let ptr = _rt::alloc::alloc(layout76).cast::<u8>();
                        if ptr.is_null() {
                            _rt::alloc::handle_alloc_error(layout76);
                        }
                        ptr
                    } else {
                        ::core::ptr::null_mut()
                    };
                    for (i, e) in vec76.into_iter().enumerate() {
                        let base = result76
                            .add(i * (4 * ::core::mem::size_of::<*const u8>()));
                        {
                            let (t73_0, t73_1) = e;
                            let vec74 = t73_0;
                            let ptr74 = vec74.as_ptr().cast::<u8>();
                            let len74 = vec74.len();
                            *base
                                .add(::core::mem::size_of::<*const u8>())
                                .cast::<usize>() = len74;
                            *base.add(0).cast::<*mut u8>() = ptr74.cast_mut();
                            let vec75 = t73_1;
                            let ptr75 = vec75.as_ptr().cast::<u8>();
                            let len75 = vec75.len();
                            *base
                                .add(3 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>() = len75;
                            *base
                                .add(2 * ::core::mem::size_of::<*const u8>())
                                .cast::<*mut u8>() = ptr75.cast_mut();
                        }
                    }
                    *ptr0
                        .add(40 + 38 * ::core::mem::size_of::<*const u8>())
                        .cast::<usize>() = len76;
                    *ptr0
                        .add(40 + 37 * ::core::mem::size_of::<*const u8>())
                        .cast::<*mut u8>() = result76;
                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "wasi:otel/tracing@0.2.0-draft")]
                    unsafe extern "C" {
                        #[link_name = "on-start"]
                        fn wit_import77(_: *mut u8);
                    }
                    #[cfg(not(target_arch = "wasm32"))]
                    unsafe extern "C" fn wit_import77(_: *mut u8) {
                        unreachable!()
                    }
                    unsafe { wit_import77(ptr0) };
                    if layout9.size() != 0 {
                        _rt::alloc::dealloc(result9.cast(), layout9);
                    }
                    if layout22.size() != 0 {
                        _rt::alloc::dealloc(result22.cast(), layout22);
                    }
                    if layout35.size() != 0 {
                        _rt::alloc::dealloc(result35.cast(), layout35);
                    }
                    if layout54.size() != 0 {
                        _rt::alloc::dealloc(result54.cast(), layout54);
                    }
                    if layout68.size() != 0 {
                        _rt::alloc::dealloc(result68.cast(), layout68);
                    }
                    if layout76.size() != 0 {
                        _rt::alloc::dealloc(result76.cast(), layout76);
                    }
                    for (ptr, layout) in cleanup_list {
                        if layout.size() != 0 {
                            _rt::alloc::dealloc(ptr.cast(), layout);
                        }
                    }
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            /// Called when a span is ended.
            pub fn on_end(span: &SpanData) -> () {
                unsafe {
                    let mut cleanup_list = _rt::Vec::new();
                    #[repr(align(8))]
                    struct RetArea(
                        [::core::mem::MaybeUninit<
                            u8,
                        >; 40 + 32 * ::core::mem::size_of::<*const u8>()],
                    );
                    let mut ret_area = RetArea(
                        [::core::mem::MaybeUninit::uninit(); 40
                            + 32 * ::core::mem::size_of::<*const u8>()],
                    );
                    let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                    let SpanData {
                        span_context: span_context1,
                        parent_span_id: parent_span_id1,
                        span_kind: span_kind1,
                        name: name1,
                        start_time: start_time1,
                        end_time: end_time1,
                        attributes: attributes1,
                        events: events1,
                        links: links1,
                        status: status1,
                        instrumentation_scope: instrumentation_scope1,
                        dropped_attributes: dropped_attributes1,
                        dropped_events: dropped_events1,
                        dropped_links: dropped_links1,
                    } = span;
                    let SpanContext {
                        trace_id: trace_id2,
                        span_id: span_id2,
                        trace_flags: trace_flags2,
                        is_remote: is_remote2,
                        trace_state: trace_state2,
                    } = span_context1;
                    let vec3 = trace_id2;
                    let ptr3 = vec3.as_ptr().cast::<u8>();
                    let len3 = vec3.len();
                    *ptr0.add(::core::mem::size_of::<*const u8>()).cast::<usize>() = len3;
                    *ptr0.add(0).cast::<*mut u8>() = ptr3.cast_mut();
                    let vec4 = span_id2;
                    let ptr4 = vec4.as_ptr().cast::<u8>();
                    let len4 = vec4.len();
                    *ptr0.add(3 * ::core::mem::size_of::<*const u8>()).cast::<usize>() = len4;
                    *ptr0
                        .add(2 * ::core::mem::size_of::<*const u8>())
                        .cast::<*mut u8>() = ptr4.cast_mut();
                    let flags5 = trace_flags2;
                    *ptr0.add(4 * ::core::mem::size_of::<*const u8>()).cast::<u8>() = ((flags5
                        .bits() >> 0) as i32) as u8;
                    *ptr0
                        .add(1 + 4 * ::core::mem::size_of::<*const u8>())
                        .cast::<u8>() = (match is_remote2 {
                        true => 1,
                        false => 0,
                    }) as u8;
                    let vec9 = trace_state2;
                    let len9 = vec9.len();
                    let layout9 = _rt::alloc::Layout::from_size_align_unchecked(
                        vec9.len() * (4 * ::core::mem::size_of::<*const u8>()),
                        ::core::mem::size_of::<*const u8>(),
                    );
                    let result9 = if layout9.size() != 0 {
                        let ptr = _rt::alloc::alloc(layout9).cast::<u8>();
                        if ptr.is_null() {
                            _rt::alloc::handle_alloc_error(layout9);
                        }
                        ptr
                    } else {
                        ::core::ptr::null_mut()
                    };
                    for (i, e) in vec9.into_iter().enumerate() {
                        let base = result9
                            .add(i * (4 * ::core::mem::size_of::<*const u8>()));
                        {
                            let (t6_0, t6_1) = e;
                            let vec7 = t6_0;
                            let ptr7 = vec7.as_ptr().cast::<u8>();
                            let len7 = vec7.len();
                            *base
                                .add(::core::mem::size_of::<*const u8>())
                                .cast::<usize>() = len7;
                            *base.add(0).cast::<*mut u8>() = ptr7.cast_mut();
                            let vec8 = t6_1;
                            let ptr8 = vec8.as_ptr().cast::<u8>();
                            let len8 = vec8.len();
                            *base
                                .add(3 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>() = len8;
                            *base
                                .add(2 * ::core::mem::size_of::<*const u8>())
                                .cast::<*mut u8>() = ptr8.cast_mut();
                        }
                    }
                    *ptr0.add(6 * ::core::mem::size_of::<*const u8>()).cast::<usize>() = len9;
                    *ptr0
                        .add(5 * ::core::mem::size_of::<*const u8>())
                        .cast::<*mut u8>() = result9;
                    let vec10 = parent_span_id1;
                    let ptr10 = vec10.as_ptr().cast::<u8>();
                    let len10 = vec10.len();
                    *ptr0.add(8 * ::core::mem::size_of::<*const u8>()).cast::<usize>() = len10;
                    *ptr0
                        .add(7 * ::core::mem::size_of::<*const u8>())
                        .cast::<*mut u8>() = ptr10.cast_mut();
                    *ptr0.add(9 * ::core::mem::size_of::<*const u8>()).cast::<u8>() = (span_kind1
                        .clone() as i32) as u8;
                    let vec11 = name1;
                    let ptr11 = vec11.as_ptr().cast::<u8>();
                    let len11 = vec11.len();
                    *ptr0
                        .add(11 * ::core::mem::size_of::<*const u8>())
                        .cast::<usize>() = len11;
                    *ptr0
                        .add(10 * ::core::mem::size_of::<*const u8>())
                        .cast::<*mut u8>() = ptr11.cast_mut();
                    let super::super::super::wasi::clocks::wall_clock::Datetime {
                        seconds: seconds12,
                        nanoseconds: nanoseconds12,
                    } = start_time1;
                    *ptr0.add(12 * ::core::mem::size_of::<*const u8>()).cast::<i64>() = _rt::as_i64(
                        seconds12,
                    );
                    *ptr0
                        .add(8 + 12 * ::core::mem::size_of::<*const u8>())
                        .cast::<i32>() = _rt::as_i32(nanoseconds12);
                    let super::super::super::wasi::clocks::wall_clock::Datetime {
                        seconds: seconds13,
                        nanoseconds: nanoseconds13,
                    } = end_time1;
                    *ptr0
                        .add(16 + 12 * ::core::mem::size_of::<*const u8>())
                        .cast::<i64>() = _rt::as_i64(seconds13);
                    *ptr0
                        .add(24 + 12 * ::core::mem::size_of::<*const u8>())
                        .cast::<i32>() = _rt::as_i32(nanoseconds13);
                    let vec22 = attributes1;
                    let len22 = vec22.len();
                    let layout22 = _rt::alloc::Layout::from_size_align_unchecked(
                        vec22.len() * (8 + 4 * ::core::mem::size_of::<*const u8>()),
                        8,
                    );
                    let result22 = if layout22.size() != 0 {
                        let ptr = _rt::alloc::alloc(layout22).cast::<u8>();
                        if ptr.is_null() {
                            _rt::alloc::handle_alloc_error(layout22);
                        }
                        ptr
                    } else {
                        ::core::ptr::null_mut()
                    };
                    for (i, e) in vec22.into_iter().enumerate() {
                        let base = result22
                            .add(i * (8 + 4 * ::core::mem::size_of::<*const u8>()));
                        {
                            let KeyValue { key: key14, value: value14 } = e;
                            let vec15 = key14;
                            let ptr15 = vec15.as_ptr().cast::<u8>();
                            let len15 = vec15.len();
                            *base
                                .add(::core::mem::size_of::<*const u8>())
                                .cast::<usize>() = len15;
                            *base.add(0).cast::<*mut u8>() = ptr15.cast_mut();
                            match value14 {
                                Value::String(e) => {
                                    *base
                                        .add(2 * ::core::mem::size_of::<*const u8>())
                                        .cast::<u8>() = (0i32) as u8;
                                    let vec16 = e;
                                    let ptr16 = vec16.as_ptr().cast::<u8>();
                                    let len16 = vec16.len();
                                    *base
                                        .add(8 + 3 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len16;
                                    *base
                                        .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                        .cast::<*mut u8>() = ptr16.cast_mut();
                                }
                                Value::Bool(e) => {
                                    *base
                                        .add(2 * ::core::mem::size_of::<*const u8>())
                                        .cast::<u8>() = (1i32) as u8;
                                    *base
                                        .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                        .cast::<u8>() = (match e {
                                        true => 1,
                                        false => 0,
                                    }) as u8;
                                }
                                Value::F64(e) => {
                                    *base
                                        .add(2 * ::core::mem::size_of::<*const u8>())
                                        .cast::<u8>() = (2i32) as u8;
                                    *base
                                        .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                        .cast::<f64>() = _rt::as_f64(e);
                                }
                                Value::S64(e) => {
                                    *base
                                        .add(2 * ::core::mem::size_of::<*const u8>())
                                        .cast::<u8>() = (3i32) as u8;
                                    *base
                                        .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                        .cast::<i64>() = _rt::as_i64(e);
                                }
                                Value::StringArray(e) => {
                                    *base
                                        .add(2 * ::core::mem::size_of::<*const u8>())
                                        .cast::<u8>() = (4i32) as u8;
                                    let vec18 = e;
                                    let len18 = vec18.len();
                                    let layout18 = _rt::alloc::Layout::from_size_align_unchecked(
                                        vec18.len() * (2 * ::core::mem::size_of::<*const u8>()),
                                        ::core::mem::size_of::<*const u8>(),
                                    );
                                    let result18 = if layout18.size() != 0 {
                                        let ptr = _rt::alloc::alloc(layout18).cast::<u8>();
                                        if ptr.is_null() {
                                            _rt::alloc::handle_alloc_error(layout18);
                                        }
                                        ptr
                                    } else {
                                        ::core::ptr::null_mut()
                                    };
                                    for (i, e) in vec18.into_iter().enumerate() {
                                        let base = result18
                                            .add(i * (2 * ::core::mem::size_of::<*const u8>()));
                                        {
                                            let vec17 = e;
                                            let ptr17 = vec17.as_ptr().cast::<u8>();
                                            let len17 = vec17.len();
                                            *base
                                                .add(::core::mem::size_of::<*const u8>())
                                                .cast::<usize>() = len17;
                                            *base.add(0).cast::<*mut u8>() = ptr17.cast_mut();
                                        }
                                    }
                                    *base
                                        .add(8 + 3 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len18;
                                    *base
                                        .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                        .cast::<*mut u8>() = result18;
                                    cleanup_list.extend_from_slice(&[(result18, layout18)]);
                                }
                                Value::BoolArray(e) => {
                                    *base
                                        .add(2 * ::core::mem::size_of::<*const u8>())
                                        .cast::<u8>() = (5i32) as u8;
                                    let vec19 = e;
                                    let len19 = vec19.len();
                                    let layout19 = _rt::alloc::Layout::from_size_align_unchecked(
                                        vec19.len() * 1,
                                        1,
                                    );
                                    let result19 = if layout19.size() != 0 {
                                        let ptr = _rt::alloc::alloc(layout19).cast::<u8>();
                                        if ptr.is_null() {
                                            _rt::alloc::handle_alloc_error(layout19);
                                        }
                                        ptr
                                    } else {
                                        ::core::ptr::null_mut()
                                    };
                                    for (i, e) in vec19.into_iter().enumerate() {
                                        let base = result19.add(i * 1);
                                        {
                                            *base.add(0).cast::<u8>() = (match e {
                                                true => 1,
                                                false => 0,
                                            }) as u8;
                                        }
                                    }
                                    *base
                                        .add(8 + 3 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len19;
                                    *base
                                        .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                        .cast::<*mut u8>() = result19;
                                    cleanup_list.extend_from_slice(&[(result19, layout19)]);
                                }
                                Value::F64Array(e) => {
                                    *base
                                        .add(2 * ::core::mem::size_of::<*const u8>())
                                        .cast::<u8>() = (6i32) as u8;
                                    let vec20 = e;
                                    let ptr20 = vec20.as_ptr().cast::<u8>();
                                    let len20 = vec20.len();
                                    *base
                                        .add(8 + 3 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len20;
                                    *base
                                        .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                        .cast::<*mut u8>() = ptr20.cast_mut();
                                }
                                Value::S64Array(e) => {
                                    *base
                                        .add(2 * ::core::mem::size_of::<*const u8>())
                                        .cast::<u8>() = (7i32) as u8;
                                    let vec21 = e;
                                    let ptr21 = vec21.as_ptr().cast::<u8>();
                                    let len21 = vec21.len();
                                    *base
                                        .add(8 + 3 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len21;
                                    *base
                                        .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                        .cast::<*mut u8>() = ptr21.cast_mut();
                                }
                            }
                        }
                    }
                    *ptr0
                        .add(32 + 13 * ::core::mem::size_of::<*const u8>())
                        .cast::<usize>() = len22;
                    *ptr0
                        .add(32 + 12 * ::core::mem::size_of::<*const u8>())
                        .cast::<*mut u8>() = result22;
                    let vec35 = events1;
                    let len35 = vec35.len();
                    let layout35 = _rt::alloc::Layout::from_size_align_unchecked(
                        vec35.len() * (16 + 4 * ::core::mem::size_of::<*const u8>()),
                        8,
                    );
                    let result35 = if layout35.size() != 0 {
                        let ptr = _rt::alloc::alloc(layout35).cast::<u8>();
                        if ptr.is_null() {
                            _rt::alloc::handle_alloc_error(layout35);
                        }
                        ptr
                    } else {
                        ::core::ptr::null_mut()
                    };
                    for (i, e) in vec35.into_iter().enumerate() {
                        let base = result35
                            .add(i * (16 + 4 * ::core::mem::size_of::<*const u8>()));
                        {
                            let Event {
                                name: name23,
                                time: time23,
                                attributes: attributes23,
                            } = e;
                            let vec24 = name23;
                            let ptr24 = vec24.as_ptr().cast::<u8>();
                            let len24 = vec24.len();
                            *base
                                .add(::core::mem::size_of::<*const u8>())
                                .cast::<usize>() = len24;
                            *base.add(0).cast::<*mut u8>() = ptr24.cast_mut();
                            let super::super::super::wasi::clocks::wall_clock::Datetime {
                                seconds: seconds25,
                                nanoseconds: nanoseconds25,
                            } = time23;
                            *base
                                .add(2 * ::core::mem::size_of::<*const u8>())
                                .cast::<i64>() = _rt::as_i64(seconds25);
                            *base
                                .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                .cast::<i32>() = _rt::as_i32(nanoseconds25);
                            let vec34 = attributes23;
                            let len34 = vec34.len();
                            let layout34 = _rt::alloc::Layout::from_size_align_unchecked(
                                vec34.len() * (8 + 4 * ::core::mem::size_of::<*const u8>()),
                                8,
                            );
                            let result34 = if layout34.size() != 0 {
                                let ptr = _rt::alloc::alloc(layout34).cast::<u8>();
                                if ptr.is_null() {
                                    _rt::alloc::handle_alloc_error(layout34);
                                }
                                ptr
                            } else {
                                ::core::ptr::null_mut()
                            };
                            for (i, e) in vec34.into_iter().enumerate() {
                                let base = result34
                                    .add(i * (8 + 4 * ::core::mem::size_of::<*const u8>()));
                                {
                                    let KeyValue { key: key26, value: value26 } = e;
                                    let vec27 = key26;
                                    let ptr27 = vec27.as_ptr().cast::<u8>();
                                    let len27 = vec27.len();
                                    *base
                                        .add(::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len27;
                                    *base.add(0).cast::<*mut u8>() = ptr27.cast_mut();
                                    match value26 {
                                        Value::String(e) => {
                                            *base
                                                .add(2 * ::core::mem::size_of::<*const u8>())
                                                .cast::<u8>() = (0i32) as u8;
                                            let vec28 = e;
                                            let ptr28 = vec28.as_ptr().cast::<u8>();
                                            let len28 = vec28.len();
                                            *base
                                                .add(8 + 3 * ::core::mem::size_of::<*const u8>())
                                                .cast::<usize>() = len28;
                                            *base
                                                .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                .cast::<*mut u8>() = ptr28.cast_mut();
                                        }
                                        Value::Bool(e) => {
                                            *base
                                                .add(2 * ::core::mem::size_of::<*const u8>())
                                                .cast::<u8>() = (1i32) as u8;
                                            *base
                                                .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                .cast::<u8>() = (match e {
                                                true => 1,
                                                false => 0,
                                            }) as u8;
                                        }
                                        Value::F64(e) => {
                                            *base
                                                .add(2 * ::core::mem::size_of::<*const u8>())
                                                .cast::<u8>() = (2i32) as u8;
                                            *base
                                                .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                .cast::<f64>() = _rt::as_f64(e);
                                        }
                                        Value::S64(e) => {
                                            *base
                                                .add(2 * ::core::mem::size_of::<*const u8>())
                                                .cast::<u8>() = (3i32) as u8;
                                            *base
                                                .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                .cast::<i64>() = _rt::as_i64(e);
                                        }
                                        Value::StringArray(e) => {
                                            *base
                                                .add(2 * ::core::mem::size_of::<*const u8>())
                                                .cast::<u8>() = (4i32) as u8;
                                            let vec30 = e;
                                            let len30 = vec30.len();
                                            let layout30 = _rt::alloc::Layout::from_size_align_unchecked(
                                                vec30.len() * (2 * ::core::mem::size_of::<*const u8>()),
                                                ::core::mem::size_of::<*const u8>(),
                                            );
                                            let result30 = if layout30.size() != 0 {
                                                let ptr = _rt::alloc::alloc(layout30).cast::<u8>();
                                                if ptr.is_null() {
                                                    _rt::alloc::handle_alloc_error(layout30);
                                                }
                                                ptr
                                            } else {
                                                ::core::ptr::null_mut()
                                            };
                                            for (i, e) in vec30.into_iter().enumerate() {
                                                let base = result30
                                                    .add(i * (2 * ::core::mem::size_of::<*const u8>()));
                                                {
                                                    let vec29 = e;
                                                    let ptr29 = vec29.as_ptr().cast::<u8>();
                                                    let len29 = vec29.len();
                                                    *base
                                                        .add(::core::mem::size_of::<*const u8>())
                                                        .cast::<usize>() = len29;
                                                    *base.add(0).cast::<*mut u8>() = ptr29.cast_mut();
                                                }
                                            }
                                            *base
                                                .add(8 + 3 * ::core::mem::size_of::<*const u8>())
                                                .cast::<usize>() = len30;
                                            *base
                                                .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                .cast::<*mut u8>() = result30;
                                            cleanup_list.extend_from_slice(&[(result30, layout30)]);
                                        }
                                        Value::BoolArray(e) => {
                                            *base
                                                .add(2 * ::core::mem::size_of::<*const u8>())
                                                .cast::<u8>() = (5i32) as u8;
                                            let vec31 = e;
                                            let len31 = vec31.len();
                                            let layout31 = _rt::alloc::Layout::from_size_align_unchecked(
                                                vec31.len() * 1,
                                                1,
                                            );
                                            let result31 = if layout31.size() != 0 {
                                                let ptr = _rt::alloc::alloc(layout31).cast::<u8>();
                                                if ptr.is_null() {
                                                    _rt::alloc::handle_alloc_error(layout31);
                                                }
                                                ptr
                                            } else {
                                                ::core::ptr::null_mut()
                                            };
                                            for (i, e) in vec31.into_iter().enumerate() {
                                                let base = result31.add(i * 1);
                                                {
                                                    *base.add(0).cast::<u8>() = (match e {
                                                        true => 1,
                                                        false => 0,
                                                    }) as u8;
                                                }
                                            }
                                            *base
                                                .add(8 + 3 * ::core::mem::size_of::<*const u8>())
                                                .cast::<usize>() = len31;
                                            *base
                                                .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                .cast::<*mut u8>() = result31;
                                            cleanup_list.extend_from_slice(&[(result31, layout31)]);
                                        }
                                        Value::F64Array(e) => {
                                            *base
                                                .add(2 * ::core::mem::size_of::<*const u8>())
                                                .cast::<u8>() = (6i32) as u8;
                                            let vec32 = e;
                                            let ptr32 = vec32.as_ptr().cast::<u8>();
                                            let len32 = vec32.len();
                                            *base
                                                .add(8 + 3 * ::core::mem::size_of::<*const u8>())
                                                .cast::<usize>() = len32;
                                            *base
                                                .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                .cast::<*mut u8>() = ptr32.cast_mut();
                                        }
                                        Value::S64Array(e) => {
                                            *base
                                                .add(2 * ::core::mem::size_of::<*const u8>())
                                                .cast::<u8>() = (7i32) as u8;
                                            let vec33 = e;
                                            let ptr33 = vec33.as_ptr().cast::<u8>();
                                            let len33 = vec33.len();
                                            *base
                                                .add(8 + 3 * ::core::mem::size_of::<*const u8>())
                                                .cast::<usize>() = len33;
                                            *base
                                                .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                .cast::<*mut u8>() = ptr33.cast_mut();
                                        }
                                    }
                                }
                            }
                            *base
                                .add(16 + 3 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>() = len34;
                            *base
                                .add(16 + 2 * ::core::mem::size_of::<*const u8>())
                                .cast::<*mut u8>() = result34;
                            cleanup_list.extend_from_slice(&[(result34, layout34)]);
                        }
                    }
                    *ptr0
                        .add(32 + 15 * ::core::mem::size_of::<*const u8>())
                        .cast::<usize>() = len35;
                    *ptr0
                        .add(32 + 14 * ::core::mem::size_of::<*const u8>())
                        .cast::<*mut u8>() = result35;
                    let vec54 = links1;
                    let len54 = vec54.len();
                    let layout54 = _rt::alloc::Layout::from_size_align_unchecked(
                        vec54.len() * (9 * ::core::mem::size_of::<*const u8>()),
                        ::core::mem::size_of::<*const u8>(),
                    );
                    let result54 = if layout54.size() != 0 {
                        let ptr = _rt::alloc::alloc(layout54).cast::<u8>();
                        if ptr.is_null() {
                            _rt::alloc::handle_alloc_error(layout54);
                        }
                        ptr
                    } else {
                        ::core::ptr::null_mut()
                    };
                    for (i, e) in vec54.into_iter().enumerate() {
                        let base = result54
                            .add(i * (9 * ::core::mem::size_of::<*const u8>()));
                        {
                            let Link {
                                span_context: span_context36,
                                attributes: attributes36,
                            } = e;
                            let SpanContext {
                                trace_id: trace_id37,
                                span_id: span_id37,
                                trace_flags: trace_flags37,
                                is_remote: is_remote37,
                                trace_state: trace_state37,
                            } = span_context36;
                            let vec38 = trace_id37;
                            let ptr38 = vec38.as_ptr().cast::<u8>();
                            let len38 = vec38.len();
                            *base
                                .add(::core::mem::size_of::<*const u8>())
                                .cast::<usize>() = len38;
                            *base.add(0).cast::<*mut u8>() = ptr38.cast_mut();
                            let vec39 = span_id37;
                            let ptr39 = vec39.as_ptr().cast::<u8>();
                            let len39 = vec39.len();
                            *base
                                .add(3 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>() = len39;
                            *base
                                .add(2 * ::core::mem::size_of::<*const u8>())
                                .cast::<*mut u8>() = ptr39.cast_mut();
                            let flags40 = trace_flags37;
                            *base
                                .add(4 * ::core::mem::size_of::<*const u8>())
                                .cast::<u8>() = ((flags40.bits() >> 0) as i32) as u8;
                            *base
                                .add(1 + 4 * ::core::mem::size_of::<*const u8>())
                                .cast::<u8>() = (match is_remote37 {
                                true => 1,
                                false => 0,
                            }) as u8;
                            let vec44 = trace_state37;
                            let len44 = vec44.len();
                            let layout44 = _rt::alloc::Layout::from_size_align_unchecked(
                                vec44.len() * (4 * ::core::mem::size_of::<*const u8>()),
                                ::core::mem::size_of::<*const u8>(),
                            );
                            let result44 = if layout44.size() != 0 {
                                let ptr = _rt::alloc::alloc(layout44).cast::<u8>();
                                if ptr.is_null() {
                                    _rt::alloc::handle_alloc_error(layout44);
                                }
                                ptr
                            } else {
                                ::core::ptr::null_mut()
                            };
                            for (i, e) in vec44.into_iter().enumerate() {
                                let base = result44
                                    .add(i * (4 * ::core::mem::size_of::<*const u8>()));
                                {
                                    let (t41_0, t41_1) = e;
                                    let vec42 = t41_0;
                                    let ptr42 = vec42.as_ptr().cast::<u8>();
                                    let len42 = vec42.len();
                                    *base
                                        .add(::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len42;
                                    *base.add(0).cast::<*mut u8>() = ptr42.cast_mut();
                                    let vec43 = t41_1;
                                    let ptr43 = vec43.as_ptr().cast::<u8>();
                                    let len43 = vec43.len();
                                    *base
                                        .add(3 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len43;
                                    *base
                                        .add(2 * ::core::mem::size_of::<*const u8>())
                                        .cast::<*mut u8>() = ptr43.cast_mut();
                                }
                            }
                            *base
                                .add(6 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>() = len44;
                            *base
                                .add(5 * ::core::mem::size_of::<*const u8>())
                                .cast::<*mut u8>() = result44;
                            let vec53 = attributes36;
                            let len53 = vec53.len();
                            let layout53 = _rt::alloc::Layout::from_size_align_unchecked(
                                vec53.len() * (8 + 4 * ::core::mem::size_of::<*const u8>()),
                                8,
                            );
                            let result53 = if layout53.size() != 0 {
                                let ptr = _rt::alloc::alloc(layout53).cast::<u8>();
                                if ptr.is_null() {
                                    _rt::alloc::handle_alloc_error(layout53);
                                }
                                ptr
                            } else {
                                ::core::ptr::null_mut()
                            };
                            for (i, e) in vec53.into_iter().enumerate() {
                                let base = result53
                                    .add(i * (8 + 4 * ::core::mem::size_of::<*const u8>()));
                                {
                                    let KeyValue { key: key45, value: value45 } = e;
                                    let vec46 = key45;
                                    let ptr46 = vec46.as_ptr().cast::<u8>();
                                    let len46 = vec46.len();
                                    *base
                                        .add(::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len46;
                                    *base.add(0).cast::<*mut u8>() = ptr46.cast_mut();
                                    match value45 {
                                        Value::String(e) => {
                                            *base
                                                .add(2 * ::core::mem::size_of::<*const u8>())
                                                .cast::<u8>() = (0i32) as u8;
                                            let vec47 = e;
                                            let ptr47 = vec47.as_ptr().cast::<u8>();
                                            let len47 = vec47.len();
                                            *base
                                                .add(8 + 3 * ::core::mem::size_of::<*const u8>())
                                                .cast::<usize>() = len47;
                                            *base
                                                .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                .cast::<*mut u8>() = ptr47.cast_mut();
                                        }
                                        Value::Bool(e) => {
                                            *base
                                                .add(2 * ::core::mem::size_of::<*const u8>())
                                                .cast::<u8>() = (1i32) as u8;
                                            *base
                                                .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                .cast::<u8>() = (match e {
                                                true => 1,
                                                false => 0,
                                            }) as u8;
                                        }
                                        Value::F64(e) => {
                                            *base
                                                .add(2 * ::core::mem::size_of::<*const u8>())
                                                .cast::<u8>() = (2i32) as u8;
                                            *base
                                                .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                .cast::<f64>() = _rt::as_f64(e);
                                        }
                                        Value::S64(e) => {
                                            *base
                                                .add(2 * ::core::mem::size_of::<*const u8>())
                                                .cast::<u8>() = (3i32) as u8;
                                            *base
                                                .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                .cast::<i64>() = _rt::as_i64(e);
                                        }
                                        Value::StringArray(e) => {
                                            *base
                                                .add(2 * ::core::mem::size_of::<*const u8>())
                                                .cast::<u8>() = (4i32) as u8;
                                            let vec49 = e;
                                            let len49 = vec49.len();
                                            let layout49 = _rt::alloc::Layout::from_size_align_unchecked(
                                                vec49.len() * (2 * ::core::mem::size_of::<*const u8>()),
                                                ::core::mem::size_of::<*const u8>(),
                                            );
                                            let result49 = if layout49.size() != 0 {
                                                let ptr = _rt::alloc::alloc(layout49).cast::<u8>();
                                                if ptr.is_null() {
                                                    _rt::alloc::handle_alloc_error(layout49);
                                                }
                                                ptr
                                            } else {
                                                ::core::ptr::null_mut()
                                            };
                                            for (i, e) in vec49.into_iter().enumerate() {
                                                let base = result49
                                                    .add(i * (2 * ::core::mem::size_of::<*const u8>()));
                                                {
                                                    let vec48 = e;
                                                    let ptr48 = vec48.as_ptr().cast::<u8>();
                                                    let len48 = vec48.len();
                                                    *base
                                                        .add(::core::mem::size_of::<*const u8>())
                                                        .cast::<usize>() = len48;
                                                    *base.add(0).cast::<*mut u8>() = ptr48.cast_mut();
                                                }
                                            }
                                            *base
                                                .add(8 + 3 * ::core::mem::size_of::<*const u8>())
                                                .cast::<usize>() = len49;
                                            *base
                                                .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                .cast::<*mut u8>() = result49;
                                            cleanup_list.extend_from_slice(&[(result49, layout49)]);
                                        }
                                        Value::BoolArray(e) => {
                                            *base
                                                .add(2 * ::core::mem::size_of::<*const u8>())
                                                .cast::<u8>() = (5i32) as u8;
                                            let vec50 = e;
                                            let len50 = vec50.len();
                                            let layout50 = _rt::alloc::Layout::from_size_align_unchecked(
                                                vec50.len() * 1,
                                                1,
                                            );
                                            let result50 = if layout50.size() != 0 {
                                                let ptr = _rt::alloc::alloc(layout50).cast::<u8>();
                                                if ptr.is_null() {
                                                    _rt::alloc::handle_alloc_error(layout50);
                                                }
                                                ptr
                                            } else {
                                                ::core::ptr::null_mut()
                                            };
                                            for (i, e) in vec50.into_iter().enumerate() {
                                                let base = result50.add(i * 1);
                                                {
                                                    *base.add(0).cast::<u8>() = (match e {
                                                        true => 1,
                                                        false => 0,
                                                    }) as u8;
                                                }
                                            }
                                            *base
                                                .add(8 + 3 * ::core::mem::size_of::<*const u8>())
                                                .cast::<usize>() = len50;
                                            *base
                                                .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                .cast::<*mut u8>() = result50;
                                            cleanup_list.extend_from_slice(&[(result50, layout50)]);
                                        }
                                        Value::F64Array(e) => {
                                            *base
                                                .add(2 * ::core::mem::size_of::<*const u8>())
                                                .cast::<u8>() = (6i32) as u8;
                                            let vec51 = e;
                                            let ptr51 = vec51.as_ptr().cast::<u8>();
                                            let len51 = vec51.len();
                                            *base
                                                .add(8 + 3 * ::core::mem::size_of::<*const u8>())
                                                .cast::<usize>() = len51;
                                            *base
                                                .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                .cast::<*mut u8>() = ptr51.cast_mut();
                                        }
                                        Value::S64Array(e) => {
                                            *base
                                                .add(2 * ::core::mem::size_of::<*const u8>())
                                                .cast::<u8>() = (7i32) as u8;
                                            let vec52 = e;
                                            let ptr52 = vec52.as_ptr().cast::<u8>();
                                            let len52 = vec52.len();
                                            *base
                                                .add(8 + 3 * ::core::mem::size_of::<*const u8>())
                                                .cast::<usize>() = len52;
                                            *base
                                                .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                .cast::<*mut u8>() = ptr52.cast_mut();
                                        }
                                    }
                                }
                            }
                            *base
                                .add(8 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>() = len53;
                            *base
                                .add(7 * ::core::mem::size_of::<*const u8>())
                                .cast::<*mut u8>() = result53;
                            cleanup_list
                                .extend_from_slice(
                                    &[(result44, layout44), (result53, layout53)],
                                );
                        }
                    }
                    *ptr0
                        .add(32 + 17 * ::core::mem::size_of::<*const u8>())
                        .cast::<usize>() = len54;
                    *ptr0
                        .add(32 + 16 * ::core::mem::size_of::<*const u8>())
                        .cast::<*mut u8>() = result54;
                    match status1 {
                        Status::Unset => {
                            *ptr0
                                .add(32 + 18 * ::core::mem::size_of::<*const u8>())
                                .cast::<u8>() = (0i32) as u8;
                        }
                        Status::Ok => {
                            *ptr0
                                .add(32 + 18 * ::core::mem::size_of::<*const u8>())
                                .cast::<u8>() = (1i32) as u8;
                        }
                        Status::Error(e) => {
                            *ptr0
                                .add(32 + 18 * ::core::mem::size_of::<*const u8>())
                                .cast::<u8>() = (2i32) as u8;
                            let vec55 = e;
                            let ptr55 = vec55.as_ptr().cast::<u8>();
                            let len55 = vec55.len();
                            *ptr0
                                .add(32 + 20 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>() = len55;
                            *ptr0
                                .add(32 + 19 * ::core::mem::size_of::<*const u8>())
                                .cast::<*mut u8>() = ptr55.cast_mut();
                        }
                    }
                    let InstrumentationScope {
                        name: name56,
                        version: version56,
                        schema_url: schema_url56,
                        attributes: attributes56,
                    } = instrumentation_scope1;
                    let vec57 = name56;
                    let ptr57 = vec57.as_ptr().cast::<u8>();
                    let len57 = vec57.len();
                    *ptr0
                        .add(32 + 22 * ::core::mem::size_of::<*const u8>())
                        .cast::<usize>() = len57;
                    *ptr0
                        .add(32 + 21 * ::core::mem::size_of::<*const u8>())
                        .cast::<*mut u8>() = ptr57.cast_mut();
                    match version56 {
                        Some(e) => {
                            *ptr0
                                .add(32 + 23 * ::core::mem::size_of::<*const u8>())
                                .cast::<u8>() = (1i32) as u8;
                            let vec58 = e;
                            let ptr58 = vec58.as_ptr().cast::<u8>();
                            let len58 = vec58.len();
                            *ptr0
                                .add(32 + 25 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>() = len58;
                            *ptr0
                                .add(32 + 24 * ::core::mem::size_of::<*const u8>())
                                .cast::<*mut u8>() = ptr58.cast_mut();
                        }
                        None => {
                            *ptr0
                                .add(32 + 23 * ::core::mem::size_of::<*const u8>())
                                .cast::<u8>() = (0i32) as u8;
                        }
                    };
                    match schema_url56 {
                        Some(e) => {
                            *ptr0
                                .add(32 + 26 * ::core::mem::size_of::<*const u8>())
                                .cast::<u8>() = (1i32) as u8;
                            let vec59 = e;
                            let ptr59 = vec59.as_ptr().cast::<u8>();
                            let len59 = vec59.len();
                            *ptr0
                                .add(32 + 28 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>() = len59;
                            *ptr0
                                .add(32 + 27 * ::core::mem::size_of::<*const u8>())
                                .cast::<*mut u8>() = ptr59.cast_mut();
                        }
                        None => {
                            *ptr0
                                .add(32 + 26 * ::core::mem::size_of::<*const u8>())
                                .cast::<u8>() = (0i32) as u8;
                        }
                    };
                    let vec68 = attributes56;
                    let len68 = vec68.len();
                    let layout68 = _rt::alloc::Layout::from_size_align_unchecked(
                        vec68.len() * (8 + 4 * ::core::mem::size_of::<*const u8>()),
                        8,
                    );
                    let result68 = if layout68.size() != 0 {
                        let ptr = _rt::alloc::alloc(layout68).cast::<u8>();
                        if ptr.is_null() {
                            _rt::alloc::handle_alloc_error(layout68);
                        }
                        ptr
                    } else {
                        ::core::ptr::null_mut()
                    };
                    for (i, e) in vec68.into_iter().enumerate() {
                        let base = result68
                            .add(i * (8 + 4 * ::core::mem::size_of::<*const u8>()));
                        {
                            let KeyValue { key: key60, value: value60 } = e;
                            let vec61 = key60;
                            let ptr61 = vec61.as_ptr().cast::<u8>();
                            let len61 = vec61.len();
                            *base
                                .add(::core::mem::size_of::<*const u8>())
                                .cast::<usize>() = len61;
                            *base.add(0).cast::<*mut u8>() = ptr61.cast_mut();
                            match value60 {
                                Value::String(e) => {
                                    *base
                                        .add(2 * ::core::mem::size_of::<*const u8>())
                                        .cast::<u8>() = (0i32) as u8;
                                    let vec62 = e;
                                    let ptr62 = vec62.as_ptr().cast::<u8>();
                                    let len62 = vec62.len();
                                    *base
                                        .add(8 + 3 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len62;
                                    *base
                                        .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                        .cast::<*mut u8>() = ptr62.cast_mut();
                                }
                                Value::Bool(e) => {
                                    *base
                                        .add(2 * ::core::mem::size_of::<*const u8>())
                                        .cast::<u8>() = (1i32) as u8;
                                    *base
                                        .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                        .cast::<u8>() = (match e {
                                        true => 1,
                                        false => 0,
                                    }) as u8;
                                }
                                Value::F64(e) => {
                                    *base
                                        .add(2 * ::core::mem::size_of::<*const u8>())
                                        .cast::<u8>() = (2i32) as u8;
                                    *base
                                        .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                        .cast::<f64>() = _rt::as_f64(e);
                                }
                                Value::S64(e) => {
                                    *base
                                        .add(2 * ::core::mem::size_of::<*const u8>())
                                        .cast::<u8>() = (3i32) as u8;
                                    *base
                                        .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                        .cast::<i64>() = _rt::as_i64(e);
                                }
                                Value::StringArray(e) => {
                                    *base
                                        .add(2 * ::core::mem::size_of::<*const u8>())
                                        .cast::<u8>() = (4i32) as u8;
                                    let vec64 = e;
                                    let len64 = vec64.len();
                                    let layout64 = _rt::alloc::Layout::from_size_align_unchecked(
                                        vec64.len() * (2 * ::core::mem::size_of::<*const u8>()),
                                        ::core::mem::size_of::<*const u8>(),
                                    );
                                    let result64 = if layout64.size() != 0 {
                                        let ptr = _rt::alloc::alloc(layout64).cast::<u8>();
                                        if ptr.is_null() {
                                            _rt::alloc::handle_alloc_error(layout64);
                                        }
                                        ptr
                                    } else {
                                        ::core::ptr::null_mut()
                                    };
                                    for (i, e) in vec64.into_iter().enumerate() {
                                        let base = result64
                                            .add(i * (2 * ::core::mem::size_of::<*const u8>()));
                                        {
                                            let vec63 = e;
                                            let ptr63 = vec63.as_ptr().cast::<u8>();
                                            let len63 = vec63.len();
                                            *base
                                                .add(::core::mem::size_of::<*const u8>())
                                                .cast::<usize>() = len63;
                                            *base.add(0).cast::<*mut u8>() = ptr63.cast_mut();
                                        }
                                    }
                                    *base
                                        .add(8 + 3 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len64;
                                    *base
                                        .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                        .cast::<*mut u8>() = result64;
                                    cleanup_list.extend_from_slice(&[(result64, layout64)]);
                                }
                                Value::BoolArray(e) => {
                                    *base
                                        .add(2 * ::core::mem::size_of::<*const u8>())
                                        .cast::<u8>() = (5i32) as u8;
                                    let vec65 = e;
                                    let len65 = vec65.len();
                                    let layout65 = _rt::alloc::Layout::from_size_align_unchecked(
                                        vec65.len() * 1,
                                        1,
                                    );
                                    let result65 = if layout65.size() != 0 {
                                        let ptr = _rt::alloc::alloc(layout65).cast::<u8>();
                                        if ptr.is_null() {
                                            _rt::alloc::handle_alloc_error(layout65);
                                        }
                                        ptr
                                    } else {
                                        ::core::ptr::null_mut()
                                    };
                                    for (i, e) in vec65.into_iter().enumerate() {
                                        let base = result65.add(i * 1);
                                        {
                                            *base.add(0).cast::<u8>() = (match e {
                                                true => 1,
                                                false => 0,
                                            }) as u8;
                                        }
                                    }
                                    *base
                                        .add(8 + 3 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len65;
                                    *base
                                        .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                        .cast::<*mut u8>() = result65;
                                    cleanup_list.extend_from_slice(&[(result65, layout65)]);
                                }
                                Value::F64Array(e) => {
                                    *base
                                        .add(2 * ::core::mem::size_of::<*const u8>())
                                        .cast::<u8>() = (6i32) as u8;
                                    let vec66 = e;
                                    let ptr66 = vec66.as_ptr().cast::<u8>();
                                    let len66 = vec66.len();
                                    *base
                                        .add(8 + 3 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len66;
                                    *base
                                        .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                        .cast::<*mut u8>() = ptr66.cast_mut();
                                }
                                Value::S64Array(e) => {
                                    *base
                                        .add(2 * ::core::mem::size_of::<*const u8>())
                                        .cast::<u8>() = (7i32) as u8;
                                    let vec67 = e;
                                    let ptr67 = vec67.as_ptr().cast::<u8>();
                                    let len67 = vec67.len();
                                    *base
                                        .add(8 + 3 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len67;
                                    *base
                                        .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                        .cast::<*mut u8>() = ptr67.cast_mut();
                                }
                            }
                        }
                    }
                    *ptr0
                        .add(32 + 30 * ::core::mem::size_of::<*const u8>())
                        .cast::<usize>() = len68;
                    *ptr0
                        .add(32 + 29 * ::core::mem::size_of::<*const u8>())
                        .cast::<*mut u8>() = result68;
                    *ptr0
                        .add(32 + 31 * ::core::mem::size_of::<*const u8>())
                        .cast::<i32>() = _rt::as_i32(dropped_attributes1);
                    *ptr0
                        .add(36 + 31 * ::core::mem::size_of::<*const u8>())
                        .cast::<i32>() = _rt::as_i32(dropped_events1);
                    *ptr0
                        .add(40 + 31 * ::core::mem::size_of::<*const u8>())
                        .cast::<i32>() = _rt::as_i32(dropped_links1);
                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "wasi:otel/tracing@0.2.0-draft")]
                    unsafe extern "C" {
                        #[link_name = "on-end"]
                        fn wit_import69(_: *mut u8);
                    }
                    #[cfg(not(target_arch = "wasm32"))]
                    unsafe extern "C" fn wit_import69(_: *mut u8) {
                        unreachable!()
                    }
                    unsafe { wit_import69(ptr0) };
                    if layout9.size() != 0 {
                        _rt::alloc::dealloc(result9.cast(), layout9);
                    }
                    if layout22.size() != 0 {
                        _rt::alloc::dealloc(result22.cast(), layout22);
                    }
                    if layout35.size() != 0 {
                        _rt::alloc::dealloc(result35.cast(), layout35);
                    }
                    if layout54.size() != 0 {
                        _rt::alloc::dealloc(result54.cast(), layout54);
                    }
                    if layout68.size() != 0 {
                        _rt::alloc::dealloc(result68.cast(), layout68);
                    }
                    for (ptr, layout) in cleanup_list {
                        if layout.size() != 0 {
                            _rt::alloc::dealloc(ptr.cast(), layout);
                        }
                    }
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            /// Returns the current span context of the host.
            pub fn current_span_context() -> SpanContext {
                unsafe {
                    #[cfg_attr(target_pointer_width = "64", repr(align(8)))]
                    #[cfg_attr(target_pointer_width = "32", repr(align(4)))]
                    struct RetArea(
                        [::core::mem::MaybeUninit<
                            u8,
                        >; 7 * ::core::mem::size_of::<*const u8>()],
                    );
                    let mut ret_area = RetArea(
                        [::core::mem::MaybeUninit::uninit(); 7
                            * ::core::mem::size_of::<*const u8>()],
                    );
                    let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "wasi:otel/tracing@0.2.0-draft")]
                    unsafe extern "C" {
                        #[link_name = "current-span-context"]
                        fn wit_import1(_: *mut u8);
                    }
                    #[cfg(not(target_arch = "wasm32"))]
                    unsafe extern "C" fn wit_import1(_: *mut u8) {
                        unreachable!()
                    }
                    unsafe { wit_import1(ptr0) };
                    let l2 = *ptr0.add(0).cast::<*mut u8>();
                    let l3 = *ptr0
                        .add(::core::mem::size_of::<*const u8>())
                        .cast::<usize>();
                    let len4 = l3;
                    let bytes4 = _rt::Vec::from_raw_parts(l2.cast(), len4, len4);
                    let l5 = *ptr0
                        .add(2 * ::core::mem::size_of::<*const u8>())
                        .cast::<*mut u8>();
                    let l6 = *ptr0
                        .add(3 * ::core::mem::size_of::<*const u8>())
                        .cast::<usize>();
                    let len7 = l6;
                    let bytes7 = _rt::Vec::from_raw_parts(l5.cast(), len7, len7);
                    let l8 = i32::from(
                        *ptr0.add(4 * ::core::mem::size_of::<*const u8>()).cast::<u8>(),
                    );
                    let l9 = i32::from(
                        *ptr0
                            .add(1 + 4 * ::core::mem::size_of::<*const u8>())
                            .cast::<u8>(),
                    );
                    let l10 = *ptr0
                        .add(5 * ::core::mem::size_of::<*const u8>())
                        .cast::<*mut u8>();
                    let l11 = *ptr0
                        .add(6 * ::core::mem::size_of::<*const u8>())
                        .cast::<usize>();
                    let base18 = l10;
                    let len18 = l11;
                    let mut result18 = _rt::Vec::with_capacity(len18);
                    for i in 0..len18 {
                        let base = base18
                            .add(i * (4 * ::core::mem::size_of::<*const u8>()));
                        let e18 = {
                            let l12 = *base.add(0).cast::<*mut u8>();
                            let l13 = *base
                                .add(::core::mem::size_of::<*const u8>())
                                .cast::<usize>();
                            let len14 = l13;
                            let bytes14 = _rt::Vec::from_raw_parts(
                                l12.cast(),
                                len14,
                                len14,
                            );
                            let l15 = *base
                                .add(2 * ::core::mem::size_of::<*const u8>())
                                .cast::<*mut u8>();
                            let l16 = *base
                                .add(3 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>();
                            let len17 = l16;
                            let bytes17 = _rt::Vec::from_raw_parts(
                                l15.cast(),
                                len17,
                                len17,
                            );
                            (_rt::string_lift(bytes14), _rt::string_lift(bytes17))
                        };
                        result18.push(e18);
                    }
                    _rt::cabi_dealloc(
                        base18,
                        len18 * (4 * ::core::mem::size_of::<*const u8>()),
                        ::core::mem::size_of::<*const u8>(),
                    );
                    let result19 = SpanContext {
                        trace_id: _rt::string_lift(bytes4),
                        span_id: _rt::string_lift(bytes7),
                        trace_flags: TraceFlags::empty()
                            | TraceFlags::from_bits_retain(((l8 as u8) << 0) as _),
                        is_remote: _rt::bool_lift(l9 as u8),
                        trace_state: result18,
                    };
                    result19
                }
            }
        }
    }
}
#[rustfmt::skip]
#[allow(dead_code, clippy::all)]
pub mod exports {
    pub mod wasmcp {
        pub mod otel_exporter {
            #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
            pub mod api {
                #[used]
                #[doc(hidden)]
                static __FORCE_SECTION_REF: fn() = super::super::super::super::__link_custom_section_describing_imports;
                use super::super::super::super::_rt;
                pub type SpanContext = super::super::super::super::wasi::otel::tracing::SpanContext;
                #[derive(Debug)]
                #[repr(transparent)]
                pub struct Span {
                    handle: _rt::Resource<Span>,
                }
                type _SpanRep<T> = Option<T>;
                impl Span {
                    /// Creates a new resource from the specified representation.
                    ///
                    /// This function will create a new resource handle by moving `val` onto
                    /// the heap and then passing that heap pointer to the component model to
                    /// create a handle. The owned handle is then returned as `Span`.
                    pub fn new<T: GuestSpan>(val: T) -> Self {
                        Self::type_guard::<T>();
                        let val: _SpanRep<T> = Some(val);
                        let ptr: *mut _SpanRep<T> = _rt::Box::into_raw(
                            _rt::Box::new(val),
                        );
                        unsafe { Self::from_handle(T::_resource_new(ptr.cast())) }
                    }
                    /// Gets access to the underlying `T` which represents this resource.
                    pub fn get<T: GuestSpan>(&self) -> &T {
                        let ptr = unsafe { &*self.as_ptr::<T>() };
                        ptr.as_ref().unwrap()
                    }
                    /// Gets mutable access to the underlying `T` which represents this
                    /// resource.
                    pub fn get_mut<T: GuestSpan>(&mut self) -> &mut T {
                        let ptr = unsafe { &mut *self.as_ptr::<T>() };
                        ptr.as_mut().unwrap()
                    }
                    /// Consumes this resource and returns the underlying `T`.
                    pub fn into_inner<T: GuestSpan>(self) -> T {
                        let ptr = unsafe { &mut *self.as_ptr::<T>() };
                        ptr.take().unwrap()
                    }
                    #[doc(hidden)]
                    pub unsafe fn from_handle(handle: u32) -> Self {
                        Self {
                            handle: unsafe { _rt::Resource::from_handle(handle) },
                        }
                    }
                    #[doc(hidden)]
                    pub fn take_handle(&self) -> u32 {
                        _rt::Resource::take_handle(&self.handle)
                    }
                    #[doc(hidden)]
                    pub fn handle(&self) -> u32 {
                        _rt::Resource::handle(&self.handle)
                    }
                    #[doc(hidden)]
                    fn type_guard<T: 'static>() {
                        use core::any::TypeId;
                        static mut LAST_TYPE: Option<TypeId> = None;
                        unsafe {
                            assert!(! cfg!(target_feature = "atomics"));
                            let id = TypeId::of::<T>();
                            match LAST_TYPE {
                                Some(ty) => {
                                    assert!(
                                        ty == id, "cannot use two types with this resource type"
                                    )
                                }
                                None => LAST_TYPE = Some(id),
                            }
                        }
                    }
                    #[doc(hidden)]
                    pub unsafe fn dtor<T: 'static>(handle: *mut u8) {
                        Self::type_guard::<T>();
                        let _ = unsafe {
                            _rt::Box::from_raw(handle as *mut _SpanRep<T>)
                        };
                    }
                    fn as_ptr<T: GuestSpan>(&self) -> *mut _SpanRep<T> {
                        Span::type_guard::<T>();
                        T::_resource_rep(self.handle()).cast()
                    }
                }
                /// A borrowed version of [`Span`] which represents a borrowed value
                /// with the lifetime `'a`.
                #[derive(Debug)]
                #[repr(transparent)]
                pub struct SpanBorrow<'a> {
                    rep: *mut u8,
                    _marker: core::marker::PhantomData<&'a Span>,
                }
                impl<'a> SpanBorrow<'a> {
                    #[doc(hidden)]
                    pub unsafe fn lift(rep: usize) -> Self {
                        Self {
                            rep: rep as *mut u8,
                            _marker: core::marker::PhantomData,
                        }
                    }
                    /// Gets access to the underlying `T` in this resource.
                    pub fn get<T: GuestSpan>(&self) -> &T {
                        let ptr = unsafe { &mut *self.as_ptr::<T>() };
                        ptr.as_ref().unwrap()
                    }
                    fn as_ptr<T: 'static>(&self) -> *mut _SpanRep<T> {
                        Span::type_guard::<T>();
                        self.rep.cast()
                    }
                }
                unsafe impl _rt::WasmResource for Span {
                    #[inline]
                    unsafe fn drop(_handle: u32) {
                        #[cfg(not(target_arch = "wasm32"))]
                        unreachable!();
                        #[cfg(target_arch = "wasm32")]
                        {
                            #[link(
                                wasm_import_module = "[export]wasmcp:otel-exporter/api@0.1.0"
                            )]
                            unsafe extern "C" {
                                #[link_name = "[resource-drop]span"]
                                fn drop(_: u32);
                            }
                            unsafe { drop(_handle) };
                        }
                    }
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_constructor_span_cabi<T: GuestSpan>(
                    arg0: *mut u8,
                    arg1: usize,
                    arg2: i32,
                    arg3: *mut u8,
                    arg4: usize,
                    arg5: *mut u8,
                    arg6: usize,
                    arg7: i32,
                    arg8: i32,
                    arg9: *mut u8,
                    arg10: usize,
                ) -> i32 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let len0 = arg1;
                    let bytes0 = _rt::Vec::from_raw_parts(arg0.cast(), len0, len0);
                    let result10 = Span::new(
                        T::new(
                            _rt::string_lift(bytes0),
                            match arg2 {
                                0 => None,
                                1 => {
                                    let e = {
                                        let len1 = arg4;
                                        let bytes1 = _rt::Vec::from_raw_parts(
                                            arg3.cast(),
                                            len1,
                                            len1,
                                        );
                                        let len2 = arg6;
                                        let bytes2 = _rt::Vec::from_raw_parts(
                                            arg5.cast(),
                                            len2,
                                            len2,
                                        );
                                        let base9 = arg9;
                                        let len9 = arg10;
                                        let mut result9 = _rt::Vec::with_capacity(len9);
                                        for i in 0..len9 {
                                            let base = base9
                                                .add(i * (4 * ::core::mem::size_of::<*const u8>()));
                                            let e9 = {
                                                let l3 = *base.add(0).cast::<*mut u8>();
                                                let l4 = *base
                                                    .add(::core::mem::size_of::<*const u8>())
                                                    .cast::<usize>();
                                                let len5 = l4;
                                                let bytes5 = _rt::Vec::from_raw_parts(
                                                    l3.cast(),
                                                    len5,
                                                    len5,
                                                );
                                                let l6 = *base
                                                    .add(2 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<*mut u8>();
                                                let l7 = *base
                                                    .add(3 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<usize>();
                                                let len8 = l7;
                                                let bytes8 = _rt::Vec::from_raw_parts(
                                                    l6.cast(),
                                                    len8,
                                                    len8,
                                                );
                                                (_rt::string_lift(bytes5), _rt::string_lift(bytes8))
                                            };
                                            result9.push(e9);
                                        }
                                        _rt::cabi_dealloc(
                                            base9,
                                            len9 * (4 * ::core::mem::size_of::<*const u8>()),
                                            ::core::mem::size_of::<*const u8>(),
                                        );
                                        super::super::super::super::wasi::otel::tracing::SpanContext {
                                            trace_id: _rt::string_lift(bytes1),
                                            span_id: _rt::string_lift(bytes2),
                                            trace_flags: super::super::super::super::wasi::otel::tracing::TraceFlags::empty()
                                                | super::super::super::super::wasi::otel::tracing::TraceFlags::from_bits_retain(
                                                    ((arg7 as u8) << 0) as _,
                                                ),
                                            is_remote: _rt::bool_lift(arg8 as u8),
                                            trace_state: result9,
                                        }
                                    };
                                    Some(e)
                                }
                                _ => _rt::invalid_enum_discriminant(),
                            },
                        ),
                    );
                    (result10).take_handle() as i32
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_method_span_add_event_cabi<T: GuestSpan>(
                    arg0: *mut u8,
                    arg1: *mut u8,
                    arg2: usize,
                ) {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let len0 = arg2;
                    let bytes0 = _rt::Vec::from_raw_parts(arg1.cast(), len0, len0);
                    T::add_event(
                        unsafe { SpanBorrow::lift(arg0 as u32 as usize) }.get(),
                        _rt::string_lift(bytes0),
                    );
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_method_span_finish_cabi<T: GuestSpan>(
                    arg0: *mut u8,
                ) {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    T::finish(unsafe { SpanBorrow::lift(arg0 as u32 as usize) }.get());
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_get_context_cabi<T: Guest>(arg0: i32) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let result0 = T::get_context(unsafe {
                        SpanBorrow::lift(arg0 as u32 as usize)
                    });
                    let ptr1 = (&raw mut _RET_AREA.0).cast::<u8>();
                    let super::super::super::super::wasi::otel::tracing::SpanContext {
                        trace_id: trace_id2,
                        span_id: span_id2,
                        trace_flags: trace_flags2,
                        is_remote: is_remote2,
                        trace_state: trace_state2,
                    } = result0;
                    let vec3 = (trace_id2.into_bytes()).into_boxed_slice();
                    let ptr3 = vec3.as_ptr().cast::<u8>();
                    let len3 = vec3.len();
                    ::core::mem::forget(vec3);
                    *ptr1.add(::core::mem::size_of::<*const u8>()).cast::<usize>() = len3;
                    *ptr1.add(0).cast::<*mut u8>() = ptr3.cast_mut();
                    let vec4 = (span_id2.into_bytes()).into_boxed_slice();
                    let ptr4 = vec4.as_ptr().cast::<u8>();
                    let len4 = vec4.len();
                    ::core::mem::forget(vec4);
                    *ptr1.add(3 * ::core::mem::size_of::<*const u8>()).cast::<usize>() = len4;
                    *ptr1
                        .add(2 * ::core::mem::size_of::<*const u8>())
                        .cast::<*mut u8>() = ptr4.cast_mut();
                    let flags5 = trace_flags2;
                    *ptr1.add(4 * ::core::mem::size_of::<*const u8>()).cast::<u8>() = ((flags5
                        .bits() >> 0) as i32) as u8;
                    *ptr1
                        .add(1 + 4 * ::core::mem::size_of::<*const u8>())
                        .cast::<u8>() = (match is_remote2 {
                        true => 1,
                        false => 0,
                    }) as u8;
                    let vec9 = trace_state2;
                    let len9 = vec9.len();
                    let layout9 = _rt::alloc::Layout::from_size_align_unchecked(
                        vec9.len() * (4 * ::core::mem::size_of::<*const u8>()),
                        ::core::mem::size_of::<*const u8>(),
                    );
                    let result9 = if layout9.size() != 0 {
                        let ptr = _rt::alloc::alloc(layout9).cast::<u8>();
                        if ptr.is_null() {
                            _rt::alloc::handle_alloc_error(layout9);
                        }
                        ptr
                    } else {
                        ::core::ptr::null_mut()
                    };
                    for (i, e) in vec9.into_iter().enumerate() {
                        let base = result9
                            .add(i * (4 * ::core::mem::size_of::<*const u8>()));
                        {
                            let (t6_0, t6_1) = e;
                            let vec7 = (t6_0.into_bytes()).into_boxed_slice();
                            let ptr7 = vec7.as_ptr().cast::<u8>();
                            let len7 = vec7.len();
                            ::core::mem::forget(vec7);
                            *base
                                .add(::core::mem::size_of::<*const u8>())
                                .cast::<usize>() = len7;
                            *base.add(0).cast::<*mut u8>() = ptr7.cast_mut();
                            let vec8 = (t6_1.into_bytes()).into_boxed_slice();
                            let ptr8 = vec8.as_ptr().cast::<u8>();
                            let len8 = vec8.len();
                            ::core::mem::forget(vec8);
                            *base
                                .add(3 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>() = len8;
                            *base
                                .add(2 * ::core::mem::size_of::<*const u8>())
                                .cast::<*mut u8>() = ptr8.cast_mut();
                        }
                    }
                    *ptr1.add(6 * ::core::mem::size_of::<*const u8>()).cast::<usize>() = len9;
                    *ptr1
                        .add(5 * ::core::mem::size_of::<*const u8>())
                        .cast::<*mut u8>() = result9;
                    ptr1
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn __post_return_get_context<T: Guest>(arg0: *mut u8) {
                    let l0 = *arg0.add(0).cast::<*mut u8>();
                    let l1 = *arg0
                        .add(::core::mem::size_of::<*const u8>())
                        .cast::<usize>();
                    _rt::cabi_dealloc(l0, l1, 1);
                    let l2 = *arg0
                        .add(2 * ::core::mem::size_of::<*const u8>())
                        .cast::<*mut u8>();
                    let l3 = *arg0
                        .add(3 * ::core::mem::size_of::<*const u8>())
                        .cast::<usize>();
                    _rt::cabi_dealloc(l2, l3, 1);
                    let l4 = *arg0
                        .add(5 * ::core::mem::size_of::<*const u8>())
                        .cast::<*mut u8>();
                    let l5 = *arg0
                        .add(6 * ::core::mem::size_of::<*const u8>())
                        .cast::<usize>();
                    let base10 = l4;
                    let len10 = l5;
                    for i in 0..len10 {
                        let base = base10
                            .add(i * (4 * ::core::mem::size_of::<*const u8>()));
                        {
                            let l6 = *base.add(0).cast::<*mut u8>();
                            let l7 = *base
                                .add(::core::mem::size_of::<*const u8>())
                                .cast::<usize>();
                            _rt::cabi_dealloc(l6, l7, 1);
                            let l8 = *base
                                .add(2 * ::core::mem::size_of::<*const u8>())
                                .cast::<*mut u8>();
                            let l9 = *base
                                .add(3 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>();
                            _rt::cabi_dealloc(l8, l9, 1);
                        }
                    }
                    _rt::cabi_dealloc(
                        base10,
                        len10 * (4 * ::core::mem::size_of::<*const u8>()),
                        ::core::mem::size_of::<*const u8>(),
                    );
                }
                pub trait Guest {
                    type Span: GuestSpan;
                    fn get_context(s: SpanBorrow<'_>) -> SpanContext;
                }
                pub trait GuestSpan: 'static {
                    #[doc(hidden)]
                    unsafe fn _resource_new(val: *mut u8) -> u32
                    where
                        Self: Sized,
                    {
                        #[cfg(not(target_arch = "wasm32"))]
                        {
                            let _ = val;
                            unreachable!();
                        }
                        #[cfg(target_arch = "wasm32")]
                        {
                            #[link(
                                wasm_import_module = "[export]wasmcp:otel-exporter/api@0.1.0"
                            )]
                            unsafe extern "C" {
                                #[link_name = "[resource-new]span"]
                                fn new(_: *mut u8) -> u32;
                            }
                            unsafe { new(val) }
                        }
                    }
                    #[doc(hidden)]
                    fn _resource_rep(handle: u32) -> *mut u8
                    where
                        Self: Sized,
                    {
                        #[cfg(not(target_arch = "wasm32"))]
                        {
                            let _ = handle;
                            unreachable!();
                        }
                        #[cfg(target_arch = "wasm32")]
                        {
                            #[link(
                                wasm_import_module = "[export]wasmcp:otel-exporter/api@0.1.0"
                            )]
                            unsafe extern "C" {
                                #[link_name = "[resource-rep]span"]
                                fn rep(_: u32) -> *mut u8;
                            }
                            unsafe { rep(handle) }
                        }
                    }
                    fn new(
                        name: _rt::String,
                        parent_context: Option<SpanContext>,
                    ) -> Self;
                    fn add_event(&self, name: _rt::String) -> ();
                    fn finish(&self) -> ();
                }
                #[doc(hidden)]
                macro_rules! __export_wasmcp_otel_exporter_api_0_1_0_cabi {
                    ($ty:ident with_types_in $($path_to_types:tt)*) => {
                        const _ : () = { #[unsafe (export_name =
                        "wasmcp:otel-exporter/api@0.1.0#[constructor]span")] unsafe
                        extern "C" fn export_constructor_span(arg0 : * mut u8, arg1 :
                        usize, arg2 : i32, arg3 : * mut u8, arg4 : usize, arg5 : * mut
                        u8, arg6 : usize, arg7 : i32, arg8 : i32, arg9 : * mut u8, arg10
                        : usize,) -> i32 { unsafe { $($path_to_types)*::
                        _export_constructor_span_cabi::<<$ty as $($path_to_types)*::
                        Guest >::Span > (arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7,
                        arg8, arg9, arg10) } } #[unsafe (export_name =
                        "wasmcp:otel-exporter/api@0.1.0#[method]span.add-event")] unsafe
                        extern "C" fn export_method_span_add_event(arg0 : * mut u8, arg1
                        : * mut u8, arg2 : usize,) { unsafe { $($path_to_types)*::
                        _export_method_span_add_event_cabi::<<$ty as $($path_to_types)*::
                        Guest >::Span > (arg0, arg1, arg2) } } #[unsafe (export_name =
                        "wasmcp:otel-exporter/api@0.1.0#[method]span.finish")] unsafe
                        extern "C" fn export_method_span_finish(arg0 : * mut u8,) {
                        unsafe { $($path_to_types)*::
                        _export_method_span_finish_cabi::<<$ty as $($path_to_types)*::
                        Guest >::Span > (arg0) } } #[unsafe (export_name =
                        "wasmcp:otel-exporter/api@0.1.0#get-context")] unsafe extern "C"
                        fn export_get_context(arg0 : i32,) -> * mut u8 { unsafe {
                        $($path_to_types)*:: _export_get_context_cabi::<$ty > (arg0) } }
                        #[unsafe (export_name =
                        "cabi_post_wasmcp:otel-exporter/api@0.1.0#get-context")] unsafe
                        extern "C" fn _post_return_get_context(arg0 : * mut u8,) { unsafe
                        { $($path_to_types)*:: __post_return_get_context::<$ty > (arg0) }
                        } const _ : () = { #[doc(hidden)] #[unsafe (export_name =
                        "wasmcp:otel-exporter/api@0.1.0#[dtor]span")]
                        #[allow(non_snake_case)] unsafe extern "C" fn dtor(rep : * mut
                        u8) { unsafe { $($path_to_types)*:: Span::dtor::< <$ty as
                        $($path_to_types)*:: Guest >::Span > (rep) } } }; };
                    };
                }
                #[doc(hidden)]
                pub(crate) use __export_wasmcp_otel_exporter_api_0_1_0_cabi;
                #[cfg_attr(target_pointer_width = "64", repr(align(8)))]
                #[cfg_attr(target_pointer_width = "32", repr(align(4)))]
                struct _RetArea(
                    [::core::mem::MaybeUninit<
                        u8,
                    >; 7 * ::core::mem::size_of::<*const u8>()],
                );
                static mut _RET_AREA: _RetArea = _RetArea(
                    [::core::mem::MaybeUninit::uninit(); 7
                        * ::core::mem::size_of::<*const u8>()],
                );
            }
        }
    }
}
#[rustfmt::skip]
mod _rt {
    #![allow(dead_code, clippy::all)]
    pub use alloc_crate::string::String;
    pub use alloc_crate::vec::Vec;
    pub use alloc_crate::alloc;
    pub fn as_i64<T: AsI64>(t: T) -> i64 {
        t.as_i64()
    }
    pub trait AsI64 {
        fn as_i64(self) -> i64;
    }
    impl<'a, T: Copy + AsI64> AsI64 for &'a T {
        fn as_i64(self) -> i64 {
            (*self).as_i64()
        }
    }
    impl AsI64 for i64 {
        #[inline]
        fn as_i64(self) -> i64 {
            self as i64
        }
    }
    impl AsI64 for u64 {
        #[inline]
        fn as_i64(self) -> i64 {
            self as i64
        }
    }
    pub fn as_i32<T: AsI32>(t: T) -> i32 {
        t.as_i32()
    }
    pub trait AsI32 {
        fn as_i32(self) -> i32;
    }
    impl<'a, T: Copy + AsI32> AsI32 for &'a T {
        fn as_i32(self) -> i32 {
            (*self).as_i32()
        }
    }
    impl AsI32 for i32 {
        #[inline]
        fn as_i32(self) -> i32 {
            self as i32
        }
    }
    impl AsI32 for u32 {
        #[inline]
        fn as_i32(self) -> i32 {
            self as i32
        }
    }
    impl AsI32 for i16 {
        #[inline]
        fn as_i32(self) -> i32 {
            self as i32
        }
    }
    impl AsI32 for u16 {
        #[inline]
        fn as_i32(self) -> i32 {
            self as i32
        }
    }
    impl AsI32 for i8 {
        #[inline]
        fn as_i32(self) -> i32 {
            self as i32
        }
    }
    impl AsI32 for u8 {
        #[inline]
        fn as_i32(self) -> i32 {
            self as i32
        }
    }
    impl AsI32 for char {
        #[inline]
        fn as_i32(self) -> i32 {
            self as i32
        }
    }
    impl AsI32 for usize {
        #[inline]
        fn as_i32(self) -> i32 {
            self as i32
        }
    }
    pub fn as_f64<T: AsF64>(t: T) -> f64 {
        t.as_f64()
    }
    pub trait AsF64 {
        fn as_f64(self) -> f64;
    }
    impl<'a, T: Copy + AsF64> AsF64 for &'a T {
        fn as_f64(self) -> f64 {
            (*self).as_f64()
        }
    }
    impl AsF64 for f64 {
        #[inline]
        fn as_f64(self) -> f64 {
            self as f64
        }
    }
    pub unsafe fn string_lift(bytes: Vec<u8>) -> String {
        if cfg!(debug_assertions) {
            String::from_utf8(bytes).unwrap()
        } else {
            String::from_utf8_unchecked(bytes)
        }
    }
    pub unsafe fn bool_lift(val: u8) -> bool {
        if cfg!(debug_assertions) {
            match val {
                0 => false,
                1 => true,
                _ => panic!("invalid bool discriminant"),
            }
        } else {
            val != 0
        }
    }
    pub unsafe fn cabi_dealloc(ptr: *mut u8, size: usize, align: usize) {
        if size == 0 {
            return;
        }
        let layout = alloc::Layout::from_size_align_unchecked(size, align);
        alloc::dealloc(ptr, layout);
    }
    use core::fmt;
    use core::marker;
    use core::sync::atomic::{AtomicU32, Ordering::Relaxed};
    /// A type which represents a component model resource, either imported or
    /// exported into this component.
    ///
    /// This is a low-level wrapper which handles the lifetime of the resource
    /// (namely this has a destructor). The `T` provided defines the component model
    /// intrinsics that this wrapper uses.
    ///
    /// One of the chief purposes of this type is to provide `Deref` implementations
    /// to access the underlying data when it is owned.
    ///
    /// This type is primarily used in generated code for exported and imported
    /// resources.
    #[repr(transparent)]
    pub struct Resource<T: WasmResource> {
        handle: AtomicU32,
        _marker: marker::PhantomData<T>,
    }
    /// A trait which all wasm resources implement, namely providing the ability to
    /// drop a resource.
    ///
    /// This generally is implemented by generated code, not user-facing code.
    #[allow(clippy::missing_safety_doc)]
    pub unsafe trait WasmResource {
        /// Invokes the `[resource-drop]...` intrinsic.
        unsafe fn drop(handle: u32);
    }
    impl<T: WasmResource> Resource<T> {
        #[doc(hidden)]
        pub unsafe fn from_handle(handle: u32) -> Self {
            debug_assert!(handle != u32::MAX);
            Self {
                handle: AtomicU32::new(handle),
                _marker: marker::PhantomData,
            }
        }
        /// Takes ownership of the handle owned by `resource`.
        ///
        /// Note that this ideally would be `into_handle` taking `Resource<T>` by
        /// ownership. The code generator does not enable that in all situations,
        /// unfortunately, so this is provided instead.
        ///
        /// Also note that `take_handle` is in theory only ever called on values
        /// owned by a generated function. For example a generated function might
        /// take `Resource<T>` as an argument but then call `take_handle` on a
        /// reference to that argument. In that sense the dynamic nature of
        /// `take_handle` should only be exposed internally to generated code, not
        /// to user code.
        #[doc(hidden)]
        pub fn take_handle(resource: &Resource<T>) -> u32 {
            resource.handle.swap(u32::MAX, Relaxed)
        }
        #[doc(hidden)]
        pub fn handle(resource: &Resource<T>) -> u32 {
            resource.handle.load(Relaxed)
        }
    }
    impl<T: WasmResource> fmt::Debug for Resource<T> {
        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
            f.debug_struct("Resource").field("handle", &self.handle).finish()
        }
    }
    impl<T: WasmResource> Drop for Resource<T> {
        fn drop(&mut self) {
            unsafe {
                match self.handle.load(Relaxed) {
                    u32::MAX => {}
                    other => T::drop(other),
                }
            }
        }
    }
    pub use alloc_crate::boxed::Box;
    #[cfg(target_arch = "wasm32")]
    pub fn run_ctors_once() {
        wit_bindgen_rt::run_ctors_once();
    }
    pub unsafe fn invalid_enum_discriminant<T>() -> T {
        if cfg!(debug_assertions) {
            panic!("invalid enum discriminant")
        } else {
            unsafe { core::hint::unreachable_unchecked() }
        }
    }
    extern crate alloc as alloc_crate;
}
/// Generates `#[unsafe(no_mangle)]` functions to export the specified type as
/// the root implementation of all generated traits.
///
/// For more information see the documentation of `wit_bindgen::generate!`.
///
/// ```rust
/// # macro_rules! export{ ($($t:tt)*) => (); }
/// # trait Guest {}
/// struct MyType;
///
/// impl Guest for MyType {
///     // ...
/// }
///
/// export!(MyType);
/// ```
#[allow(unused_macros)]
#[doc(hidden)]
macro_rules! __export_otel_exporter_impl {
    ($ty:ident) => {
        self::export!($ty with_types_in self);
    };
    ($ty:ident with_types_in $($path_to_types_root:tt)*) => {
        $($path_to_types_root)*::
        exports::wasmcp::otel_exporter::api::__export_wasmcp_otel_exporter_api_0_1_0_cabi!($ty
        with_types_in $($path_to_types_root)*:: exports::wasmcp::otel_exporter::api);
    };
}
#[doc(inline)]
pub(crate) use __export_otel_exporter_impl as export;
#[cfg(target_arch = "wasm32")]
#[unsafe(
    link_section = "component-type:wit-bindgen:0.41.0:wasmcp:otel-exporter@0.1.0:otel-exporter:encoded world"
)]
#[doc(hidden)]
#[allow(clippy::octal_escapes)]
pub static __WIT_BINDGEN_COMPONENT_TYPE: [u8; 1453] = *b"\
\0asm\x0d\0\x01\0\0\x19\x16wit-component-encoding\x04\0\x07\xa9\x0a\x01A\x02\x01\
A\x08\x01B\x05\x01r\x02\x07secondsw\x0bnanosecondsy\x04\0\x08datetime\x03\0\0\x01\
@\0\0\x01\x04\0\x03now\x01\x02\x04\0\x0aresolution\x01\x02\x03\0\x1cwasi:clocks/\
wall-clock@0.2.0\x05\0\x02\x03\0\0\x08datetime\x01B-\x02\x03\x02\x01\x01\x04\0\x08\
datetime\x03\0\0\x01s\x04\0\x08trace-id\x03\0\x02\x01s\x04\0\x07span-id\x03\0\x04\
\x01n\x01\x07sampled\x04\0\x0btrace-flags\x03\0\x06\x01o\x02ss\x01p\x08\x04\0\x0b\
trace-state\x03\0\x09\x01r\x05\x08trace-id\x03\x07span-id\x05\x0btrace-flags\x07\
\x09is-remote\x7f\x0btrace-state\x0a\x04\0\x0cspan-context\x03\0\x0b\x01m\x05\x06\
client\x06server\x08producer\x08consumer\x08internal\x04\0\x09span-kind\x03\0\x0d\
\x01s\x04\0\x03key\x03\0\x0f\x01ps\x01p\x7f\x01pu\x01px\x01q\x08\x06string\x01s\0\
\x04bool\x01\x7f\0\x03f64\x01u\0\x03s64\x01x\0\x0cstring-array\x01\x11\0\x0abool\
-array\x01\x12\0\x09f64-array\x01\x13\0\x09s64-array\x01\x14\0\x04\0\x05value\x03\
\0\x15\x01r\x02\x03key\x10\x05value\x16\x04\0\x09key-value\x03\0\x17\x01p\x18\x01\
r\x03\x04names\x04time\x01\x0aattributes\x19\x04\0\x05event\x03\0\x1a\x01r\x02\x0c\
span-context\x0c\x0aattributes\x19\x04\0\x04link\x03\0\x1c\x01q\x03\x05unset\0\0\
\x02ok\0\0\x05error\x01s\0\x04\0\x06status\x03\0\x1e\x01ks\x01r\x04\x04names\x07\
version\x20\x0aschema-url\x20\x0aattributes\x19\x04\0\x15instrumentation-scope\x03\
\0!\x01p\x1b\x01p\x1d\x01r\x0e\x0cspan-context\x0c\x0eparent-span-ids\x09span-ki\
nd\x0e\x04names\x0astart-time\x01\x08end-time\x01\x0aattributes\x19\x06events#\x05\
links$\x06status\x1f\x15instrumentation-scope\"\x12dropped-attributesy\x0edroppe\
d-eventsy\x0ddropped-linksy\x04\0\x09span-data\x03\0%\x01@\x02\x04span&\x06paren\
t\x0c\x01\0\x04\0\x08on-start\x01'\x01@\x01\x04span&\x01\0\x04\0\x06on-end\x01(\x01\
@\0\0\x0c\x04\0\x14current-span-context\x01)\x03\0\x1dwasi:otel/tracing@0.2.0-dr\
aft\x05\x02\x02\x03\0\x01\x0cspan-context\x01B\x0e\x02\x03\x02\x01\x03\x04\0\x0c\
span-context\x03\0\0\x04\0\x04span\x03\x01\x01k\x01\x01i\x02\x01@\x02\x04names\x0e\
parent-context\x03\0\x04\x04\0\x11[constructor]span\x01\x05\x01h\x02\x01@\x02\x04\
self\x06\x04names\x01\0\x04\0\x16[method]span.add-event\x01\x07\x01@\x01\x04self\
\x06\x01\0\x04\0\x13[method]span.finish\x01\x08\x01@\x01\x01s\x06\0\x01\x04\0\x0b\
get-context\x01\x09\x04\0\x1ewasmcp:otel-exporter/api@0.1.0\x05\x04\x04\0(wasmcp\
:otel-exporter/otel-exporter@0.1.0\x04\0\x0b\x13\x01\0\x0dotel-exporter\x03\0\0\0\
G\x09producers\x01\x0cprocessed-by\x02\x0dwit-component\x070.227.1\x10wit-bindge\
n-rust\x060.41.0";
#[inline(never)]
#[doc(hidden)]
pub fn __link_custom_section_describing_imports() {
    wit_bindgen_rt::maybe_link_cabi_realloc();
}
