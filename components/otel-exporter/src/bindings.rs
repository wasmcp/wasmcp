// Generated by `wit-bindgen` 0.41.0. DO NOT EDIT!
// Options used:
//   * runtime_path: "wit_bindgen_rt"
//   * additional derives ["Clone"]
#[rustfmt::skip]
#[allow(dead_code, clippy::all)]
pub mod wasi {
    pub mod clocks {
        /// WASI Wall Clock is a clock API intended to let users query the current
        /// time. The name "wall" makes an analogy to a "clock on the wall", which
        /// is not necessarily monotonic as it may be reset.
        ///
        /// It is intended to be portable at least between Unix-family platforms and
        /// Windows.
        ///
        /// A wall clock is a clock which measures the date and time according to
        /// some external reference.
        ///
        /// External references may be reset, so this clock is not necessarily
        /// monotonic, making it unsuitable for measuring elapsed time.
        ///
        /// It is intended for reporting the current date and time for humans.
        #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
        pub mod wall_clock {
            #[used]
            #[doc(hidden)]
            static __FORCE_SECTION_REF: fn() = super::super::super::__link_custom_section_describing_imports;
            /// A time and date in seconds plus nanoseconds.
            #[repr(C)]
            #[derive(Clone, Copy)]
            pub struct Datetime {
                pub seconds: u64,
                pub nanoseconds: u32,
            }
            impl ::core::fmt::Debug for Datetime {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("Datetime")
                        .field("seconds", &self.seconds)
                        .field("nanoseconds", &self.nanoseconds)
                        .finish()
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            /// Read the current value of the clock.
            ///
            /// This clock is not monotonic, therefore calling this function repeatedly
            /// will not necessarily produce a sequence of non-decreasing values.
            ///
            /// The returned timestamps represent the number of seconds since
            /// 1970-01-01T00:00:00Z, also known as [POSIX's Seconds Since the Epoch],
            /// also known as [Unix Time].
            ///
            /// The nanoseconds field of the output is always less than 1000000000.
            ///
            /// [POSIX's Seconds Since the Epoch]: https://pubs.opengroup.org/onlinepubs/9699919799/xrat/V4_xbd_chap04.html#tag_21_04_16
            /// [Unix Time]: https://en.wikipedia.org/wiki/Unix_time
            pub fn now() -> Datetime {
                unsafe {
                    #[repr(align(8))]
                    struct RetArea([::core::mem::MaybeUninit<u8>; 16]);
                    let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 16]);
                    let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "wasi:clocks/wall-clock@0.2.0")]
                    unsafe extern "C" {
                        #[link_name = "now"]
                        fn wit_import1(_: *mut u8);
                    }
                    #[cfg(not(target_arch = "wasm32"))]
                    unsafe extern "C" fn wit_import1(_: *mut u8) {
                        unreachable!()
                    }
                    unsafe { wit_import1(ptr0) };
                    let l2 = *ptr0.add(0).cast::<i64>();
                    let l3 = *ptr0.add(8).cast::<i32>();
                    let result4 = Datetime {
                        seconds: l2 as u64,
                        nanoseconds: l3 as u32,
                    };
                    result4
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            /// Query the resolution of the clock.
            ///
            /// The nanoseconds field of the output is always less than 1000000000.
            pub fn resolution() -> Datetime {
                unsafe {
                    #[repr(align(8))]
                    struct RetArea([::core::mem::MaybeUninit<u8>; 16]);
                    let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 16]);
                    let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "wasi:clocks/wall-clock@0.2.0")]
                    unsafe extern "C" {
                        #[link_name = "resolution"]
                        fn wit_import1(_: *mut u8);
                    }
                    #[cfg(not(target_arch = "wasm32"))]
                    unsafe extern "C" fn wit_import1(_: *mut u8) {
                        unreachable!()
                    }
                    unsafe { wit_import1(ptr0) };
                    let l2 = *ptr0.add(0).cast::<i64>();
                    let l3 = *ptr0.add(8).cast::<i32>();
                    let result4 = Datetime {
                        seconds: l2 as u64,
                        nanoseconds: l3 as u32,
                    };
                    result4
                }
            }
        }
    }
}
#[rustfmt::skip]
#[allow(dead_code, clippy::all)]
pub mod wasmcp {
    pub mod otel_exporter {
        #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
        pub mod otel_provider_config {
            #[used]
            #[doc(hidden)]
            static __FORCE_SECTION_REF: fn() = super::super::super::__link_custom_section_describing_imports;
            use super::super::super::_rt;
            #[repr(C)]
            #[derive(Clone, Copy)]
            pub struct JaegerThriftConfig {
                pub batch_size: Option<u32>,
                pub timeout_ms: Option<u32>,
            }
            impl ::core::fmt::Debug for JaegerThriftConfig {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("JaegerThriftConfig")
                        .field("batch-size", &self.batch_size)
                        .field("timeout-ms", &self.timeout_ms)
                        .finish()
                }
            }
            #[derive(Clone)]
            pub struct ZipkinJsonConfig {
                pub batch_size: Option<u32>,
                pub endpoint_path: _rt::String,
            }
            impl ::core::fmt::Debug for ZipkinJsonConfig {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("ZipkinJsonConfig")
                        .field("batch-size", &self.batch_size)
                        .field("endpoint-path", &self.endpoint_path)
                        .finish()
                }
            }
            #[repr(u8)]
            #[derive(Clone, Copy, Eq, Ord, PartialEq, PartialOrd)]
            pub enum CompressionType {
                Gzip,
                Deflate,
                None,
            }
            impl ::core::fmt::Debug for CompressionType {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    match self {
                        CompressionType::Gzip => {
                            f.debug_tuple("CompressionType::Gzip").finish()
                        }
                        CompressionType::Deflate => {
                            f.debug_tuple("CompressionType::Deflate").finish()
                        }
                        CompressionType::None => {
                            f.debug_tuple("CompressionType::None").finish()
                        }
                    }
                }
            }
            impl CompressionType {
                #[doc(hidden)]
                pub unsafe fn _lift(val: u8) -> CompressionType {
                    if !cfg!(debug_assertions) {
                        return ::core::mem::transmute(val);
                    }
                    match val {
                        0 => CompressionType::Gzip,
                        1 => CompressionType::Deflate,
                        2 => CompressionType::None,
                        _ => panic!("invalid enum discriminant"),
                    }
                }
            }
            #[derive(Clone)]
            pub struct OtlpHttpConfig {
                pub content_type: _rt::String,
                /// "application/x-protobuf" or "application/json"
                pub compression: Option<CompressionType>,
                pub timeout_ms: Option<u32>,
            }
            impl ::core::fmt::Debug for OtlpHttpConfig {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("OtlpHttpConfig")
                        .field("content-type", &self.content_type)
                        .field("compression", &self.compression)
                        .field("timeout-ms", &self.timeout_ms)
                        .finish()
                }
            }
            #[repr(C)]
            #[derive(Clone, Copy)]
            pub struct OtlpGrpcConfig {
                pub compression: Option<CompressionType>,
                pub timeout_ms: Option<u32>,
            }
            impl ::core::fmt::Debug for OtlpGrpcConfig {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("OtlpGrpcConfig")
                        .field("compression", &self.compression)
                        .field("timeout-ms", &self.timeout_ms)
                        .finish()
                }
            }
            /// Protocol variants for serialization/transport method
            #[derive(Clone)]
            pub enum OtelProtocol {
                OtlpHttp(OtlpHttpConfig),
                OtlpGrpc(OtlpGrpcConfig),
                JaegerThrift(JaegerThriftConfig),
                ZipkinJson(ZipkinJsonConfig),
            }
            impl ::core::fmt::Debug for OtelProtocol {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    match self {
                        OtelProtocol::OtlpHttp(e) => {
                            f.debug_tuple("OtelProtocol::OtlpHttp").field(e).finish()
                        }
                        OtelProtocol::OtlpGrpc(e) => {
                            f.debug_tuple("OtelProtocol::OtlpGrpc").field(e).finish()
                        }
                        OtelProtocol::JaegerThrift(e) => {
                            f.debug_tuple("OtelProtocol::JaegerThrift").field(e).finish()
                        }
                        OtelProtocol::ZipkinJson(e) => {
                            f.debug_tuple("OtelProtocol::ZipkinJson").field(e).finish()
                        }
                    }
                }
            }
            #[derive(Clone)]
            pub struct GrafanaConfig {
                pub endpoint: _rt::String,
                /// Base OTLP endpoint URL
                pub api_key: _rt::String,
                /// Grafana Cloud API key
                pub org_id: Option<_rt::String>,
                /// Optional organization ID
                pub service_name: _rt::String,
                /// Service identifier
                pub resource_attributes: _rt::Vec<(_rt::String, _rt::String)>,
            }
            impl ::core::fmt::Debug for GrafanaConfig {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("GrafanaConfig")
                        .field("endpoint", &self.endpoint)
                        .field("api-key", &self.api_key)
                        .field("org-id", &self.org_id)
                        .field("service-name", &self.service_name)
                        .field("resource-attributes", &self.resource_attributes)
                        .finish()
                }
            }
            #[derive(Clone)]
            pub struct JaegerConfig {
                pub endpoint: _rt::String,
                /// Jaeger collector endpoint
                pub username: Option<_rt::String>,
                /// Optional basic auth
                pub password: Option<_rt::String>,
                pub service_name: _rt::String,
                pub resource_attributes: _rt::Vec<(_rt::String, _rt::String)>,
            }
            impl ::core::fmt::Debug for JaegerConfig {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("JaegerConfig")
                        .field("endpoint", &self.endpoint)
                        .field("username", &self.username)
                        .field("password", &self.password)
                        .field("service-name", &self.service_name)
                        .field("resource-attributes", &self.resource_attributes)
                        .finish()
                }
            }
            #[derive(Clone)]
            pub struct DatadogConfig {
                pub site: _rt::String,
                /// e.g., "datadoghq.com", "datadoghq.eu"
                pub api_key: _rt::String,
                /// Datadog API key
                pub service_name: _rt::String,
                pub environment: Option<_rt::String>,
                /// e.g., "production", "staging"
                pub version: Option<_rt::String>,
                /// Service version
                pub resource_attributes: _rt::Vec<(_rt::String, _rt::String)>,
            }
            impl ::core::fmt::Debug for DatadogConfig {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("DatadogConfig")
                        .field("site", &self.site)
                        .field("api-key", &self.api_key)
                        .field("service-name", &self.service_name)
                        .field("environment", &self.environment)
                        .field("version", &self.version)
                        .field("resource-attributes", &self.resource_attributes)
                        .finish()
                }
            }
            #[derive(Clone)]
            pub struct HoneycombConfig {
                pub endpoint: _rt::String,
                /// Usually "https://api.honeycomb.io"
                pub api_key: _rt::String,
                /// Honeycomb API key
                pub dataset: _rt::String,
                /// Honeycomb dataset name
                pub service_name: _rt::String,
                pub resource_attributes: _rt::Vec<(_rt::String, _rt::String)>,
            }
            impl ::core::fmt::Debug for HoneycombConfig {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("HoneycombConfig")
                        .field("endpoint", &self.endpoint)
                        .field("api-key", &self.api_key)
                        .field("dataset", &self.dataset)
                        .field("service-name", &self.service_name)
                        .field("resource-attributes", &self.resource_attributes)
                        .finish()
                }
            }
            #[derive(Clone)]
            pub struct NewrelicConfig {
                pub endpoint: _rt::String,
                /// Usually "https://otlp.nr-data.net"
                pub api_key: _rt::String,
                /// New Relic license key
                pub service_name: _rt::String,
                pub resource_attributes: _rt::Vec<(_rt::String, _rt::String)>,
            }
            impl ::core::fmt::Debug for NewrelicConfig {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("NewrelicConfig")
                        .field("endpoint", &self.endpoint)
                        .field("api-key", &self.api_key)
                        .field("service-name", &self.service_name)
                        .field("resource-attributes", &self.resource_attributes)
                        .finish()
                }
            }
            #[derive(Clone)]
            pub struct GenericOtlpConfig {
                pub endpoint: _rt::String,
                /// Any OTLP-compatible endpoint
                pub headers: _rt::Vec<(_rt::String, _rt::String)>,
                /// Custom auth headers
                pub service_name: _rt::String,
                pub resource_attributes: _rt::Vec<(_rt::String, _rt::String)>,
            }
            impl ::core::fmt::Debug for GenericOtlpConfig {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("GenericOtlpConfig")
                        .field("endpoint", &self.endpoint)
                        .field("headers", &self.headers)
                        .field("service-name", &self.service_name)
                        .field("resource-attributes", &self.resource_attributes)
                        .finish()
                }
            }
            /// Provider variants for endpoint/auth specifics
            #[derive(Clone)]
            pub enum OtelProvider {
                Grafana(GrafanaConfig),
                Jaeger(JaegerConfig),
                Datadog(DatadogConfig),
                Honeycomb(HoneycombConfig),
                Newrelic(NewrelicConfig),
                GenericOtlp(GenericOtlpConfig),
            }
            impl ::core::fmt::Debug for OtelProvider {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    match self {
                        OtelProvider::Grafana(e) => {
                            f.debug_tuple("OtelProvider::Grafana").field(e).finish()
                        }
                        OtelProvider::Jaeger(e) => {
                            f.debug_tuple("OtelProvider::Jaeger").field(e).finish()
                        }
                        OtelProvider::Datadog(e) => {
                            f.debug_tuple("OtelProvider::Datadog").field(e).finish()
                        }
                        OtelProvider::Honeycomb(e) => {
                            f.debug_tuple("OtelProvider::Honeycomb").field(e).finish()
                        }
                        OtelProvider::Newrelic(e) => {
                            f.debug_tuple("OtelProvider::Newrelic").field(e).finish()
                        }
                        OtelProvider::GenericOtlp(e) => {
                            f.debug_tuple("OtelProvider::GenericOtlp").field(e).finish()
                        }
                    }
                }
            }
            #[derive(Clone)]
            pub struct OtelConfig {
                pub provider: OtelProvider,
                pub protocol: OtelProtocol,
            }
            impl ::core::fmt::Debug for OtelConfig {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("OtelConfig")
                        .field("provider", &self.provider)
                        .field("protocol", &self.protocol)
                        .finish()
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            pub fn get_otel_config() -> OtelConfig {
                unsafe {
                    #[cfg_attr(target_pointer_width = "64", repr(align(8)))]
                    #[cfg_attr(target_pointer_width = "32", repr(align(4)))]
                    struct RetArea(
                        [::core::mem::MaybeUninit<
                            u8,
                        >; 8 + 19 * ::core::mem::size_of::<*const u8>()],
                    );
                    let mut ret_area = RetArea(
                        [::core::mem::MaybeUninit::uninit(); 8
                            + 19 * ::core::mem::size_of::<*const u8>()],
                    );
                    let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                    #[cfg(target_arch = "wasm32")]
                    #[link(
                        wasm_import_module = "wasmcp:otel-exporter/otel-provider-config@0.1.0"
                    )]
                    unsafe extern "C" {
                        #[link_name = "get-otel-config"]
                        fn wit_import1(_: *mut u8);
                    }
                    #[cfg(not(target_arch = "wasm32"))]
                    unsafe extern "C" fn wit_import1(_: *mut u8) {
                        unreachable!()
                    }
                    unsafe { wit_import1(ptr0) };
                    let l2 = i32::from(*ptr0.add(0).cast::<u8>());
                    let v137 = match l2 {
                        0 => {
                            let e137 = {
                                let l3 = *ptr0
                                    .add(::core::mem::size_of::<*const u8>())
                                    .cast::<*mut u8>();
                                let l4 = *ptr0
                                    .add(2 * ::core::mem::size_of::<*const u8>())
                                    .cast::<usize>();
                                let len5 = l4;
                                let bytes5 = _rt::Vec::from_raw_parts(
                                    l3.cast(),
                                    len5,
                                    len5,
                                );
                                let l6 = *ptr0
                                    .add(3 * ::core::mem::size_of::<*const u8>())
                                    .cast::<*mut u8>();
                                let l7 = *ptr0
                                    .add(4 * ::core::mem::size_of::<*const u8>())
                                    .cast::<usize>();
                                let len8 = l7;
                                let bytes8 = _rt::Vec::from_raw_parts(
                                    l6.cast(),
                                    len8,
                                    len8,
                                );
                                let l9 = i32::from(
                                    *ptr0
                                        .add(5 * ::core::mem::size_of::<*const u8>())
                                        .cast::<u8>(),
                                );
                                let l13 = *ptr0
                                    .add(8 * ::core::mem::size_of::<*const u8>())
                                    .cast::<*mut u8>();
                                let l14 = *ptr0
                                    .add(9 * ::core::mem::size_of::<*const u8>())
                                    .cast::<usize>();
                                let len15 = l14;
                                let bytes15 = _rt::Vec::from_raw_parts(
                                    l13.cast(),
                                    len15,
                                    len15,
                                );
                                let l16 = *ptr0
                                    .add(10 * ::core::mem::size_of::<*const u8>())
                                    .cast::<*mut u8>();
                                let l17 = *ptr0
                                    .add(11 * ::core::mem::size_of::<*const u8>())
                                    .cast::<usize>();
                                let base24 = l16;
                                let len24 = l17;
                                let mut result24 = _rt::Vec::with_capacity(len24);
                                for i in 0..len24 {
                                    let base = base24
                                        .add(i * (4 * ::core::mem::size_of::<*const u8>()));
                                    let e24 = {
                                        let l18 = *base.add(0).cast::<*mut u8>();
                                        let l19 = *base
                                            .add(::core::mem::size_of::<*const u8>())
                                            .cast::<usize>();
                                        let len20 = l19;
                                        let bytes20 = _rt::Vec::from_raw_parts(
                                            l18.cast(),
                                            len20,
                                            len20,
                                        );
                                        let l21 = *base
                                            .add(2 * ::core::mem::size_of::<*const u8>())
                                            .cast::<*mut u8>();
                                        let l22 = *base
                                            .add(3 * ::core::mem::size_of::<*const u8>())
                                            .cast::<usize>();
                                        let len23 = l22;
                                        let bytes23 = _rt::Vec::from_raw_parts(
                                            l21.cast(),
                                            len23,
                                            len23,
                                        );
                                        (_rt::string_lift(bytes20), _rt::string_lift(bytes23))
                                    };
                                    result24.push(e24);
                                }
                                _rt::cabi_dealloc(
                                    base24,
                                    len24 * (4 * ::core::mem::size_of::<*const u8>()),
                                    ::core::mem::size_of::<*const u8>(),
                                );
                                GrafanaConfig {
                                    endpoint: _rt::string_lift(bytes5),
                                    api_key: _rt::string_lift(bytes8),
                                    org_id: match l9 {
                                        0 => None,
                                        1 => {
                                            let e = {
                                                let l10 = *ptr0
                                                    .add(6 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<*mut u8>();
                                                let l11 = *ptr0
                                                    .add(7 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<usize>();
                                                let len12 = l11;
                                                let bytes12 = _rt::Vec::from_raw_parts(
                                                    l10.cast(),
                                                    len12,
                                                    len12,
                                                );
                                                _rt::string_lift(bytes12)
                                            };
                                            Some(e)
                                        }
                                        _ => _rt::invalid_enum_discriminant(),
                                    },
                                    service_name: _rt::string_lift(bytes15),
                                    resource_attributes: result24,
                                }
                            };
                            OtelProvider::Grafana(e137)
                        }
                        1 => {
                            let e137 = {
                                let l25 = *ptr0
                                    .add(::core::mem::size_of::<*const u8>())
                                    .cast::<*mut u8>();
                                let l26 = *ptr0
                                    .add(2 * ::core::mem::size_of::<*const u8>())
                                    .cast::<usize>();
                                let len27 = l26;
                                let bytes27 = _rt::Vec::from_raw_parts(
                                    l25.cast(),
                                    len27,
                                    len27,
                                );
                                let l28 = i32::from(
                                    *ptr0
                                        .add(3 * ::core::mem::size_of::<*const u8>())
                                        .cast::<u8>(),
                                );
                                let l32 = i32::from(
                                    *ptr0
                                        .add(6 * ::core::mem::size_of::<*const u8>())
                                        .cast::<u8>(),
                                );
                                let l36 = *ptr0
                                    .add(9 * ::core::mem::size_of::<*const u8>())
                                    .cast::<*mut u8>();
                                let l37 = *ptr0
                                    .add(10 * ::core::mem::size_of::<*const u8>())
                                    .cast::<usize>();
                                let len38 = l37;
                                let bytes38 = _rt::Vec::from_raw_parts(
                                    l36.cast(),
                                    len38,
                                    len38,
                                );
                                let l39 = *ptr0
                                    .add(11 * ::core::mem::size_of::<*const u8>())
                                    .cast::<*mut u8>();
                                let l40 = *ptr0
                                    .add(12 * ::core::mem::size_of::<*const u8>())
                                    .cast::<usize>();
                                let base47 = l39;
                                let len47 = l40;
                                let mut result47 = _rt::Vec::with_capacity(len47);
                                for i in 0..len47 {
                                    let base = base47
                                        .add(i * (4 * ::core::mem::size_of::<*const u8>()));
                                    let e47 = {
                                        let l41 = *base.add(0).cast::<*mut u8>();
                                        let l42 = *base
                                            .add(::core::mem::size_of::<*const u8>())
                                            .cast::<usize>();
                                        let len43 = l42;
                                        let bytes43 = _rt::Vec::from_raw_parts(
                                            l41.cast(),
                                            len43,
                                            len43,
                                        );
                                        let l44 = *base
                                            .add(2 * ::core::mem::size_of::<*const u8>())
                                            .cast::<*mut u8>();
                                        let l45 = *base
                                            .add(3 * ::core::mem::size_of::<*const u8>())
                                            .cast::<usize>();
                                        let len46 = l45;
                                        let bytes46 = _rt::Vec::from_raw_parts(
                                            l44.cast(),
                                            len46,
                                            len46,
                                        );
                                        (_rt::string_lift(bytes43), _rt::string_lift(bytes46))
                                    };
                                    result47.push(e47);
                                }
                                _rt::cabi_dealloc(
                                    base47,
                                    len47 * (4 * ::core::mem::size_of::<*const u8>()),
                                    ::core::mem::size_of::<*const u8>(),
                                );
                                JaegerConfig {
                                    endpoint: _rt::string_lift(bytes27),
                                    username: match l28 {
                                        0 => None,
                                        1 => {
                                            let e = {
                                                let l29 = *ptr0
                                                    .add(4 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<*mut u8>();
                                                let l30 = *ptr0
                                                    .add(5 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<usize>();
                                                let len31 = l30;
                                                let bytes31 = _rt::Vec::from_raw_parts(
                                                    l29.cast(),
                                                    len31,
                                                    len31,
                                                );
                                                _rt::string_lift(bytes31)
                                            };
                                            Some(e)
                                        }
                                        _ => _rt::invalid_enum_discriminant(),
                                    },
                                    password: match l32 {
                                        0 => None,
                                        1 => {
                                            let e = {
                                                let l33 = *ptr0
                                                    .add(7 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<*mut u8>();
                                                let l34 = *ptr0
                                                    .add(8 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<usize>();
                                                let len35 = l34;
                                                let bytes35 = _rt::Vec::from_raw_parts(
                                                    l33.cast(),
                                                    len35,
                                                    len35,
                                                );
                                                _rt::string_lift(bytes35)
                                            };
                                            Some(e)
                                        }
                                        _ => _rt::invalid_enum_discriminant(),
                                    },
                                    service_name: _rt::string_lift(bytes38),
                                    resource_attributes: result47,
                                }
                            };
                            OtelProvider::Jaeger(e137)
                        }
                        2 => {
                            let e137 = {
                                let l48 = *ptr0
                                    .add(::core::mem::size_of::<*const u8>())
                                    .cast::<*mut u8>();
                                let l49 = *ptr0
                                    .add(2 * ::core::mem::size_of::<*const u8>())
                                    .cast::<usize>();
                                let len50 = l49;
                                let bytes50 = _rt::Vec::from_raw_parts(
                                    l48.cast(),
                                    len50,
                                    len50,
                                );
                                let l51 = *ptr0
                                    .add(3 * ::core::mem::size_of::<*const u8>())
                                    .cast::<*mut u8>();
                                let l52 = *ptr0
                                    .add(4 * ::core::mem::size_of::<*const u8>())
                                    .cast::<usize>();
                                let len53 = l52;
                                let bytes53 = _rt::Vec::from_raw_parts(
                                    l51.cast(),
                                    len53,
                                    len53,
                                );
                                let l54 = *ptr0
                                    .add(5 * ::core::mem::size_of::<*const u8>())
                                    .cast::<*mut u8>();
                                let l55 = *ptr0
                                    .add(6 * ::core::mem::size_of::<*const u8>())
                                    .cast::<usize>();
                                let len56 = l55;
                                let bytes56 = _rt::Vec::from_raw_parts(
                                    l54.cast(),
                                    len56,
                                    len56,
                                );
                                let l57 = i32::from(
                                    *ptr0
                                        .add(7 * ::core::mem::size_of::<*const u8>())
                                        .cast::<u8>(),
                                );
                                let l61 = i32::from(
                                    *ptr0
                                        .add(10 * ::core::mem::size_of::<*const u8>())
                                        .cast::<u8>(),
                                );
                                let l65 = *ptr0
                                    .add(13 * ::core::mem::size_of::<*const u8>())
                                    .cast::<*mut u8>();
                                let l66 = *ptr0
                                    .add(14 * ::core::mem::size_of::<*const u8>())
                                    .cast::<usize>();
                                let base73 = l65;
                                let len73 = l66;
                                let mut result73 = _rt::Vec::with_capacity(len73);
                                for i in 0..len73 {
                                    let base = base73
                                        .add(i * (4 * ::core::mem::size_of::<*const u8>()));
                                    let e73 = {
                                        let l67 = *base.add(0).cast::<*mut u8>();
                                        let l68 = *base
                                            .add(::core::mem::size_of::<*const u8>())
                                            .cast::<usize>();
                                        let len69 = l68;
                                        let bytes69 = _rt::Vec::from_raw_parts(
                                            l67.cast(),
                                            len69,
                                            len69,
                                        );
                                        let l70 = *base
                                            .add(2 * ::core::mem::size_of::<*const u8>())
                                            .cast::<*mut u8>();
                                        let l71 = *base
                                            .add(3 * ::core::mem::size_of::<*const u8>())
                                            .cast::<usize>();
                                        let len72 = l71;
                                        let bytes72 = _rt::Vec::from_raw_parts(
                                            l70.cast(),
                                            len72,
                                            len72,
                                        );
                                        (_rt::string_lift(bytes69), _rt::string_lift(bytes72))
                                    };
                                    result73.push(e73);
                                }
                                _rt::cabi_dealloc(
                                    base73,
                                    len73 * (4 * ::core::mem::size_of::<*const u8>()),
                                    ::core::mem::size_of::<*const u8>(),
                                );
                                DatadogConfig {
                                    site: _rt::string_lift(bytes50),
                                    api_key: _rt::string_lift(bytes53),
                                    service_name: _rt::string_lift(bytes56),
                                    environment: match l57 {
                                        0 => None,
                                        1 => {
                                            let e = {
                                                let l58 = *ptr0
                                                    .add(8 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<*mut u8>();
                                                let l59 = *ptr0
                                                    .add(9 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<usize>();
                                                let len60 = l59;
                                                let bytes60 = _rt::Vec::from_raw_parts(
                                                    l58.cast(),
                                                    len60,
                                                    len60,
                                                );
                                                _rt::string_lift(bytes60)
                                            };
                                            Some(e)
                                        }
                                        _ => _rt::invalid_enum_discriminant(),
                                    },
                                    version: match l61 {
                                        0 => None,
                                        1 => {
                                            let e = {
                                                let l62 = *ptr0
                                                    .add(11 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<*mut u8>();
                                                let l63 = *ptr0
                                                    .add(12 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<usize>();
                                                let len64 = l63;
                                                let bytes64 = _rt::Vec::from_raw_parts(
                                                    l62.cast(),
                                                    len64,
                                                    len64,
                                                );
                                                _rt::string_lift(bytes64)
                                            };
                                            Some(e)
                                        }
                                        _ => _rt::invalid_enum_discriminant(),
                                    },
                                    resource_attributes: result73,
                                }
                            };
                            OtelProvider::Datadog(e137)
                        }
                        3 => {
                            let e137 = {
                                let l74 = *ptr0
                                    .add(::core::mem::size_of::<*const u8>())
                                    .cast::<*mut u8>();
                                let l75 = *ptr0
                                    .add(2 * ::core::mem::size_of::<*const u8>())
                                    .cast::<usize>();
                                let len76 = l75;
                                let bytes76 = _rt::Vec::from_raw_parts(
                                    l74.cast(),
                                    len76,
                                    len76,
                                );
                                let l77 = *ptr0
                                    .add(3 * ::core::mem::size_of::<*const u8>())
                                    .cast::<*mut u8>();
                                let l78 = *ptr0
                                    .add(4 * ::core::mem::size_of::<*const u8>())
                                    .cast::<usize>();
                                let len79 = l78;
                                let bytes79 = _rt::Vec::from_raw_parts(
                                    l77.cast(),
                                    len79,
                                    len79,
                                );
                                let l80 = *ptr0
                                    .add(5 * ::core::mem::size_of::<*const u8>())
                                    .cast::<*mut u8>();
                                let l81 = *ptr0
                                    .add(6 * ::core::mem::size_of::<*const u8>())
                                    .cast::<usize>();
                                let len82 = l81;
                                let bytes82 = _rt::Vec::from_raw_parts(
                                    l80.cast(),
                                    len82,
                                    len82,
                                );
                                let l83 = *ptr0
                                    .add(7 * ::core::mem::size_of::<*const u8>())
                                    .cast::<*mut u8>();
                                let l84 = *ptr0
                                    .add(8 * ::core::mem::size_of::<*const u8>())
                                    .cast::<usize>();
                                let len85 = l84;
                                let bytes85 = _rt::Vec::from_raw_parts(
                                    l83.cast(),
                                    len85,
                                    len85,
                                );
                                let l86 = *ptr0
                                    .add(9 * ::core::mem::size_of::<*const u8>())
                                    .cast::<*mut u8>();
                                let l87 = *ptr0
                                    .add(10 * ::core::mem::size_of::<*const u8>())
                                    .cast::<usize>();
                                let base94 = l86;
                                let len94 = l87;
                                let mut result94 = _rt::Vec::with_capacity(len94);
                                for i in 0..len94 {
                                    let base = base94
                                        .add(i * (4 * ::core::mem::size_of::<*const u8>()));
                                    let e94 = {
                                        let l88 = *base.add(0).cast::<*mut u8>();
                                        let l89 = *base
                                            .add(::core::mem::size_of::<*const u8>())
                                            .cast::<usize>();
                                        let len90 = l89;
                                        let bytes90 = _rt::Vec::from_raw_parts(
                                            l88.cast(),
                                            len90,
                                            len90,
                                        );
                                        let l91 = *base
                                            .add(2 * ::core::mem::size_of::<*const u8>())
                                            .cast::<*mut u8>();
                                        let l92 = *base
                                            .add(3 * ::core::mem::size_of::<*const u8>())
                                            .cast::<usize>();
                                        let len93 = l92;
                                        let bytes93 = _rt::Vec::from_raw_parts(
                                            l91.cast(),
                                            len93,
                                            len93,
                                        );
                                        (_rt::string_lift(bytes90), _rt::string_lift(bytes93))
                                    };
                                    result94.push(e94);
                                }
                                _rt::cabi_dealloc(
                                    base94,
                                    len94 * (4 * ::core::mem::size_of::<*const u8>()),
                                    ::core::mem::size_of::<*const u8>(),
                                );
                                HoneycombConfig {
                                    endpoint: _rt::string_lift(bytes76),
                                    api_key: _rt::string_lift(bytes79),
                                    dataset: _rt::string_lift(bytes82),
                                    service_name: _rt::string_lift(bytes85),
                                    resource_attributes: result94,
                                }
                            };
                            OtelProvider::Honeycomb(e137)
                        }
                        4 => {
                            let e137 = {
                                let l95 = *ptr0
                                    .add(::core::mem::size_of::<*const u8>())
                                    .cast::<*mut u8>();
                                let l96 = *ptr0
                                    .add(2 * ::core::mem::size_of::<*const u8>())
                                    .cast::<usize>();
                                let len97 = l96;
                                let bytes97 = _rt::Vec::from_raw_parts(
                                    l95.cast(),
                                    len97,
                                    len97,
                                );
                                let l98 = *ptr0
                                    .add(3 * ::core::mem::size_of::<*const u8>())
                                    .cast::<*mut u8>();
                                let l99 = *ptr0
                                    .add(4 * ::core::mem::size_of::<*const u8>())
                                    .cast::<usize>();
                                let len100 = l99;
                                let bytes100 = _rt::Vec::from_raw_parts(
                                    l98.cast(),
                                    len100,
                                    len100,
                                );
                                let l101 = *ptr0
                                    .add(5 * ::core::mem::size_of::<*const u8>())
                                    .cast::<*mut u8>();
                                let l102 = *ptr0
                                    .add(6 * ::core::mem::size_of::<*const u8>())
                                    .cast::<usize>();
                                let len103 = l102;
                                let bytes103 = _rt::Vec::from_raw_parts(
                                    l101.cast(),
                                    len103,
                                    len103,
                                );
                                let l104 = *ptr0
                                    .add(7 * ::core::mem::size_of::<*const u8>())
                                    .cast::<*mut u8>();
                                let l105 = *ptr0
                                    .add(8 * ::core::mem::size_of::<*const u8>())
                                    .cast::<usize>();
                                let base112 = l104;
                                let len112 = l105;
                                let mut result112 = _rt::Vec::with_capacity(len112);
                                for i in 0..len112 {
                                    let base = base112
                                        .add(i * (4 * ::core::mem::size_of::<*const u8>()));
                                    let e112 = {
                                        let l106 = *base.add(0).cast::<*mut u8>();
                                        let l107 = *base
                                            .add(::core::mem::size_of::<*const u8>())
                                            .cast::<usize>();
                                        let len108 = l107;
                                        let bytes108 = _rt::Vec::from_raw_parts(
                                            l106.cast(),
                                            len108,
                                            len108,
                                        );
                                        let l109 = *base
                                            .add(2 * ::core::mem::size_of::<*const u8>())
                                            .cast::<*mut u8>();
                                        let l110 = *base
                                            .add(3 * ::core::mem::size_of::<*const u8>())
                                            .cast::<usize>();
                                        let len111 = l110;
                                        let bytes111 = _rt::Vec::from_raw_parts(
                                            l109.cast(),
                                            len111,
                                            len111,
                                        );
                                        (_rt::string_lift(bytes108), _rt::string_lift(bytes111))
                                    };
                                    result112.push(e112);
                                }
                                _rt::cabi_dealloc(
                                    base112,
                                    len112 * (4 * ::core::mem::size_of::<*const u8>()),
                                    ::core::mem::size_of::<*const u8>(),
                                );
                                NewrelicConfig {
                                    endpoint: _rt::string_lift(bytes97),
                                    api_key: _rt::string_lift(bytes100),
                                    service_name: _rt::string_lift(bytes103),
                                    resource_attributes: result112,
                                }
                            };
                            OtelProvider::Newrelic(e137)
                        }
                        n => {
                            debug_assert_eq!(n, 5, "invalid enum discriminant");
                            let e137 = {
                                let l113 = *ptr0
                                    .add(::core::mem::size_of::<*const u8>())
                                    .cast::<*mut u8>();
                                let l114 = *ptr0
                                    .add(2 * ::core::mem::size_of::<*const u8>())
                                    .cast::<usize>();
                                let len115 = l114;
                                let bytes115 = _rt::Vec::from_raw_parts(
                                    l113.cast(),
                                    len115,
                                    len115,
                                );
                                let l116 = *ptr0
                                    .add(3 * ::core::mem::size_of::<*const u8>())
                                    .cast::<*mut u8>();
                                let l117 = *ptr0
                                    .add(4 * ::core::mem::size_of::<*const u8>())
                                    .cast::<usize>();
                                let base124 = l116;
                                let len124 = l117;
                                let mut result124 = _rt::Vec::with_capacity(len124);
                                for i in 0..len124 {
                                    let base = base124
                                        .add(i * (4 * ::core::mem::size_of::<*const u8>()));
                                    let e124 = {
                                        let l118 = *base.add(0).cast::<*mut u8>();
                                        let l119 = *base
                                            .add(::core::mem::size_of::<*const u8>())
                                            .cast::<usize>();
                                        let len120 = l119;
                                        let bytes120 = _rt::Vec::from_raw_parts(
                                            l118.cast(),
                                            len120,
                                            len120,
                                        );
                                        let l121 = *base
                                            .add(2 * ::core::mem::size_of::<*const u8>())
                                            .cast::<*mut u8>();
                                        let l122 = *base
                                            .add(3 * ::core::mem::size_of::<*const u8>())
                                            .cast::<usize>();
                                        let len123 = l122;
                                        let bytes123 = _rt::Vec::from_raw_parts(
                                            l121.cast(),
                                            len123,
                                            len123,
                                        );
                                        (_rt::string_lift(bytes120), _rt::string_lift(bytes123))
                                    };
                                    result124.push(e124);
                                }
                                _rt::cabi_dealloc(
                                    base124,
                                    len124 * (4 * ::core::mem::size_of::<*const u8>()),
                                    ::core::mem::size_of::<*const u8>(),
                                );
                                let l125 = *ptr0
                                    .add(5 * ::core::mem::size_of::<*const u8>())
                                    .cast::<*mut u8>();
                                let l126 = *ptr0
                                    .add(6 * ::core::mem::size_of::<*const u8>())
                                    .cast::<usize>();
                                let len127 = l126;
                                let bytes127 = _rt::Vec::from_raw_parts(
                                    l125.cast(),
                                    len127,
                                    len127,
                                );
                                let l128 = *ptr0
                                    .add(7 * ::core::mem::size_of::<*const u8>())
                                    .cast::<*mut u8>();
                                let l129 = *ptr0
                                    .add(8 * ::core::mem::size_of::<*const u8>())
                                    .cast::<usize>();
                                let base136 = l128;
                                let len136 = l129;
                                let mut result136 = _rt::Vec::with_capacity(len136);
                                for i in 0..len136 {
                                    let base = base136
                                        .add(i * (4 * ::core::mem::size_of::<*const u8>()));
                                    let e136 = {
                                        let l130 = *base.add(0).cast::<*mut u8>();
                                        let l131 = *base
                                            .add(::core::mem::size_of::<*const u8>())
                                            .cast::<usize>();
                                        let len132 = l131;
                                        let bytes132 = _rt::Vec::from_raw_parts(
                                            l130.cast(),
                                            len132,
                                            len132,
                                        );
                                        let l133 = *base
                                            .add(2 * ::core::mem::size_of::<*const u8>())
                                            .cast::<*mut u8>();
                                        let l134 = *base
                                            .add(3 * ::core::mem::size_of::<*const u8>())
                                            .cast::<usize>();
                                        let len135 = l134;
                                        let bytes135 = _rt::Vec::from_raw_parts(
                                            l133.cast(),
                                            len135,
                                            len135,
                                        );
                                        (_rt::string_lift(bytes132), _rt::string_lift(bytes135))
                                    };
                                    result136.push(e136);
                                }
                                _rt::cabi_dealloc(
                                    base136,
                                    len136 * (4 * ::core::mem::size_of::<*const u8>()),
                                    ::core::mem::size_of::<*const u8>(),
                                );
                                GenericOtlpConfig {
                                    endpoint: _rt::string_lift(bytes115),
                                    headers: result124,
                                    service_name: _rt::string_lift(bytes127),
                                    resource_attributes: result136,
                                }
                            };
                            OtelProvider::GenericOtlp(e137)
                        }
                    };
                    let l138 = i32::from(
                        *ptr0.add(15 * ::core::mem::size_of::<*const u8>()).cast::<u8>(),
                    );
                    let v159 = match l138 {
                        0 => {
                            let e159 = {
                                let l139 = *ptr0
                                    .add(16 * ::core::mem::size_of::<*const u8>())
                                    .cast::<*mut u8>();
                                let l140 = *ptr0
                                    .add(17 * ::core::mem::size_of::<*const u8>())
                                    .cast::<usize>();
                                let len141 = l140;
                                let bytes141 = _rt::Vec::from_raw_parts(
                                    l139.cast(),
                                    len141,
                                    len141,
                                );
                                let l142 = i32::from(
                                    *ptr0
                                        .add(18 * ::core::mem::size_of::<*const u8>())
                                        .cast::<u8>(),
                                );
                                let l144 = i32::from(
                                    *ptr0
                                        .add(4 + 18 * ::core::mem::size_of::<*const u8>())
                                        .cast::<u8>(),
                                );
                                OtlpHttpConfig {
                                    content_type: _rt::string_lift(bytes141),
                                    compression: match l142 {
                                        0 => None,
                                        1 => {
                                            let e = {
                                                let l143 = i32::from(
                                                    *ptr0
                                                        .add(1 + 18 * ::core::mem::size_of::<*const u8>())
                                                        .cast::<u8>(),
                                                );
                                                CompressionType::_lift(l143 as u8)
                                            };
                                            Some(e)
                                        }
                                        _ => _rt::invalid_enum_discriminant(),
                                    },
                                    timeout_ms: match l144 {
                                        0 => None,
                                        1 => {
                                            let e = {
                                                let l145 = *ptr0
                                                    .add(8 + 18 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<i32>();
                                                l145 as u32
                                            };
                                            Some(e)
                                        }
                                        _ => _rt::invalid_enum_discriminant(),
                                    },
                                }
                            };
                            OtelProtocol::OtlpHttp(e159)
                        }
                        1 => {
                            let e159 = {
                                let l146 = i32::from(
                                    *ptr0
                                        .add(16 * ::core::mem::size_of::<*const u8>())
                                        .cast::<u8>(),
                                );
                                let l148 = i32::from(
                                    *ptr0
                                        .add(4 + 16 * ::core::mem::size_of::<*const u8>())
                                        .cast::<u8>(),
                                );
                                OtlpGrpcConfig {
                                    compression: match l146 {
                                        0 => None,
                                        1 => {
                                            let e = {
                                                let l147 = i32::from(
                                                    *ptr0
                                                        .add(1 + 16 * ::core::mem::size_of::<*const u8>())
                                                        .cast::<u8>(),
                                                );
                                                CompressionType::_lift(l147 as u8)
                                            };
                                            Some(e)
                                        }
                                        _ => _rt::invalid_enum_discriminant(),
                                    },
                                    timeout_ms: match l148 {
                                        0 => None,
                                        1 => {
                                            let e = {
                                                let l149 = *ptr0
                                                    .add(8 + 16 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<i32>();
                                                l149 as u32
                                            };
                                            Some(e)
                                        }
                                        _ => _rt::invalid_enum_discriminant(),
                                    },
                                }
                            };
                            OtelProtocol::OtlpGrpc(e159)
                        }
                        2 => {
                            let e159 = {
                                let l150 = i32::from(
                                    *ptr0
                                        .add(16 * ::core::mem::size_of::<*const u8>())
                                        .cast::<u8>(),
                                );
                                let l152 = i32::from(
                                    *ptr0
                                        .add(8 + 16 * ::core::mem::size_of::<*const u8>())
                                        .cast::<u8>(),
                                );
                                JaegerThriftConfig {
                                    batch_size: match l150 {
                                        0 => None,
                                        1 => {
                                            let e = {
                                                let l151 = *ptr0
                                                    .add(4 + 16 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<i32>();
                                                l151 as u32
                                            };
                                            Some(e)
                                        }
                                        _ => _rt::invalid_enum_discriminant(),
                                    },
                                    timeout_ms: match l152 {
                                        0 => None,
                                        1 => {
                                            let e = {
                                                let l153 = *ptr0
                                                    .add(12 + 16 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<i32>();
                                                l153 as u32
                                            };
                                            Some(e)
                                        }
                                        _ => _rt::invalid_enum_discriminant(),
                                    },
                                }
                            };
                            OtelProtocol::JaegerThrift(e159)
                        }
                        n => {
                            debug_assert_eq!(n, 3, "invalid enum discriminant");
                            let e159 = {
                                let l154 = i32::from(
                                    *ptr0
                                        .add(16 * ::core::mem::size_of::<*const u8>())
                                        .cast::<u8>(),
                                );
                                let l156 = *ptr0
                                    .add(8 + 16 * ::core::mem::size_of::<*const u8>())
                                    .cast::<*mut u8>();
                                let l157 = *ptr0
                                    .add(8 + 17 * ::core::mem::size_of::<*const u8>())
                                    .cast::<usize>();
                                let len158 = l157;
                                let bytes158 = _rt::Vec::from_raw_parts(
                                    l156.cast(),
                                    len158,
                                    len158,
                                );
                                ZipkinJsonConfig {
                                    batch_size: match l154 {
                                        0 => None,
                                        1 => {
                                            let e = {
                                                let l155 = *ptr0
                                                    .add(4 + 16 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<i32>();
                                                l155 as u32
                                            };
                                            Some(e)
                                        }
                                        _ => _rt::invalid_enum_discriminant(),
                                    },
                                    endpoint_path: _rt::string_lift(bytes158),
                                }
                            };
                            OtelProtocol::ZipkinJson(e159)
                        }
                    };
                    let result160 = OtelConfig {
                        provider: v137,
                        protocol: v159,
                    };
                    result160
                }
            }
        }
    }
}
#[rustfmt::skip]
#[allow(dead_code, clippy::all)]
pub mod exports {
    pub mod wasi {
        pub mod otel {
            #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
            pub mod tracing {
                #[used]
                #[doc(hidden)]
                static __FORCE_SECTION_REF: fn() = super::super::super::super::__link_custom_section_describing_imports;
                use super::super::super::super::_rt;
                pub type Datetime = super::super::super::super::wasi::clocks::wall_clock::Datetime;
                /// The trace that this `span-context` belongs to.
                ///
                /// 16 bytes encoded as a hexadecimal string.
                pub type TraceId = _rt::String;
                /// The id of this `span-context`.
                ///
                /// 8 bytes encoded as a hexadecimal string.
                pub type SpanId = _rt::String;
                wit_bindgen_rt::bitflags::bitflags! {
                    #[doc = " Flags that can be set on a `span-context`."]
                    #[derive(PartialEq, Eq, PartialOrd, Ord, Hash, Debug, Clone, Copy)]
                    pub struct TraceFlags : u8 { #[doc =
                    " Whether the `span` should be sampled or not."] const SAMPLED = 1 <<
                    0; }
                }
                /// Carries system-specific configuration data, represented as a list of key-value pairs. `trace-state` allows multiple tracing systems to participate in the same trace.
                ///
                /// If any invalid keys or values are provided then the `trace-state` will be treated as an empty list.
                pub type TraceState = _rt::Vec<(_rt::String, _rt::String)>;
                /// Identifying trace information about a span that can be serialized and propagated.
                #[derive(Clone)]
                pub struct SpanContext {
                    /// The `trace-id` for this `span-context`.
                    pub trace_id: TraceId,
                    /// The `span-id` for this `span-context`.
                    pub span_id: SpanId,
                    /// The `trace-flags` for this `span-context`.
                    pub trace_flags: TraceFlags,
                    /// Whether this `span-context` was propagated from a remote parent.
                    pub is_remote: bool,
                    /// The `trace-state` for this `span-context`.
                    pub trace_state: TraceState,
                }
                impl ::core::fmt::Debug for SpanContext {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter<'_>,
                    ) -> ::core::fmt::Result {
                        f.debug_struct("SpanContext")
                            .field("trace-id", &self.trace_id)
                            .field("span-id", &self.span_id)
                            .field("trace-flags", &self.trace_flags)
                            .field("is-remote", &self.is_remote)
                            .field("trace-state", &self.trace_state)
                            .finish()
                    }
                }
                /// Describes the relationship between the Span, its parents, and its children in a trace.
                #[repr(u8)]
                #[derive(Clone, Copy, Eq, Ord, PartialEq, PartialOrd)]
                pub enum SpanKind {
                    /// Indicates that the span describes a request to some remote service. This span is usually the parent of a remote server span and does not end until the response is received.
                    Client,
                    /// Indicates that the span covers server-side handling of a synchronous RPC or other remote request. This span is often the child of a remote client span that was expected to wait for a response.
                    Server,
                    /// Indicates that the span describes the initiators of an asynchronous request. This parent span will often end before the corresponding child consumer span, possibly even before the child span starts. In messaging scenarios with batching, tracing individual messages requires a new producer span per message to be created.
                    Producer,
                    /// Indicates that the span describes a child of an asynchronous consumer request.
                    Consumer,
                    /// Default value. Indicates that the span represents an internal operation within an application, as opposed to an operations with remote parents or children.
                    Internal,
                }
                impl ::core::fmt::Debug for SpanKind {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter<'_>,
                    ) -> ::core::fmt::Result {
                        match self {
                            SpanKind::Client => {
                                f.debug_tuple("SpanKind::Client").finish()
                            }
                            SpanKind::Server => {
                                f.debug_tuple("SpanKind::Server").finish()
                            }
                            SpanKind::Producer => {
                                f.debug_tuple("SpanKind::Producer").finish()
                            }
                            SpanKind::Consumer => {
                                f.debug_tuple("SpanKind::Consumer").finish()
                            }
                            SpanKind::Internal => {
                                f.debug_tuple("SpanKind::Internal").finish()
                            }
                        }
                    }
                }
                impl SpanKind {
                    #[doc(hidden)]
                    pub unsafe fn _lift(val: u8) -> SpanKind {
                        if !cfg!(debug_assertions) {
                            return ::core::mem::transmute(val);
                        }
                        match val {
                            0 => SpanKind::Client,
                            1 => SpanKind::Server,
                            2 => SpanKind::Producer,
                            3 => SpanKind::Consumer,
                            4 => SpanKind::Internal,
                            _ => panic!("invalid enum discriminant"),
                        }
                    }
                }
                /// The key part of attribute `key-value` pairs.
                pub type Key = _rt::String;
                /// The value part of attribute `key-value` pairs.
                #[derive(Clone)]
                pub enum Value {
                    /// A string value.
                    String(_rt::String),
                    /// A boolean value.
                    Bool(bool),
                    /// A double precision floating point value.
                    F64(f64),
                    /// A signed 64 bit integer value.
                    S64(i64),
                    /// A homogeneous array of string values.
                    StringArray(_rt::Vec<_rt::String>),
                    /// A homogeneous array of boolean values.
                    BoolArray(_rt::Vec<bool>),
                    /// A homogeneous array of double precision floating point values.
                    F64Array(_rt::Vec<f64>),
                    /// A homogeneous array of 64 bit integer values.
                    S64Array(_rt::Vec<i64>),
                }
                impl ::core::fmt::Debug for Value {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter<'_>,
                    ) -> ::core::fmt::Result {
                        match self {
                            Value::String(e) => {
                                f.debug_tuple("Value::String").field(e).finish()
                            }
                            Value::Bool(e) => {
                                f.debug_tuple("Value::Bool").field(e).finish()
                            }
                            Value::F64(e) => {
                                f.debug_tuple("Value::F64").field(e).finish()
                            }
                            Value::S64(e) => {
                                f.debug_tuple("Value::S64").field(e).finish()
                            }
                            Value::StringArray(e) => {
                                f.debug_tuple("Value::StringArray").field(e).finish()
                            }
                            Value::BoolArray(e) => {
                                f.debug_tuple("Value::BoolArray").field(e).finish()
                            }
                            Value::F64Array(e) => {
                                f.debug_tuple("Value::F64Array").field(e).finish()
                            }
                            Value::S64Array(e) => {
                                f.debug_tuple("Value::S64Array").field(e).finish()
                            }
                        }
                    }
                }
                /// A key-value pair describing an attribute.
                #[derive(Clone)]
                pub struct KeyValue {
                    /// The attribute name.
                    pub key: Key,
                    /// The attribute value.
                    pub value: Value,
                }
                impl ::core::fmt::Debug for KeyValue {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter<'_>,
                    ) -> ::core::fmt::Result {
                        f.debug_struct("KeyValue")
                            .field("key", &self.key)
                            .field("value", &self.value)
                            .finish()
                    }
                }
                /// An event describing a specific moment in time on a span and associated attributes.
                #[derive(Clone)]
                pub struct Event {
                    /// Event name.
                    pub name: _rt::String,
                    /// Event time.
                    pub time: Datetime,
                    /// Event attributes.
                    pub attributes: _rt::Vec<KeyValue>,
                }
                impl ::core::fmt::Debug for Event {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter<'_>,
                    ) -> ::core::fmt::Result {
                        f.debug_struct("Event")
                            .field("name", &self.name)
                            .field("time", &self.time)
                            .field("attributes", &self.attributes)
                            .finish()
                    }
                }
                /// Describes a relationship to another `span`.
                #[derive(Clone)]
                pub struct Link {
                    /// Denotes which `span` to link to.
                    pub span_context: SpanContext,
                    /// Attributes describing the link.
                    pub attributes: _rt::Vec<KeyValue>,
                }
                impl ::core::fmt::Debug for Link {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter<'_>,
                    ) -> ::core::fmt::Result {
                        f.debug_struct("Link")
                            .field("span-context", &self.span_context)
                            .field("attributes", &self.attributes)
                            .finish()
                    }
                }
                /// The `status` of a `span`.
                #[derive(Clone)]
                pub enum Status {
                    /// The default status.
                    Unset,
                    /// The operation has been validated by an Application developer or Operator to have completed successfully.
                    Ok,
                    /// The operation contains an error with a description.
                    Error(_rt::String),
                }
                impl ::core::fmt::Debug for Status {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter<'_>,
                    ) -> ::core::fmt::Result {
                        match self {
                            Status::Unset => f.debug_tuple("Status::Unset").finish(),
                            Status::Ok => f.debug_tuple("Status::Ok").finish(),
                            Status::Error(e) => {
                                f.debug_tuple("Status::Error").field(e).finish()
                            }
                        }
                    }
                }
                /// Describes the instrumentation scope that produced a span.
                #[derive(Clone)]
                pub struct InstrumentationScope {
                    /// Name of the instrumentation scope.
                    pub name: _rt::String,
                    /// The library version.
                    pub version: Option<_rt::String>,
                    /// Schema URL used by this library.
                    /// https://github.com/open-telemetry/opentelemetry-specification/blob/v1.9.0/specification/schemas/overview.md#schema-url
                    pub schema_url: Option<_rt::String>,
                    /// Specifies the instrumentation scope attributes to associate with emitted telemetry.
                    pub attributes: _rt::Vec<KeyValue>,
                }
                impl ::core::fmt::Debug for InstrumentationScope {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter<'_>,
                    ) -> ::core::fmt::Result {
                        f.debug_struct("InstrumentationScope")
                            .field("name", &self.name)
                            .field("version", &self.version)
                            .field("schema-url", &self.schema_url)
                            .field("attributes", &self.attributes)
                            .finish()
                    }
                }
                /// The data associated with a span.
                #[derive(Clone)]
                pub struct SpanData {
                    /// Span context.
                    pub span_context: SpanContext,
                    /// Span parent id.
                    pub parent_span_id: _rt::String,
                    /// Span kind.
                    pub span_kind: SpanKind,
                    /// Span name.
                    pub name: _rt::String,
                    /// Span start time.
                    pub start_time: Datetime,
                    /// Span end time.
                    pub end_time: Datetime,
                    /// Span attributes.
                    pub attributes: _rt::Vec<KeyValue>,
                    /// Span events.
                    pub events: _rt::Vec<Event>,
                    /// Span Links.
                    pub links: _rt::Vec<Link>,
                    /// Span status.
                    pub status: Status,
                    /// Instrumentation scope that produced this span.
                    pub instrumentation_scope: InstrumentationScope,
                    /// Number of attributes dropped by the span due to limits being reached.
                    pub dropped_attributes: u32,
                    /// Number of events dropped by the span due to limits being reached.
                    pub dropped_events: u32,
                    /// Number of links dropped by the span due to limits being reached.
                    pub dropped_links: u32,
                }
                impl ::core::fmt::Debug for SpanData {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter<'_>,
                    ) -> ::core::fmt::Result {
                        f.debug_struct("SpanData")
                            .field("span-context", &self.span_context)
                            .field("parent-span-id", &self.parent_span_id)
                            .field("span-kind", &self.span_kind)
                            .field("name", &self.name)
                            .field("start-time", &self.start_time)
                            .field("end-time", &self.end_time)
                            .field("attributes", &self.attributes)
                            .field("events", &self.events)
                            .field("links", &self.links)
                            .field("status", &self.status)
                            .field("instrumentation-scope", &self.instrumentation_scope)
                            .field("dropped-attributes", &self.dropped_attributes)
                            .field("dropped-events", &self.dropped_events)
                            .field("dropped-links", &self.dropped_links)
                            .finish()
                    }
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_on_start_cabi<T: Guest>(arg0: *mut u8) {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let l0 = *arg0.add(0).cast::<*mut u8>();
                    let l1 = *arg0
                        .add(::core::mem::size_of::<*const u8>())
                        .cast::<usize>();
                    let len2 = l1;
                    let bytes2 = _rt::Vec::from_raw_parts(l0.cast(), len2, len2);
                    let l3 = *arg0
                        .add(2 * ::core::mem::size_of::<*const u8>())
                        .cast::<*mut u8>();
                    let l4 = *arg0
                        .add(3 * ::core::mem::size_of::<*const u8>())
                        .cast::<usize>();
                    let len5 = l4;
                    let bytes5 = _rt::Vec::from_raw_parts(l3.cast(), len5, len5);
                    let l6 = i32::from(
                        *arg0.add(4 * ::core::mem::size_of::<*const u8>()).cast::<u8>(),
                    );
                    let l7 = i32::from(
                        *arg0
                            .add(1 + 4 * ::core::mem::size_of::<*const u8>())
                            .cast::<u8>(),
                    );
                    let l8 = *arg0
                        .add(5 * ::core::mem::size_of::<*const u8>())
                        .cast::<*mut u8>();
                    let l9 = *arg0
                        .add(6 * ::core::mem::size_of::<*const u8>())
                        .cast::<usize>();
                    let base16 = l8;
                    let len16 = l9;
                    let mut result16 = _rt::Vec::with_capacity(len16);
                    for i in 0..len16 {
                        let base = base16
                            .add(i * (4 * ::core::mem::size_of::<*const u8>()));
                        let e16 = {
                            let l10 = *base.add(0).cast::<*mut u8>();
                            let l11 = *base
                                .add(::core::mem::size_of::<*const u8>())
                                .cast::<usize>();
                            let len12 = l11;
                            let bytes12 = _rt::Vec::from_raw_parts(
                                l10.cast(),
                                len12,
                                len12,
                            );
                            let l13 = *base
                                .add(2 * ::core::mem::size_of::<*const u8>())
                                .cast::<*mut u8>();
                            let l14 = *base
                                .add(3 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>();
                            let len15 = l14;
                            let bytes15 = _rt::Vec::from_raw_parts(
                                l13.cast(),
                                len15,
                                len15,
                            );
                            (_rt::string_lift(bytes12), _rt::string_lift(bytes15))
                        };
                        result16.push(e16);
                    }
                    _rt::cabi_dealloc(
                        base16,
                        len16 * (4 * ::core::mem::size_of::<*const u8>()),
                        ::core::mem::size_of::<*const u8>(),
                    );
                    let l17 = *arg0
                        .add(7 * ::core::mem::size_of::<*const u8>())
                        .cast::<*mut u8>();
                    let l18 = *arg0
                        .add(8 * ::core::mem::size_of::<*const u8>())
                        .cast::<usize>();
                    let len19 = l18;
                    let bytes19 = _rt::Vec::from_raw_parts(l17.cast(), len19, len19);
                    let l20 = i32::from(
                        *arg0.add(9 * ::core::mem::size_of::<*const u8>()).cast::<u8>(),
                    );
                    let l21 = *arg0
                        .add(10 * ::core::mem::size_of::<*const u8>())
                        .cast::<*mut u8>();
                    let l22 = *arg0
                        .add(11 * ::core::mem::size_of::<*const u8>())
                        .cast::<usize>();
                    let len23 = l22;
                    let bytes23 = _rt::Vec::from_raw_parts(l21.cast(), len23, len23);
                    let l24 = *arg0
                        .add(12 * ::core::mem::size_of::<*const u8>())
                        .cast::<i64>();
                    let l25 = *arg0
                        .add(8 + 12 * ::core::mem::size_of::<*const u8>())
                        .cast::<i32>();
                    let l26 = *arg0
                        .add(16 + 12 * ::core::mem::size_of::<*const u8>())
                        .cast::<i64>();
                    let l27 = *arg0
                        .add(24 + 12 * ::core::mem::size_of::<*const u8>())
                        .cast::<i32>();
                    let l28 = *arg0
                        .add(32 + 12 * ::core::mem::size_of::<*const u8>())
                        .cast::<*mut u8>();
                    let l29 = *arg0
                        .add(32 + 13 * ::core::mem::size_of::<*const u8>())
                        .cast::<usize>();
                    let base57 = l28;
                    let len57 = l29;
                    let mut result57 = _rt::Vec::with_capacity(len57);
                    for i in 0..len57 {
                        let base = base57
                            .add(i * (8 + 4 * ::core::mem::size_of::<*const u8>()));
                        let e57 = {
                            let l30 = *base.add(0).cast::<*mut u8>();
                            let l31 = *base
                                .add(::core::mem::size_of::<*const u8>())
                                .cast::<usize>();
                            let len32 = l31;
                            let bytes32 = _rt::Vec::from_raw_parts(
                                l30.cast(),
                                len32,
                                len32,
                            );
                            let l33 = i32::from(
                                *base
                                    .add(2 * ::core::mem::size_of::<*const u8>())
                                    .cast::<u8>(),
                            );
                            let v56 = match l33 {
                                0 => {
                                    let e56 = {
                                        let l34 = *base
                                            .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                            .cast::<*mut u8>();
                                        let l35 = *base
                                            .add(8 + 3 * ::core::mem::size_of::<*const u8>())
                                            .cast::<usize>();
                                        let len36 = l35;
                                        let bytes36 = _rt::Vec::from_raw_parts(
                                            l34.cast(),
                                            len36,
                                            len36,
                                        );
                                        _rt::string_lift(bytes36)
                                    };
                                    Value::String(e56)
                                }
                                1 => {
                                    let e56 = {
                                        let l37 = i32::from(
                                            *base
                                                .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                .cast::<u8>(),
                                        );
                                        _rt::bool_lift(l37 as u8)
                                    };
                                    Value::Bool(e56)
                                }
                                2 => {
                                    let e56 = {
                                        let l38 = *base
                                            .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                            .cast::<f64>();
                                        l38
                                    };
                                    Value::F64(e56)
                                }
                                3 => {
                                    let e56 = {
                                        let l39 = *base
                                            .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                            .cast::<i64>();
                                        l39
                                    };
                                    Value::S64(e56)
                                }
                                4 => {
                                    let e56 = {
                                        let l40 = *base
                                            .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                            .cast::<*mut u8>();
                                        let l41 = *base
                                            .add(8 + 3 * ::core::mem::size_of::<*const u8>())
                                            .cast::<usize>();
                                        let base45 = l40;
                                        let len45 = l41;
                                        let mut result45 = _rt::Vec::with_capacity(len45);
                                        for i in 0..len45 {
                                            let base = base45
                                                .add(i * (2 * ::core::mem::size_of::<*const u8>()));
                                            let e45 = {
                                                let l42 = *base.add(0).cast::<*mut u8>();
                                                let l43 = *base
                                                    .add(::core::mem::size_of::<*const u8>())
                                                    .cast::<usize>();
                                                let len44 = l43;
                                                let bytes44 = _rt::Vec::from_raw_parts(
                                                    l42.cast(),
                                                    len44,
                                                    len44,
                                                );
                                                _rt::string_lift(bytes44)
                                            };
                                            result45.push(e45);
                                        }
                                        _rt::cabi_dealloc(
                                            base45,
                                            len45 * (2 * ::core::mem::size_of::<*const u8>()),
                                            ::core::mem::size_of::<*const u8>(),
                                        );
                                        result45
                                    };
                                    Value::StringArray(e56)
                                }
                                5 => {
                                    let e56 = {
                                        let l46 = *base
                                            .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                            .cast::<*mut u8>();
                                        let l47 = *base
                                            .add(8 + 3 * ::core::mem::size_of::<*const u8>())
                                            .cast::<usize>();
                                        let base49 = l46;
                                        let len49 = l47;
                                        let mut result49 = _rt::Vec::with_capacity(len49);
                                        for i in 0..len49 {
                                            let base = base49.add(i * 1);
                                            let e49 = {
                                                let l48 = i32::from(*base.add(0).cast::<u8>());
                                                _rt::bool_lift(l48 as u8)
                                            };
                                            result49.push(e49);
                                        }
                                        _rt::cabi_dealloc(base49, len49 * 1, 1);
                                        result49
                                    };
                                    Value::BoolArray(e56)
                                }
                                6 => {
                                    let e56 = {
                                        let l50 = *base
                                            .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                            .cast::<*mut u8>();
                                        let l51 = *base
                                            .add(8 + 3 * ::core::mem::size_of::<*const u8>())
                                            .cast::<usize>();
                                        let len52 = l51;
                                        _rt::Vec::from_raw_parts(l50.cast(), len52, len52)
                                    };
                                    Value::F64Array(e56)
                                }
                                n => {
                                    debug_assert_eq!(n, 7, "invalid enum discriminant");
                                    let e56 = {
                                        let l53 = *base
                                            .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                            .cast::<*mut u8>();
                                        let l54 = *base
                                            .add(8 + 3 * ::core::mem::size_of::<*const u8>())
                                            .cast::<usize>();
                                        let len55 = l54;
                                        _rt::Vec::from_raw_parts(l53.cast(), len55, len55)
                                    };
                                    Value::S64Array(e56)
                                }
                            };
                            KeyValue {
                                key: _rt::string_lift(bytes32),
                                value: v56,
                            }
                        };
                        result57.push(e57);
                    }
                    _rt::cabi_dealloc(
                        base57,
                        len57 * (8 + 4 * ::core::mem::size_of::<*const u8>()),
                        8,
                    );
                    let l58 = *arg0
                        .add(32 + 14 * ::core::mem::size_of::<*const u8>())
                        .cast::<*mut u8>();
                    let l59 = *arg0
                        .add(32 + 15 * ::core::mem::size_of::<*const u8>())
                        .cast::<usize>();
                    let base95 = l58;
                    let len95 = l59;
                    let mut result95 = _rt::Vec::with_capacity(len95);
                    for i in 0..len95 {
                        let base = base95
                            .add(i * (16 + 4 * ::core::mem::size_of::<*const u8>()));
                        let e95 = {
                            let l60 = *base.add(0).cast::<*mut u8>();
                            let l61 = *base
                                .add(::core::mem::size_of::<*const u8>())
                                .cast::<usize>();
                            let len62 = l61;
                            let bytes62 = _rt::Vec::from_raw_parts(
                                l60.cast(),
                                len62,
                                len62,
                            );
                            let l63 = *base
                                .add(2 * ::core::mem::size_of::<*const u8>())
                                .cast::<i64>();
                            let l64 = *base
                                .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                .cast::<i32>();
                            let l65 = *base
                                .add(16 + 2 * ::core::mem::size_of::<*const u8>())
                                .cast::<*mut u8>();
                            let l66 = *base
                                .add(16 + 3 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>();
                            let base94 = l65;
                            let len94 = l66;
                            let mut result94 = _rt::Vec::with_capacity(len94);
                            for i in 0..len94 {
                                let base = base94
                                    .add(i * (8 + 4 * ::core::mem::size_of::<*const u8>()));
                                let e94 = {
                                    let l67 = *base.add(0).cast::<*mut u8>();
                                    let l68 = *base
                                        .add(::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    let len69 = l68;
                                    let bytes69 = _rt::Vec::from_raw_parts(
                                        l67.cast(),
                                        len69,
                                        len69,
                                    );
                                    let l70 = i32::from(
                                        *base
                                            .add(2 * ::core::mem::size_of::<*const u8>())
                                            .cast::<u8>(),
                                    );
                                    let v93 = match l70 {
                                        0 => {
                                            let e93 = {
                                                let l71 = *base
                                                    .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<*mut u8>();
                                                let l72 = *base
                                                    .add(8 + 3 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<usize>();
                                                let len73 = l72;
                                                let bytes73 = _rt::Vec::from_raw_parts(
                                                    l71.cast(),
                                                    len73,
                                                    len73,
                                                );
                                                _rt::string_lift(bytes73)
                                            };
                                            Value::String(e93)
                                        }
                                        1 => {
                                            let e93 = {
                                                let l74 = i32::from(
                                                    *base
                                                        .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                        .cast::<u8>(),
                                                );
                                                _rt::bool_lift(l74 as u8)
                                            };
                                            Value::Bool(e93)
                                        }
                                        2 => {
                                            let e93 = {
                                                let l75 = *base
                                                    .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<f64>();
                                                l75
                                            };
                                            Value::F64(e93)
                                        }
                                        3 => {
                                            let e93 = {
                                                let l76 = *base
                                                    .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<i64>();
                                                l76
                                            };
                                            Value::S64(e93)
                                        }
                                        4 => {
                                            let e93 = {
                                                let l77 = *base
                                                    .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<*mut u8>();
                                                let l78 = *base
                                                    .add(8 + 3 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<usize>();
                                                let base82 = l77;
                                                let len82 = l78;
                                                let mut result82 = _rt::Vec::with_capacity(len82);
                                                for i in 0..len82 {
                                                    let base = base82
                                                        .add(i * (2 * ::core::mem::size_of::<*const u8>()));
                                                    let e82 = {
                                                        let l79 = *base.add(0).cast::<*mut u8>();
                                                        let l80 = *base
                                                            .add(::core::mem::size_of::<*const u8>())
                                                            .cast::<usize>();
                                                        let len81 = l80;
                                                        let bytes81 = _rt::Vec::from_raw_parts(
                                                            l79.cast(),
                                                            len81,
                                                            len81,
                                                        );
                                                        _rt::string_lift(bytes81)
                                                    };
                                                    result82.push(e82);
                                                }
                                                _rt::cabi_dealloc(
                                                    base82,
                                                    len82 * (2 * ::core::mem::size_of::<*const u8>()),
                                                    ::core::mem::size_of::<*const u8>(),
                                                );
                                                result82
                                            };
                                            Value::StringArray(e93)
                                        }
                                        5 => {
                                            let e93 = {
                                                let l83 = *base
                                                    .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<*mut u8>();
                                                let l84 = *base
                                                    .add(8 + 3 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<usize>();
                                                let base86 = l83;
                                                let len86 = l84;
                                                let mut result86 = _rt::Vec::with_capacity(len86);
                                                for i in 0..len86 {
                                                    let base = base86.add(i * 1);
                                                    let e86 = {
                                                        let l85 = i32::from(*base.add(0).cast::<u8>());
                                                        _rt::bool_lift(l85 as u8)
                                                    };
                                                    result86.push(e86);
                                                }
                                                _rt::cabi_dealloc(base86, len86 * 1, 1);
                                                result86
                                            };
                                            Value::BoolArray(e93)
                                        }
                                        6 => {
                                            let e93 = {
                                                let l87 = *base
                                                    .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<*mut u8>();
                                                let l88 = *base
                                                    .add(8 + 3 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<usize>();
                                                let len89 = l88;
                                                _rt::Vec::from_raw_parts(l87.cast(), len89, len89)
                                            };
                                            Value::F64Array(e93)
                                        }
                                        n => {
                                            debug_assert_eq!(n, 7, "invalid enum discriminant");
                                            let e93 = {
                                                let l90 = *base
                                                    .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<*mut u8>();
                                                let l91 = *base
                                                    .add(8 + 3 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<usize>();
                                                let len92 = l91;
                                                _rt::Vec::from_raw_parts(l90.cast(), len92, len92)
                                            };
                                            Value::S64Array(e93)
                                        }
                                    };
                                    KeyValue {
                                        key: _rt::string_lift(bytes69),
                                        value: v93,
                                    }
                                };
                                result94.push(e94);
                            }
                            _rt::cabi_dealloc(
                                base94,
                                len94 * (8 + 4 * ::core::mem::size_of::<*const u8>()),
                                8,
                            );
                            Event {
                                name: _rt::string_lift(bytes62),
                                time: super::super::super::super::wasi::clocks::wall_clock::Datetime {
                                    seconds: l63 as u64,
                                    nanoseconds: l64 as u32,
                                },
                                attributes: result94,
                            }
                        };
                        result95.push(e95);
                    }
                    _rt::cabi_dealloc(
                        base95,
                        len95 * (16 + 4 * ::core::mem::size_of::<*const u8>()),
                        8,
                    );
                    let l96 = *arg0
                        .add(32 + 16 * ::core::mem::size_of::<*const u8>())
                        .cast::<*mut u8>();
                    let l97 = *arg0
                        .add(32 + 17 * ::core::mem::size_of::<*const u8>())
                        .cast::<usize>();
                    let base145 = l96;
                    let len145 = l97;
                    let mut result145 = _rt::Vec::with_capacity(len145);
                    for i in 0..len145 {
                        let base = base145
                            .add(i * (9 * ::core::mem::size_of::<*const u8>()));
                        let e145 = {
                            let l98 = *base.add(0).cast::<*mut u8>();
                            let l99 = *base
                                .add(::core::mem::size_of::<*const u8>())
                                .cast::<usize>();
                            let len100 = l99;
                            let bytes100 = _rt::Vec::from_raw_parts(
                                l98.cast(),
                                len100,
                                len100,
                            );
                            let l101 = *base
                                .add(2 * ::core::mem::size_of::<*const u8>())
                                .cast::<*mut u8>();
                            let l102 = *base
                                .add(3 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>();
                            let len103 = l102;
                            let bytes103 = _rt::Vec::from_raw_parts(
                                l101.cast(),
                                len103,
                                len103,
                            );
                            let l104 = i32::from(
                                *base
                                    .add(4 * ::core::mem::size_of::<*const u8>())
                                    .cast::<u8>(),
                            );
                            let l105 = i32::from(
                                *base
                                    .add(1 + 4 * ::core::mem::size_of::<*const u8>())
                                    .cast::<u8>(),
                            );
                            let l106 = *base
                                .add(5 * ::core::mem::size_of::<*const u8>())
                                .cast::<*mut u8>();
                            let l107 = *base
                                .add(6 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>();
                            let base114 = l106;
                            let len114 = l107;
                            let mut result114 = _rt::Vec::with_capacity(len114);
                            for i in 0..len114 {
                                let base = base114
                                    .add(i * (4 * ::core::mem::size_of::<*const u8>()));
                                let e114 = {
                                    let l108 = *base.add(0).cast::<*mut u8>();
                                    let l109 = *base
                                        .add(::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    let len110 = l109;
                                    let bytes110 = _rt::Vec::from_raw_parts(
                                        l108.cast(),
                                        len110,
                                        len110,
                                    );
                                    let l111 = *base
                                        .add(2 * ::core::mem::size_of::<*const u8>())
                                        .cast::<*mut u8>();
                                    let l112 = *base
                                        .add(3 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    let len113 = l112;
                                    let bytes113 = _rt::Vec::from_raw_parts(
                                        l111.cast(),
                                        len113,
                                        len113,
                                    );
                                    (_rt::string_lift(bytes110), _rt::string_lift(bytes113))
                                };
                                result114.push(e114);
                            }
                            _rt::cabi_dealloc(
                                base114,
                                len114 * (4 * ::core::mem::size_of::<*const u8>()),
                                ::core::mem::size_of::<*const u8>(),
                            );
                            let l115 = *base
                                .add(7 * ::core::mem::size_of::<*const u8>())
                                .cast::<*mut u8>();
                            let l116 = *base
                                .add(8 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>();
                            let base144 = l115;
                            let len144 = l116;
                            let mut result144 = _rt::Vec::with_capacity(len144);
                            for i in 0..len144 {
                                let base = base144
                                    .add(i * (8 + 4 * ::core::mem::size_of::<*const u8>()));
                                let e144 = {
                                    let l117 = *base.add(0).cast::<*mut u8>();
                                    let l118 = *base
                                        .add(::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    let len119 = l118;
                                    let bytes119 = _rt::Vec::from_raw_parts(
                                        l117.cast(),
                                        len119,
                                        len119,
                                    );
                                    let l120 = i32::from(
                                        *base
                                            .add(2 * ::core::mem::size_of::<*const u8>())
                                            .cast::<u8>(),
                                    );
                                    let v143 = match l120 {
                                        0 => {
                                            let e143 = {
                                                let l121 = *base
                                                    .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<*mut u8>();
                                                let l122 = *base
                                                    .add(8 + 3 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<usize>();
                                                let len123 = l122;
                                                let bytes123 = _rt::Vec::from_raw_parts(
                                                    l121.cast(),
                                                    len123,
                                                    len123,
                                                );
                                                _rt::string_lift(bytes123)
                                            };
                                            Value::String(e143)
                                        }
                                        1 => {
                                            let e143 = {
                                                let l124 = i32::from(
                                                    *base
                                                        .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                        .cast::<u8>(),
                                                );
                                                _rt::bool_lift(l124 as u8)
                                            };
                                            Value::Bool(e143)
                                        }
                                        2 => {
                                            let e143 = {
                                                let l125 = *base
                                                    .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<f64>();
                                                l125
                                            };
                                            Value::F64(e143)
                                        }
                                        3 => {
                                            let e143 = {
                                                let l126 = *base
                                                    .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<i64>();
                                                l126
                                            };
                                            Value::S64(e143)
                                        }
                                        4 => {
                                            let e143 = {
                                                let l127 = *base
                                                    .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<*mut u8>();
                                                let l128 = *base
                                                    .add(8 + 3 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<usize>();
                                                let base132 = l127;
                                                let len132 = l128;
                                                let mut result132 = _rt::Vec::with_capacity(len132);
                                                for i in 0..len132 {
                                                    let base = base132
                                                        .add(i * (2 * ::core::mem::size_of::<*const u8>()));
                                                    let e132 = {
                                                        let l129 = *base.add(0).cast::<*mut u8>();
                                                        let l130 = *base
                                                            .add(::core::mem::size_of::<*const u8>())
                                                            .cast::<usize>();
                                                        let len131 = l130;
                                                        let bytes131 = _rt::Vec::from_raw_parts(
                                                            l129.cast(),
                                                            len131,
                                                            len131,
                                                        );
                                                        _rt::string_lift(bytes131)
                                                    };
                                                    result132.push(e132);
                                                }
                                                _rt::cabi_dealloc(
                                                    base132,
                                                    len132 * (2 * ::core::mem::size_of::<*const u8>()),
                                                    ::core::mem::size_of::<*const u8>(),
                                                );
                                                result132
                                            };
                                            Value::StringArray(e143)
                                        }
                                        5 => {
                                            let e143 = {
                                                let l133 = *base
                                                    .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<*mut u8>();
                                                let l134 = *base
                                                    .add(8 + 3 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<usize>();
                                                let base136 = l133;
                                                let len136 = l134;
                                                let mut result136 = _rt::Vec::with_capacity(len136);
                                                for i in 0..len136 {
                                                    let base = base136.add(i * 1);
                                                    let e136 = {
                                                        let l135 = i32::from(*base.add(0).cast::<u8>());
                                                        _rt::bool_lift(l135 as u8)
                                                    };
                                                    result136.push(e136);
                                                }
                                                _rt::cabi_dealloc(base136, len136 * 1, 1);
                                                result136
                                            };
                                            Value::BoolArray(e143)
                                        }
                                        6 => {
                                            let e143 = {
                                                let l137 = *base
                                                    .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<*mut u8>();
                                                let l138 = *base
                                                    .add(8 + 3 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<usize>();
                                                let len139 = l138;
                                                _rt::Vec::from_raw_parts(l137.cast(), len139, len139)
                                            };
                                            Value::F64Array(e143)
                                        }
                                        n => {
                                            debug_assert_eq!(n, 7, "invalid enum discriminant");
                                            let e143 = {
                                                let l140 = *base
                                                    .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<*mut u8>();
                                                let l141 = *base
                                                    .add(8 + 3 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<usize>();
                                                let len142 = l141;
                                                _rt::Vec::from_raw_parts(l140.cast(), len142, len142)
                                            };
                                            Value::S64Array(e143)
                                        }
                                    };
                                    KeyValue {
                                        key: _rt::string_lift(bytes119),
                                        value: v143,
                                    }
                                };
                                result144.push(e144);
                            }
                            _rt::cabi_dealloc(
                                base144,
                                len144 * (8 + 4 * ::core::mem::size_of::<*const u8>()),
                                8,
                            );
                            Link {
                                span_context: SpanContext {
                                    trace_id: _rt::string_lift(bytes100),
                                    span_id: _rt::string_lift(bytes103),
                                    trace_flags: TraceFlags::empty()
                                        | TraceFlags::from_bits_retain(((l104 as u8) << 0) as _),
                                    is_remote: _rt::bool_lift(l105 as u8),
                                    trace_state: result114,
                                },
                                attributes: result144,
                            }
                        };
                        result145.push(e145);
                    }
                    _rt::cabi_dealloc(
                        base145,
                        len145 * (9 * ::core::mem::size_of::<*const u8>()),
                        ::core::mem::size_of::<*const u8>(),
                    );
                    let l146 = i32::from(
                        *arg0
                            .add(32 + 18 * ::core::mem::size_of::<*const u8>())
                            .cast::<u8>(),
                    );
                    let v150 = match l146 {
                        0 => Status::Unset,
                        1 => Status::Ok,
                        n => {
                            debug_assert_eq!(n, 2, "invalid enum discriminant");
                            let e150 = {
                                let l147 = *arg0
                                    .add(32 + 19 * ::core::mem::size_of::<*const u8>())
                                    .cast::<*mut u8>();
                                let l148 = *arg0
                                    .add(32 + 20 * ::core::mem::size_of::<*const u8>())
                                    .cast::<usize>();
                                let len149 = l148;
                                let bytes149 = _rt::Vec::from_raw_parts(
                                    l147.cast(),
                                    len149,
                                    len149,
                                );
                                _rt::string_lift(bytes149)
                            };
                            Status::Error(e150)
                        }
                    };
                    let l151 = *arg0
                        .add(32 + 21 * ::core::mem::size_of::<*const u8>())
                        .cast::<*mut u8>();
                    let l152 = *arg0
                        .add(32 + 22 * ::core::mem::size_of::<*const u8>())
                        .cast::<usize>();
                    let len153 = l152;
                    let bytes153 = _rt::Vec::from_raw_parts(l151.cast(), len153, len153);
                    let l154 = i32::from(
                        *arg0
                            .add(32 + 23 * ::core::mem::size_of::<*const u8>())
                            .cast::<u8>(),
                    );
                    let l158 = i32::from(
                        *arg0
                            .add(32 + 26 * ::core::mem::size_of::<*const u8>())
                            .cast::<u8>(),
                    );
                    let l162 = *arg0
                        .add(32 + 29 * ::core::mem::size_of::<*const u8>())
                        .cast::<*mut u8>();
                    let l163 = *arg0
                        .add(32 + 30 * ::core::mem::size_of::<*const u8>())
                        .cast::<usize>();
                    let base191 = l162;
                    let len191 = l163;
                    let mut result191 = _rt::Vec::with_capacity(len191);
                    for i in 0..len191 {
                        let base = base191
                            .add(i * (8 + 4 * ::core::mem::size_of::<*const u8>()));
                        let e191 = {
                            let l164 = *base.add(0).cast::<*mut u8>();
                            let l165 = *base
                                .add(::core::mem::size_of::<*const u8>())
                                .cast::<usize>();
                            let len166 = l165;
                            let bytes166 = _rt::Vec::from_raw_parts(
                                l164.cast(),
                                len166,
                                len166,
                            );
                            let l167 = i32::from(
                                *base
                                    .add(2 * ::core::mem::size_of::<*const u8>())
                                    .cast::<u8>(),
                            );
                            let v190 = match l167 {
                                0 => {
                                    let e190 = {
                                        let l168 = *base
                                            .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                            .cast::<*mut u8>();
                                        let l169 = *base
                                            .add(8 + 3 * ::core::mem::size_of::<*const u8>())
                                            .cast::<usize>();
                                        let len170 = l169;
                                        let bytes170 = _rt::Vec::from_raw_parts(
                                            l168.cast(),
                                            len170,
                                            len170,
                                        );
                                        _rt::string_lift(bytes170)
                                    };
                                    Value::String(e190)
                                }
                                1 => {
                                    let e190 = {
                                        let l171 = i32::from(
                                            *base
                                                .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                .cast::<u8>(),
                                        );
                                        _rt::bool_lift(l171 as u8)
                                    };
                                    Value::Bool(e190)
                                }
                                2 => {
                                    let e190 = {
                                        let l172 = *base
                                            .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                            .cast::<f64>();
                                        l172
                                    };
                                    Value::F64(e190)
                                }
                                3 => {
                                    let e190 = {
                                        let l173 = *base
                                            .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                            .cast::<i64>();
                                        l173
                                    };
                                    Value::S64(e190)
                                }
                                4 => {
                                    let e190 = {
                                        let l174 = *base
                                            .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                            .cast::<*mut u8>();
                                        let l175 = *base
                                            .add(8 + 3 * ::core::mem::size_of::<*const u8>())
                                            .cast::<usize>();
                                        let base179 = l174;
                                        let len179 = l175;
                                        let mut result179 = _rt::Vec::with_capacity(len179);
                                        for i in 0..len179 {
                                            let base = base179
                                                .add(i * (2 * ::core::mem::size_of::<*const u8>()));
                                            let e179 = {
                                                let l176 = *base.add(0).cast::<*mut u8>();
                                                let l177 = *base
                                                    .add(::core::mem::size_of::<*const u8>())
                                                    .cast::<usize>();
                                                let len178 = l177;
                                                let bytes178 = _rt::Vec::from_raw_parts(
                                                    l176.cast(),
                                                    len178,
                                                    len178,
                                                );
                                                _rt::string_lift(bytes178)
                                            };
                                            result179.push(e179);
                                        }
                                        _rt::cabi_dealloc(
                                            base179,
                                            len179 * (2 * ::core::mem::size_of::<*const u8>()),
                                            ::core::mem::size_of::<*const u8>(),
                                        );
                                        result179
                                    };
                                    Value::StringArray(e190)
                                }
                                5 => {
                                    let e190 = {
                                        let l180 = *base
                                            .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                            .cast::<*mut u8>();
                                        let l181 = *base
                                            .add(8 + 3 * ::core::mem::size_of::<*const u8>())
                                            .cast::<usize>();
                                        let base183 = l180;
                                        let len183 = l181;
                                        let mut result183 = _rt::Vec::with_capacity(len183);
                                        for i in 0..len183 {
                                            let base = base183.add(i * 1);
                                            let e183 = {
                                                let l182 = i32::from(*base.add(0).cast::<u8>());
                                                _rt::bool_lift(l182 as u8)
                                            };
                                            result183.push(e183);
                                        }
                                        _rt::cabi_dealloc(base183, len183 * 1, 1);
                                        result183
                                    };
                                    Value::BoolArray(e190)
                                }
                                6 => {
                                    let e190 = {
                                        let l184 = *base
                                            .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                            .cast::<*mut u8>();
                                        let l185 = *base
                                            .add(8 + 3 * ::core::mem::size_of::<*const u8>())
                                            .cast::<usize>();
                                        let len186 = l185;
                                        _rt::Vec::from_raw_parts(l184.cast(), len186, len186)
                                    };
                                    Value::F64Array(e190)
                                }
                                n => {
                                    debug_assert_eq!(n, 7, "invalid enum discriminant");
                                    let e190 = {
                                        let l187 = *base
                                            .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                            .cast::<*mut u8>();
                                        let l188 = *base
                                            .add(8 + 3 * ::core::mem::size_of::<*const u8>())
                                            .cast::<usize>();
                                        let len189 = l188;
                                        _rt::Vec::from_raw_parts(l187.cast(), len189, len189)
                                    };
                                    Value::S64Array(e190)
                                }
                            };
                            KeyValue {
                                key: _rt::string_lift(bytes166),
                                value: v190,
                            }
                        };
                        result191.push(e191);
                    }
                    _rt::cabi_dealloc(
                        base191,
                        len191 * (8 + 4 * ::core::mem::size_of::<*const u8>()),
                        8,
                    );
                    let l192 = *arg0
                        .add(32 + 31 * ::core::mem::size_of::<*const u8>())
                        .cast::<i32>();
                    let l193 = *arg0
                        .add(36 + 31 * ::core::mem::size_of::<*const u8>())
                        .cast::<i32>();
                    let l194 = *arg0
                        .add(40 + 31 * ::core::mem::size_of::<*const u8>())
                        .cast::<i32>();
                    let l195 = *arg0
                        .add(40 + 32 * ::core::mem::size_of::<*const u8>())
                        .cast::<*mut u8>();
                    let l196 = *arg0
                        .add(40 + 33 * ::core::mem::size_of::<*const u8>())
                        .cast::<usize>();
                    let len197 = l196;
                    let bytes197 = _rt::Vec::from_raw_parts(l195.cast(), len197, len197);
                    let l198 = *arg0
                        .add(40 + 34 * ::core::mem::size_of::<*const u8>())
                        .cast::<*mut u8>();
                    let l199 = *arg0
                        .add(40 + 35 * ::core::mem::size_of::<*const u8>())
                        .cast::<usize>();
                    let len200 = l199;
                    let bytes200 = _rt::Vec::from_raw_parts(l198.cast(), len200, len200);
                    let l201 = i32::from(
                        *arg0
                            .add(40 + 36 * ::core::mem::size_of::<*const u8>())
                            .cast::<u8>(),
                    );
                    let l202 = i32::from(
                        *arg0
                            .add(41 + 36 * ::core::mem::size_of::<*const u8>())
                            .cast::<u8>(),
                    );
                    let l203 = *arg0
                        .add(40 + 37 * ::core::mem::size_of::<*const u8>())
                        .cast::<*mut u8>();
                    let l204 = *arg0
                        .add(40 + 38 * ::core::mem::size_of::<*const u8>())
                        .cast::<usize>();
                    let base211 = l203;
                    let len211 = l204;
                    let mut result211 = _rt::Vec::with_capacity(len211);
                    for i in 0..len211 {
                        let base = base211
                            .add(i * (4 * ::core::mem::size_of::<*const u8>()));
                        let e211 = {
                            let l205 = *base.add(0).cast::<*mut u8>();
                            let l206 = *base
                                .add(::core::mem::size_of::<*const u8>())
                                .cast::<usize>();
                            let len207 = l206;
                            let bytes207 = _rt::Vec::from_raw_parts(
                                l205.cast(),
                                len207,
                                len207,
                            );
                            let l208 = *base
                                .add(2 * ::core::mem::size_of::<*const u8>())
                                .cast::<*mut u8>();
                            let l209 = *base
                                .add(3 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>();
                            let len210 = l209;
                            let bytes210 = _rt::Vec::from_raw_parts(
                                l208.cast(),
                                len210,
                                len210,
                            );
                            (_rt::string_lift(bytes207), _rt::string_lift(bytes210))
                        };
                        result211.push(e211);
                    }
                    _rt::cabi_dealloc(
                        base211,
                        len211 * (4 * ::core::mem::size_of::<*const u8>()),
                        ::core::mem::size_of::<*const u8>(),
                    );
                    T::on_start(
                        SpanData {
                            span_context: SpanContext {
                                trace_id: _rt::string_lift(bytes2),
                                span_id: _rt::string_lift(bytes5),
                                trace_flags: TraceFlags::empty()
                                    | TraceFlags::from_bits_retain(((l6 as u8) << 0) as _),
                                is_remote: _rt::bool_lift(l7 as u8),
                                trace_state: result16,
                            },
                            parent_span_id: _rt::string_lift(bytes19),
                            span_kind: SpanKind::_lift(l20 as u8),
                            name: _rt::string_lift(bytes23),
                            start_time: super::super::super::super::wasi::clocks::wall_clock::Datetime {
                                seconds: l24 as u64,
                                nanoseconds: l25 as u32,
                            },
                            end_time: super::super::super::super::wasi::clocks::wall_clock::Datetime {
                                seconds: l26 as u64,
                                nanoseconds: l27 as u32,
                            },
                            attributes: result57,
                            events: result95,
                            links: result145,
                            status: v150,
                            instrumentation_scope: InstrumentationScope {
                                name: _rt::string_lift(bytes153),
                                version: match l154 {
                                    0 => None,
                                    1 => {
                                        let e = {
                                            let l155 = *arg0
                                                .add(32 + 24 * ::core::mem::size_of::<*const u8>())
                                                .cast::<*mut u8>();
                                            let l156 = *arg0
                                                .add(32 + 25 * ::core::mem::size_of::<*const u8>())
                                                .cast::<usize>();
                                            let len157 = l156;
                                            let bytes157 = _rt::Vec::from_raw_parts(
                                                l155.cast(),
                                                len157,
                                                len157,
                                            );
                                            _rt::string_lift(bytes157)
                                        };
                                        Some(e)
                                    }
                                    _ => _rt::invalid_enum_discriminant(),
                                },
                                schema_url: match l158 {
                                    0 => None,
                                    1 => {
                                        let e = {
                                            let l159 = *arg0
                                                .add(32 + 27 * ::core::mem::size_of::<*const u8>())
                                                .cast::<*mut u8>();
                                            let l160 = *arg0
                                                .add(32 + 28 * ::core::mem::size_of::<*const u8>())
                                                .cast::<usize>();
                                            let len161 = l160;
                                            let bytes161 = _rt::Vec::from_raw_parts(
                                                l159.cast(),
                                                len161,
                                                len161,
                                            );
                                            _rt::string_lift(bytes161)
                                        };
                                        Some(e)
                                    }
                                    _ => _rt::invalid_enum_discriminant(),
                                },
                                attributes: result191,
                            },
                            dropped_attributes: l192 as u32,
                            dropped_events: l193 as u32,
                            dropped_links: l194 as u32,
                        },
                        SpanContext {
                            trace_id: _rt::string_lift(bytes197),
                            span_id: _rt::string_lift(bytes200),
                            trace_flags: TraceFlags::empty()
                                | TraceFlags::from_bits_retain(((l201 as u8) << 0) as _),
                            is_remote: _rt::bool_lift(l202 as u8),
                            trace_state: result211,
                        },
                    );
                    _rt::cabi_dealloc(
                        arg0,
                        48 + 38 * ::core::mem::size_of::<*const u8>(),
                        8,
                    );
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_on_end_cabi<T: Guest>(arg0: *mut u8) {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let l0 = *arg0.add(0).cast::<*mut u8>();
                    let l1 = *arg0
                        .add(::core::mem::size_of::<*const u8>())
                        .cast::<usize>();
                    let len2 = l1;
                    let bytes2 = _rt::Vec::from_raw_parts(l0.cast(), len2, len2);
                    let l3 = *arg0
                        .add(2 * ::core::mem::size_of::<*const u8>())
                        .cast::<*mut u8>();
                    let l4 = *arg0
                        .add(3 * ::core::mem::size_of::<*const u8>())
                        .cast::<usize>();
                    let len5 = l4;
                    let bytes5 = _rt::Vec::from_raw_parts(l3.cast(), len5, len5);
                    let l6 = i32::from(
                        *arg0.add(4 * ::core::mem::size_of::<*const u8>()).cast::<u8>(),
                    );
                    let l7 = i32::from(
                        *arg0
                            .add(1 + 4 * ::core::mem::size_of::<*const u8>())
                            .cast::<u8>(),
                    );
                    let l8 = *arg0
                        .add(5 * ::core::mem::size_of::<*const u8>())
                        .cast::<*mut u8>();
                    let l9 = *arg0
                        .add(6 * ::core::mem::size_of::<*const u8>())
                        .cast::<usize>();
                    let base16 = l8;
                    let len16 = l9;
                    let mut result16 = _rt::Vec::with_capacity(len16);
                    for i in 0..len16 {
                        let base = base16
                            .add(i * (4 * ::core::mem::size_of::<*const u8>()));
                        let e16 = {
                            let l10 = *base.add(0).cast::<*mut u8>();
                            let l11 = *base
                                .add(::core::mem::size_of::<*const u8>())
                                .cast::<usize>();
                            let len12 = l11;
                            let bytes12 = _rt::Vec::from_raw_parts(
                                l10.cast(),
                                len12,
                                len12,
                            );
                            let l13 = *base
                                .add(2 * ::core::mem::size_of::<*const u8>())
                                .cast::<*mut u8>();
                            let l14 = *base
                                .add(3 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>();
                            let len15 = l14;
                            let bytes15 = _rt::Vec::from_raw_parts(
                                l13.cast(),
                                len15,
                                len15,
                            );
                            (_rt::string_lift(bytes12), _rt::string_lift(bytes15))
                        };
                        result16.push(e16);
                    }
                    _rt::cabi_dealloc(
                        base16,
                        len16 * (4 * ::core::mem::size_of::<*const u8>()),
                        ::core::mem::size_of::<*const u8>(),
                    );
                    let l17 = *arg0
                        .add(7 * ::core::mem::size_of::<*const u8>())
                        .cast::<*mut u8>();
                    let l18 = *arg0
                        .add(8 * ::core::mem::size_of::<*const u8>())
                        .cast::<usize>();
                    let len19 = l18;
                    let bytes19 = _rt::Vec::from_raw_parts(l17.cast(), len19, len19);
                    let l20 = i32::from(
                        *arg0.add(9 * ::core::mem::size_of::<*const u8>()).cast::<u8>(),
                    );
                    let l21 = *arg0
                        .add(10 * ::core::mem::size_of::<*const u8>())
                        .cast::<*mut u8>();
                    let l22 = *arg0
                        .add(11 * ::core::mem::size_of::<*const u8>())
                        .cast::<usize>();
                    let len23 = l22;
                    let bytes23 = _rt::Vec::from_raw_parts(l21.cast(), len23, len23);
                    let l24 = *arg0
                        .add(12 * ::core::mem::size_of::<*const u8>())
                        .cast::<i64>();
                    let l25 = *arg0
                        .add(8 + 12 * ::core::mem::size_of::<*const u8>())
                        .cast::<i32>();
                    let l26 = *arg0
                        .add(16 + 12 * ::core::mem::size_of::<*const u8>())
                        .cast::<i64>();
                    let l27 = *arg0
                        .add(24 + 12 * ::core::mem::size_of::<*const u8>())
                        .cast::<i32>();
                    let l28 = *arg0
                        .add(32 + 12 * ::core::mem::size_of::<*const u8>())
                        .cast::<*mut u8>();
                    let l29 = *arg0
                        .add(32 + 13 * ::core::mem::size_of::<*const u8>())
                        .cast::<usize>();
                    let base57 = l28;
                    let len57 = l29;
                    let mut result57 = _rt::Vec::with_capacity(len57);
                    for i in 0..len57 {
                        let base = base57
                            .add(i * (8 + 4 * ::core::mem::size_of::<*const u8>()));
                        let e57 = {
                            let l30 = *base.add(0).cast::<*mut u8>();
                            let l31 = *base
                                .add(::core::mem::size_of::<*const u8>())
                                .cast::<usize>();
                            let len32 = l31;
                            let bytes32 = _rt::Vec::from_raw_parts(
                                l30.cast(),
                                len32,
                                len32,
                            );
                            let l33 = i32::from(
                                *base
                                    .add(2 * ::core::mem::size_of::<*const u8>())
                                    .cast::<u8>(),
                            );
                            let v56 = match l33 {
                                0 => {
                                    let e56 = {
                                        let l34 = *base
                                            .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                            .cast::<*mut u8>();
                                        let l35 = *base
                                            .add(8 + 3 * ::core::mem::size_of::<*const u8>())
                                            .cast::<usize>();
                                        let len36 = l35;
                                        let bytes36 = _rt::Vec::from_raw_parts(
                                            l34.cast(),
                                            len36,
                                            len36,
                                        );
                                        _rt::string_lift(bytes36)
                                    };
                                    Value::String(e56)
                                }
                                1 => {
                                    let e56 = {
                                        let l37 = i32::from(
                                            *base
                                                .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                .cast::<u8>(),
                                        );
                                        _rt::bool_lift(l37 as u8)
                                    };
                                    Value::Bool(e56)
                                }
                                2 => {
                                    let e56 = {
                                        let l38 = *base
                                            .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                            .cast::<f64>();
                                        l38
                                    };
                                    Value::F64(e56)
                                }
                                3 => {
                                    let e56 = {
                                        let l39 = *base
                                            .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                            .cast::<i64>();
                                        l39
                                    };
                                    Value::S64(e56)
                                }
                                4 => {
                                    let e56 = {
                                        let l40 = *base
                                            .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                            .cast::<*mut u8>();
                                        let l41 = *base
                                            .add(8 + 3 * ::core::mem::size_of::<*const u8>())
                                            .cast::<usize>();
                                        let base45 = l40;
                                        let len45 = l41;
                                        let mut result45 = _rt::Vec::with_capacity(len45);
                                        for i in 0..len45 {
                                            let base = base45
                                                .add(i * (2 * ::core::mem::size_of::<*const u8>()));
                                            let e45 = {
                                                let l42 = *base.add(0).cast::<*mut u8>();
                                                let l43 = *base
                                                    .add(::core::mem::size_of::<*const u8>())
                                                    .cast::<usize>();
                                                let len44 = l43;
                                                let bytes44 = _rt::Vec::from_raw_parts(
                                                    l42.cast(),
                                                    len44,
                                                    len44,
                                                );
                                                _rt::string_lift(bytes44)
                                            };
                                            result45.push(e45);
                                        }
                                        _rt::cabi_dealloc(
                                            base45,
                                            len45 * (2 * ::core::mem::size_of::<*const u8>()),
                                            ::core::mem::size_of::<*const u8>(),
                                        );
                                        result45
                                    };
                                    Value::StringArray(e56)
                                }
                                5 => {
                                    let e56 = {
                                        let l46 = *base
                                            .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                            .cast::<*mut u8>();
                                        let l47 = *base
                                            .add(8 + 3 * ::core::mem::size_of::<*const u8>())
                                            .cast::<usize>();
                                        let base49 = l46;
                                        let len49 = l47;
                                        let mut result49 = _rt::Vec::with_capacity(len49);
                                        for i in 0..len49 {
                                            let base = base49.add(i * 1);
                                            let e49 = {
                                                let l48 = i32::from(*base.add(0).cast::<u8>());
                                                _rt::bool_lift(l48 as u8)
                                            };
                                            result49.push(e49);
                                        }
                                        _rt::cabi_dealloc(base49, len49 * 1, 1);
                                        result49
                                    };
                                    Value::BoolArray(e56)
                                }
                                6 => {
                                    let e56 = {
                                        let l50 = *base
                                            .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                            .cast::<*mut u8>();
                                        let l51 = *base
                                            .add(8 + 3 * ::core::mem::size_of::<*const u8>())
                                            .cast::<usize>();
                                        let len52 = l51;
                                        _rt::Vec::from_raw_parts(l50.cast(), len52, len52)
                                    };
                                    Value::F64Array(e56)
                                }
                                n => {
                                    debug_assert_eq!(n, 7, "invalid enum discriminant");
                                    let e56 = {
                                        let l53 = *base
                                            .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                            .cast::<*mut u8>();
                                        let l54 = *base
                                            .add(8 + 3 * ::core::mem::size_of::<*const u8>())
                                            .cast::<usize>();
                                        let len55 = l54;
                                        _rt::Vec::from_raw_parts(l53.cast(), len55, len55)
                                    };
                                    Value::S64Array(e56)
                                }
                            };
                            KeyValue {
                                key: _rt::string_lift(bytes32),
                                value: v56,
                            }
                        };
                        result57.push(e57);
                    }
                    _rt::cabi_dealloc(
                        base57,
                        len57 * (8 + 4 * ::core::mem::size_of::<*const u8>()),
                        8,
                    );
                    let l58 = *arg0
                        .add(32 + 14 * ::core::mem::size_of::<*const u8>())
                        .cast::<*mut u8>();
                    let l59 = *arg0
                        .add(32 + 15 * ::core::mem::size_of::<*const u8>())
                        .cast::<usize>();
                    let base95 = l58;
                    let len95 = l59;
                    let mut result95 = _rt::Vec::with_capacity(len95);
                    for i in 0..len95 {
                        let base = base95
                            .add(i * (16 + 4 * ::core::mem::size_of::<*const u8>()));
                        let e95 = {
                            let l60 = *base.add(0).cast::<*mut u8>();
                            let l61 = *base
                                .add(::core::mem::size_of::<*const u8>())
                                .cast::<usize>();
                            let len62 = l61;
                            let bytes62 = _rt::Vec::from_raw_parts(
                                l60.cast(),
                                len62,
                                len62,
                            );
                            let l63 = *base
                                .add(2 * ::core::mem::size_of::<*const u8>())
                                .cast::<i64>();
                            let l64 = *base
                                .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                .cast::<i32>();
                            let l65 = *base
                                .add(16 + 2 * ::core::mem::size_of::<*const u8>())
                                .cast::<*mut u8>();
                            let l66 = *base
                                .add(16 + 3 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>();
                            let base94 = l65;
                            let len94 = l66;
                            let mut result94 = _rt::Vec::with_capacity(len94);
                            for i in 0..len94 {
                                let base = base94
                                    .add(i * (8 + 4 * ::core::mem::size_of::<*const u8>()));
                                let e94 = {
                                    let l67 = *base.add(0).cast::<*mut u8>();
                                    let l68 = *base
                                        .add(::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    let len69 = l68;
                                    let bytes69 = _rt::Vec::from_raw_parts(
                                        l67.cast(),
                                        len69,
                                        len69,
                                    );
                                    let l70 = i32::from(
                                        *base
                                            .add(2 * ::core::mem::size_of::<*const u8>())
                                            .cast::<u8>(),
                                    );
                                    let v93 = match l70 {
                                        0 => {
                                            let e93 = {
                                                let l71 = *base
                                                    .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<*mut u8>();
                                                let l72 = *base
                                                    .add(8 + 3 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<usize>();
                                                let len73 = l72;
                                                let bytes73 = _rt::Vec::from_raw_parts(
                                                    l71.cast(),
                                                    len73,
                                                    len73,
                                                );
                                                _rt::string_lift(bytes73)
                                            };
                                            Value::String(e93)
                                        }
                                        1 => {
                                            let e93 = {
                                                let l74 = i32::from(
                                                    *base
                                                        .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                        .cast::<u8>(),
                                                );
                                                _rt::bool_lift(l74 as u8)
                                            };
                                            Value::Bool(e93)
                                        }
                                        2 => {
                                            let e93 = {
                                                let l75 = *base
                                                    .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<f64>();
                                                l75
                                            };
                                            Value::F64(e93)
                                        }
                                        3 => {
                                            let e93 = {
                                                let l76 = *base
                                                    .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<i64>();
                                                l76
                                            };
                                            Value::S64(e93)
                                        }
                                        4 => {
                                            let e93 = {
                                                let l77 = *base
                                                    .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<*mut u8>();
                                                let l78 = *base
                                                    .add(8 + 3 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<usize>();
                                                let base82 = l77;
                                                let len82 = l78;
                                                let mut result82 = _rt::Vec::with_capacity(len82);
                                                for i in 0..len82 {
                                                    let base = base82
                                                        .add(i * (2 * ::core::mem::size_of::<*const u8>()));
                                                    let e82 = {
                                                        let l79 = *base.add(0).cast::<*mut u8>();
                                                        let l80 = *base
                                                            .add(::core::mem::size_of::<*const u8>())
                                                            .cast::<usize>();
                                                        let len81 = l80;
                                                        let bytes81 = _rt::Vec::from_raw_parts(
                                                            l79.cast(),
                                                            len81,
                                                            len81,
                                                        );
                                                        _rt::string_lift(bytes81)
                                                    };
                                                    result82.push(e82);
                                                }
                                                _rt::cabi_dealloc(
                                                    base82,
                                                    len82 * (2 * ::core::mem::size_of::<*const u8>()),
                                                    ::core::mem::size_of::<*const u8>(),
                                                );
                                                result82
                                            };
                                            Value::StringArray(e93)
                                        }
                                        5 => {
                                            let e93 = {
                                                let l83 = *base
                                                    .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<*mut u8>();
                                                let l84 = *base
                                                    .add(8 + 3 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<usize>();
                                                let base86 = l83;
                                                let len86 = l84;
                                                let mut result86 = _rt::Vec::with_capacity(len86);
                                                for i in 0..len86 {
                                                    let base = base86.add(i * 1);
                                                    let e86 = {
                                                        let l85 = i32::from(*base.add(0).cast::<u8>());
                                                        _rt::bool_lift(l85 as u8)
                                                    };
                                                    result86.push(e86);
                                                }
                                                _rt::cabi_dealloc(base86, len86 * 1, 1);
                                                result86
                                            };
                                            Value::BoolArray(e93)
                                        }
                                        6 => {
                                            let e93 = {
                                                let l87 = *base
                                                    .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<*mut u8>();
                                                let l88 = *base
                                                    .add(8 + 3 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<usize>();
                                                let len89 = l88;
                                                _rt::Vec::from_raw_parts(l87.cast(), len89, len89)
                                            };
                                            Value::F64Array(e93)
                                        }
                                        n => {
                                            debug_assert_eq!(n, 7, "invalid enum discriminant");
                                            let e93 = {
                                                let l90 = *base
                                                    .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<*mut u8>();
                                                let l91 = *base
                                                    .add(8 + 3 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<usize>();
                                                let len92 = l91;
                                                _rt::Vec::from_raw_parts(l90.cast(), len92, len92)
                                            };
                                            Value::S64Array(e93)
                                        }
                                    };
                                    KeyValue {
                                        key: _rt::string_lift(bytes69),
                                        value: v93,
                                    }
                                };
                                result94.push(e94);
                            }
                            _rt::cabi_dealloc(
                                base94,
                                len94 * (8 + 4 * ::core::mem::size_of::<*const u8>()),
                                8,
                            );
                            Event {
                                name: _rt::string_lift(bytes62),
                                time: super::super::super::super::wasi::clocks::wall_clock::Datetime {
                                    seconds: l63 as u64,
                                    nanoseconds: l64 as u32,
                                },
                                attributes: result94,
                            }
                        };
                        result95.push(e95);
                    }
                    _rt::cabi_dealloc(
                        base95,
                        len95 * (16 + 4 * ::core::mem::size_of::<*const u8>()),
                        8,
                    );
                    let l96 = *arg0
                        .add(32 + 16 * ::core::mem::size_of::<*const u8>())
                        .cast::<*mut u8>();
                    let l97 = *arg0
                        .add(32 + 17 * ::core::mem::size_of::<*const u8>())
                        .cast::<usize>();
                    let base145 = l96;
                    let len145 = l97;
                    let mut result145 = _rt::Vec::with_capacity(len145);
                    for i in 0..len145 {
                        let base = base145
                            .add(i * (9 * ::core::mem::size_of::<*const u8>()));
                        let e145 = {
                            let l98 = *base.add(0).cast::<*mut u8>();
                            let l99 = *base
                                .add(::core::mem::size_of::<*const u8>())
                                .cast::<usize>();
                            let len100 = l99;
                            let bytes100 = _rt::Vec::from_raw_parts(
                                l98.cast(),
                                len100,
                                len100,
                            );
                            let l101 = *base
                                .add(2 * ::core::mem::size_of::<*const u8>())
                                .cast::<*mut u8>();
                            let l102 = *base
                                .add(3 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>();
                            let len103 = l102;
                            let bytes103 = _rt::Vec::from_raw_parts(
                                l101.cast(),
                                len103,
                                len103,
                            );
                            let l104 = i32::from(
                                *base
                                    .add(4 * ::core::mem::size_of::<*const u8>())
                                    .cast::<u8>(),
                            );
                            let l105 = i32::from(
                                *base
                                    .add(1 + 4 * ::core::mem::size_of::<*const u8>())
                                    .cast::<u8>(),
                            );
                            let l106 = *base
                                .add(5 * ::core::mem::size_of::<*const u8>())
                                .cast::<*mut u8>();
                            let l107 = *base
                                .add(6 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>();
                            let base114 = l106;
                            let len114 = l107;
                            let mut result114 = _rt::Vec::with_capacity(len114);
                            for i in 0..len114 {
                                let base = base114
                                    .add(i * (4 * ::core::mem::size_of::<*const u8>()));
                                let e114 = {
                                    let l108 = *base.add(0).cast::<*mut u8>();
                                    let l109 = *base
                                        .add(::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    let len110 = l109;
                                    let bytes110 = _rt::Vec::from_raw_parts(
                                        l108.cast(),
                                        len110,
                                        len110,
                                    );
                                    let l111 = *base
                                        .add(2 * ::core::mem::size_of::<*const u8>())
                                        .cast::<*mut u8>();
                                    let l112 = *base
                                        .add(3 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    let len113 = l112;
                                    let bytes113 = _rt::Vec::from_raw_parts(
                                        l111.cast(),
                                        len113,
                                        len113,
                                    );
                                    (_rt::string_lift(bytes110), _rt::string_lift(bytes113))
                                };
                                result114.push(e114);
                            }
                            _rt::cabi_dealloc(
                                base114,
                                len114 * (4 * ::core::mem::size_of::<*const u8>()),
                                ::core::mem::size_of::<*const u8>(),
                            );
                            let l115 = *base
                                .add(7 * ::core::mem::size_of::<*const u8>())
                                .cast::<*mut u8>();
                            let l116 = *base
                                .add(8 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>();
                            let base144 = l115;
                            let len144 = l116;
                            let mut result144 = _rt::Vec::with_capacity(len144);
                            for i in 0..len144 {
                                let base = base144
                                    .add(i * (8 + 4 * ::core::mem::size_of::<*const u8>()));
                                let e144 = {
                                    let l117 = *base.add(0).cast::<*mut u8>();
                                    let l118 = *base
                                        .add(::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    let len119 = l118;
                                    let bytes119 = _rt::Vec::from_raw_parts(
                                        l117.cast(),
                                        len119,
                                        len119,
                                    );
                                    let l120 = i32::from(
                                        *base
                                            .add(2 * ::core::mem::size_of::<*const u8>())
                                            .cast::<u8>(),
                                    );
                                    let v143 = match l120 {
                                        0 => {
                                            let e143 = {
                                                let l121 = *base
                                                    .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<*mut u8>();
                                                let l122 = *base
                                                    .add(8 + 3 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<usize>();
                                                let len123 = l122;
                                                let bytes123 = _rt::Vec::from_raw_parts(
                                                    l121.cast(),
                                                    len123,
                                                    len123,
                                                );
                                                _rt::string_lift(bytes123)
                                            };
                                            Value::String(e143)
                                        }
                                        1 => {
                                            let e143 = {
                                                let l124 = i32::from(
                                                    *base
                                                        .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                        .cast::<u8>(),
                                                );
                                                _rt::bool_lift(l124 as u8)
                                            };
                                            Value::Bool(e143)
                                        }
                                        2 => {
                                            let e143 = {
                                                let l125 = *base
                                                    .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<f64>();
                                                l125
                                            };
                                            Value::F64(e143)
                                        }
                                        3 => {
                                            let e143 = {
                                                let l126 = *base
                                                    .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<i64>();
                                                l126
                                            };
                                            Value::S64(e143)
                                        }
                                        4 => {
                                            let e143 = {
                                                let l127 = *base
                                                    .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<*mut u8>();
                                                let l128 = *base
                                                    .add(8 + 3 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<usize>();
                                                let base132 = l127;
                                                let len132 = l128;
                                                let mut result132 = _rt::Vec::with_capacity(len132);
                                                for i in 0..len132 {
                                                    let base = base132
                                                        .add(i * (2 * ::core::mem::size_of::<*const u8>()));
                                                    let e132 = {
                                                        let l129 = *base.add(0).cast::<*mut u8>();
                                                        let l130 = *base
                                                            .add(::core::mem::size_of::<*const u8>())
                                                            .cast::<usize>();
                                                        let len131 = l130;
                                                        let bytes131 = _rt::Vec::from_raw_parts(
                                                            l129.cast(),
                                                            len131,
                                                            len131,
                                                        );
                                                        _rt::string_lift(bytes131)
                                                    };
                                                    result132.push(e132);
                                                }
                                                _rt::cabi_dealloc(
                                                    base132,
                                                    len132 * (2 * ::core::mem::size_of::<*const u8>()),
                                                    ::core::mem::size_of::<*const u8>(),
                                                );
                                                result132
                                            };
                                            Value::StringArray(e143)
                                        }
                                        5 => {
                                            let e143 = {
                                                let l133 = *base
                                                    .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<*mut u8>();
                                                let l134 = *base
                                                    .add(8 + 3 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<usize>();
                                                let base136 = l133;
                                                let len136 = l134;
                                                let mut result136 = _rt::Vec::with_capacity(len136);
                                                for i in 0..len136 {
                                                    let base = base136.add(i * 1);
                                                    let e136 = {
                                                        let l135 = i32::from(*base.add(0).cast::<u8>());
                                                        _rt::bool_lift(l135 as u8)
                                                    };
                                                    result136.push(e136);
                                                }
                                                _rt::cabi_dealloc(base136, len136 * 1, 1);
                                                result136
                                            };
                                            Value::BoolArray(e143)
                                        }
                                        6 => {
                                            let e143 = {
                                                let l137 = *base
                                                    .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<*mut u8>();
                                                let l138 = *base
                                                    .add(8 + 3 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<usize>();
                                                let len139 = l138;
                                                _rt::Vec::from_raw_parts(l137.cast(), len139, len139)
                                            };
                                            Value::F64Array(e143)
                                        }
                                        n => {
                                            debug_assert_eq!(n, 7, "invalid enum discriminant");
                                            let e143 = {
                                                let l140 = *base
                                                    .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<*mut u8>();
                                                let l141 = *base
                                                    .add(8 + 3 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<usize>();
                                                let len142 = l141;
                                                _rt::Vec::from_raw_parts(l140.cast(), len142, len142)
                                            };
                                            Value::S64Array(e143)
                                        }
                                    };
                                    KeyValue {
                                        key: _rt::string_lift(bytes119),
                                        value: v143,
                                    }
                                };
                                result144.push(e144);
                            }
                            _rt::cabi_dealloc(
                                base144,
                                len144 * (8 + 4 * ::core::mem::size_of::<*const u8>()),
                                8,
                            );
                            Link {
                                span_context: SpanContext {
                                    trace_id: _rt::string_lift(bytes100),
                                    span_id: _rt::string_lift(bytes103),
                                    trace_flags: TraceFlags::empty()
                                        | TraceFlags::from_bits_retain(((l104 as u8) << 0) as _),
                                    is_remote: _rt::bool_lift(l105 as u8),
                                    trace_state: result114,
                                },
                                attributes: result144,
                            }
                        };
                        result145.push(e145);
                    }
                    _rt::cabi_dealloc(
                        base145,
                        len145 * (9 * ::core::mem::size_of::<*const u8>()),
                        ::core::mem::size_of::<*const u8>(),
                    );
                    let l146 = i32::from(
                        *arg0
                            .add(32 + 18 * ::core::mem::size_of::<*const u8>())
                            .cast::<u8>(),
                    );
                    let v150 = match l146 {
                        0 => Status::Unset,
                        1 => Status::Ok,
                        n => {
                            debug_assert_eq!(n, 2, "invalid enum discriminant");
                            let e150 = {
                                let l147 = *arg0
                                    .add(32 + 19 * ::core::mem::size_of::<*const u8>())
                                    .cast::<*mut u8>();
                                let l148 = *arg0
                                    .add(32 + 20 * ::core::mem::size_of::<*const u8>())
                                    .cast::<usize>();
                                let len149 = l148;
                                let bytes149 = _rt::Vec::from_raw_parts(
                                    l147.cast(),
                                    len149,
                                    len149,
                                );
                                _rt::string_lift(bytes149)
                            };
                            Status::Error(e150)
                        }
                    };
                    let l151 = *arg0
                        .add(32 + 21 * ::core::mem::size_of::<*const u8>())
                        .cast::<*mut u8>();
                    let l152 = *arg0
                        .add(32 + 22 * ::core::mem::size_of::<*const u8>())
                        .cast::<usize>();
                    let len153 = l152;
                    let bytes153 = _rt::Vec::from_raw_parts(l151.cast(), len153, len153);
                    let l154 = i32::from(
                        *arg0
                            .add(32 + 23 * ::core::mem::size_of::<*const u8>())
                            .cast::<u8>(),
                    );
                    let l158 = i32::from(
                        *arg0
                            .add(32 + 26 * ::core::mem::size_of::<*const u8>())
                            .cast::<u8>(),
                    );
                    let l162 = *arg0
                        .add(32 + 29 * ::core::mem::size_of::<*const u8>())
                        .cast::<*mut u8>();
                    let l163 = *arg0
                        .add(32 + 30 * ::core::mem::size_of::<*const u8>())
                        .cast::<usize>();
                    let base191 = l162;
                    let len191 = l163;
                    let mut result191 = _rt::Vec::with_capacity(len191);
                    for i in 0..len191 {
                        let base = base191
                            .add(i * (8 + 4 * ::core::mem::size_of::<*const u8>()));
                        let e191 = {
                            let l164 = *base.add(0).cast::<*mut u8>();
                            let l165 = *base
                                .add(::core::mem::size_of::<*const u8>())
                                .cast::<usize>();
                            let len166 = l165;
                            let bytes166 = _rt::Vec::from_raw_parts(
                                l164.cast(),
                                len166,
                                len166,
                            );
                            let l167 = i32::from(
                                *base
                                    .add(2 * ::core::mem::size_of::<*const u8>())
                                    .cast::<u8>(),
                            );
                            let v190 = match l167 {
                                0 => {
                                    let e190 = {
                                        let l168 = *base
                                            .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                            .cast::<*mut u8>();
                                        let l169 = *base
                                            .add(8 + 3 * ::core::mem::size_of::<*const u8>())
                                            .cast::<usize>();
                                        let len170 = l169;
                                        let bytes170 = _rt::Vec::from_raw_parts(
                                            l168.cast(),
                                            len170,
                                            len170,
                                        );
                                        _rt::string_lift(bytes170)
                                    };
                                    Value::String(e190)
                                }
                                1 => {
                                    let e190 = {
                                        let l171 = i32::from(
                                            *base
                                                .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                .cast::<u8>(),
                                        );
                                        _rt::bool_lift(l171 as u8)
                                    };
                                    Value::Bool(e190)
                                }
                                2 => {
                                    let e190 = {
                                        let l172 = *base
                                            .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                            .cast::<f64>();
                                        l172
                                    };
                                    Value::F64(e190)
                                }
                                3 => {
                                    let e190 = {
                                        let l173 = *base
                                            .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                            .cast::<i64>();
                                        l173
                                    };
                                    Value::S64(e190)
                                }
                                4 => {
                                    let e190 = {
                                        let l174 = *base
                                            .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                            .cast::<*mut u8>();
                                        let l175 = *base
                                            .add(8 + 3 * ::core::mem::size_of::<*const u8>())
                                            .cast::<usize>();
                                        let base179 = l174;
                                        let len179 = l175;
                                        let mut result179 = _rt::Vec::with_capacity(len179);
                                        for i in 0..len179 {
                                            let base = base179
                                                .add(i * (2 * ::core::mem::size_of::<*const u8>()));
                                            let e179 = {
                                                let l176 = *base.add(0).cast::<*mut u8>();
                                                let l177 = *base
                                                    .add(::core::mem::size_of::<*const u8>())
                                                    .cast::<usize>();
                                                let len178 = l177;
                                                let bytes178 = _rt::Vec::from_raw_parts(
                                                    l176.cast(),
                                                    len178,
                                                    len178,
                                                );
                                                _rt::string_lift(bytes178)
                                            };
                                            result179.push(e179);
                                        }
                                        _rt::cabi_dealloc(
                                            base179,
                                            len179 * (2 * ::core::mem::size_of::<*const u8>()),
                                            ::core::mem::size_of::<*const u8>(),
                                        );
                                        result179
                                    };
                                    Value::StringArray(e190)
                                }
                                5 => {
                                    let e190 = {
                                        let l180 = *base
                                            .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                            .cast::<*mut u8>();
                                        let l181 = *base
                                            .add(8 + 3 * ::core::mem::size_of::<*const u8>())
                                            .cast::<usize>();
                                        let base183 = l180;
                                        let len183 = l181;
                                        let mut result183 = _rt::Vec::with_capacity(len183);
                                        for i in 0..len183 {
                                            let base = base183.add(i * 1);
                                            let e183 = {
                                                let l182 = i32::from(*base.add(0).cast::<u8>());
                                                _rt::bool_lift(l182 as u8)
                                            };
                                            result183.push(e183);
                                        }
                                        _rt::cabi_dealloc(base183, len183 * 1, 1);
                                        result183
                                    };
                                    Value::BoolArray(e190)
                                }
                                6 => {
                                    let e190 = {
                                        let l184 = *base
                                            .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                            .cast::<*mut u8>();
                                        let l185 = *base
                                            .add(8 + 3 * ::core::mem::size_of::<*const u8>())
                                            .cast::<usize>();
                                        let len186 = l185;
                                        _rt::Vec::from_raw_parts(l184.cast(), len186, len186)
                                    };
                                    Value::F64Array(e190)
                                }
                                n => {
                                    debug_assert_eq!(n, 7, "invalid enum discriminant");
                                    let e190 = {
                                        let l187 = *base
                                            .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                            .cast::<*mut u8>();
                                        let l188 = *base
                                            .add(8 + 3 * ::core::mem::size_of::<*const u8>())
                                            .cast::<usize>();
                                        let len189 = l188;
                                        _rt::Vec::from_raw_parts(l187.cast(), len189, len189)
                                    };
                                    Value::S64Array(e190)
                                }
                            };
                            KeyValue {
                                key: _rt::string_lift(bytes166),
                                value: v190,
                            }
                        };
                        result191.push(e191);
                    }
                    _rt::cabi_dealloc(
                        base191,
                        len191 * (8 + 4 * ::core::mem::size_of::<*const u8>()),
                        8,
                    );
                    let l192 = *arg0
                        .add(32 + 31 * ::core::mem::size_of::<*const u8>())
                        .cast::<i32>();
                    let l193 = *arg0
                        .add(36 + 31 * ::core::mem::size_of::<*const u8>())
                        .cast::<i32>();
                    let l194 = *arg0
                        .add(40 + 31 * ::core::mem::size_of::<*const u8>())
                        .cast::<i32>();
                    T::on_end(SpanData {
                        span_context: SpanContext {
                            trace_id: _rt::string_lift(bytes2),
                            span_id: _rt::string_lift(bytes5),
                            trace_flags: TraceFlags::empty()
                                | TraceFlags::from_bits_retain(((l6 as u8) << 0) as _),
                            is_remote: _rt::bool_lift(l7 as u8),
                            trace_state: result16,
                        },
                        parent_span_id: _rt::string_lift(bytes19),
                        span_kind: SpanKind::_lift(l20 as u8),
                        name: _rt::string_lift(bytes23),
                        start_time: super::super::super::super::wasi::clocks::wall_clock::Datetime {
                            seconds: l24 as u64,
                            nanoseconds: l25 as u32,
                        },
                        end_time: super::super::super::super::wasi::clocks::wall_clock::Datetime {
                            seconds: l26 as u64,
                            nanoseconds: l27 as u32,
                        },
                        attributes: result57,
                        events: result95,
                        links: result145,
                        status: v150,
                        instrumentation_scope: InstrumentationScope {
                            name: _rt::string_lift(bytes153),
                            version: match l154 {
                                0 => None,
                                1 => {
                                    let e = {
                                        let l155 = *arg0
                                            .add(32 + 24 * ::core::mem::size_of::<*const u8>())
                                            .cast::<*mut u8>();
                                        let l156 = *arg0
                                            .add(32 + 25 * ::core::mem::size_of::<*const u8>())
                                            .cast::<usize>();
                                        let len157 = l156;
                                        let bytes157 = _rt::Vec::from_raw_parts(
                                            l155.cast(),
                                            len157,
                                            len157,
                                        );
                                        _rt::string_lift(bytes157)
                                    };
                                    Some(e)
                                }
                                _ => _rt::invalid_enum_discriminant(),
                            },
                            schema_url: match l158 {
                                0 => None,
                                1 => {
                                    let e = {
                                        let l159 = *arg0
                                            .add(32 + 27 * ::core::mem::size_of::<*const u8>())
                                            .cast::<*mut u8>();
                                        let l160 = *arg0
                                            .add(32 + 28 * ::core::mem::size_of::<*const u8>())
                                            .cast::<usize>();
                                        let len161 = l160;
                                        let bytes161 = _rt::Vec::from_raw_parts(
                                            l159.cast(),
                                            len161,
                                            len161,
                                        );
                                        _rt::string_lift(bytes161)
                                    };
                                    Some(e)
                                }
                                _ => _rt::invalid_enum_discriminant(),
                            },
                            attributes: result191,
                        },
                        dropped_attributes: l192 as u32,
                        dropped_events: l193 as u32,
                        dropped_links: l194 as u32,
                    });
                    _rt::cabi_dealloc(
                        arg0,
                        40 + 32 * ::core::mem::size_of::<*const u8>(),
                        8,
                    );
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_current_span_context_cabi<T: Guest>() -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let result0 = T::current_span_context();
                    let ptr1 = (&raw mut _RET_AREA.0).cast::<u8>();
                    let SpanContext {
                        trace_id: trace_id2,
                        span_id: span_id2,
                        trace_flags: trace_flags2,
                        is_remote: is_remote2,
                        trace_state: trace_state2,
                    } = result0;
                    let vec3 = (trace_id2.into_bytes()).into_boxed_slice();
                    let ptr3 = vec3.as_ptr().cast::<u8>();
                    let len3 = vec3.len();
                    ::core::mem::forget(vec3);
                    *ptr1.add(::core::mem::size_of::<*const u8>()).cast::<usize>() = len3;
                    *ptr1.add(0).cast::<*mut u8>() = ptr3.cast_mut();
                    let vec4 = (span_id2.into_bytes()).into_boxed_slice();
                    let ptr4 = vec4.as_ptr().cast::<u8>();
                    let len4 = vec4.len();
                    ::core::mem::forget(vec4);
                    *ptr1.add(3 * ::core::mem::size_of::<*const u8>()).cast::<usize>() = len4;
                    *ptr1
                        .add(2 * ::core::mem::size_of::<*const u8>())
                        .cast::<*mut u8>() = ptr4.cast_mut();
                    let flags5 = trace_flags2;
                    *ptr1.add(4 * ::core::mem::size_of::<*const u8>()).cast::<u8>() = ((flags5
                        .bits() >> 0) as i32) as u8;
                    *ptr1
                        .add(1 + 4 * ::core::mem::size_of::<*const u8>())
                        .cast::<u8>() = (match is_remote2 {
                        true => 1,
                        false => 0,
                    }) as u8;
                    let vec9 = trace_state2;
                    let len9 = vec9.len();
                    let layout9 = _rt::alloc::Layout::from_size_align_unchecked(
                        vec9.len() * (4 * ::core::mem::size_of::<*const u8>()),
                        ::core::mem::size_of::<*const u8>(),
                    );
                    let result9 = if layout9.size() != 0 {
                        let ptr = _rt::alloc::alloc(layout9).cast::<u8>();
                        if ptr.is_null() {
                            _rt::alloc::handle_alloc_error(layout9);
                        }
                        ptr
                    } else {
                        ::core::ptr::null_mut()
                    };
                    for (i, e) in vec9.into_iter().enumerate() {
                        let base = result9
                            .add(i * (4 * ::core::mem::size_of::<*const u8>()));
                        {
                            let (t6_0, t6_1) = e;
                            let vec7 = (t6_0.into_bytes()).into_boxed_slice();
                            let ptr7 = vec7.as_ptr().cast::<u8>();
                            let len7 = vec7.len();
                            ::core::mem::forget(vec7);
                            *base
                                .add(::core::mem::size_of::<*const u8>())
                                .cast::<usize>() = len7;
                            *base.add(0).cast::<*mut u8>() = ptr7.cast_mut();
                            let vec8 = (t6_1.into_bytes()).into_boxed_slice();
                            let ptr8 = vec8.as_ptr().cast::<u8>();
                            let len8 = vec8.len();
                            ::core::mem::forget(vec8);
                            *base
                                .add(3 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>() = len8;
                            *base
                                .add(2 * ::core::mem::size_of::<*const u8>())
                                .cast::<*mut u8>() = ptr8.cast_mut();
                        }
                    }
                    *ptr1.add(6 * ::core::mem::size_of::<*const u8>()).cast::<usize>() = len9;
                    *ptr1
                        .add(5 * ::core::mem::size_of::<*const u8>())
                        .cast::<*mut u8>() = result9;
                    ptr1
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn __post_return_current_span_context<T: Guest>(
                    arg0: *mut u8,
                ) {
                    let l0 = *arg0.add(0).cast::<*mut u8>();
                    let l1 = *arg0
                        .add(::core::mem::size_of::<*const u8>())
                        .cast::<usize>();
                    _rt::cabi_dealloc(l0, l1, 1);
                    let l2 = *arg0
                        .add(2 * ::core::mem::size_of::<*const u8>())
                        .cast::<*mut u8>();
                    let l3 = *arg0
                        .add(3 * ::core::mem::size_of::<*const u8>())
                        .cast::<usize>();
                    _rt::cabi_dealloc(l2, l3, 1);
                    let l4 = *arg0
                        .add(5 * ::core::mem::size_of::<*const u8>())
                        .cast::<*mut u8>();
                    let l5 = *arg0
                        .add(6 * ::core::mem::size_of::<*const u8>())
                        .cast::<usize>();
                    let base10 = l4;
                    let len10 = l5;
                    for i in 0..len10 {
                        let base = base10
                            .add(i * (4 * ::core::mem::size_of::<*const u8>()));
                        {
                            let l6 = *base.add(0).cast::<*mut u8>();
                            let l7 = *base
                                .add(::core::mem::size_of::<*const u8>())
                                .cast::<usize>();
                            _rt::cabi_dealloc(l6, l7, 1);
                            let l8 = *base
                                .add(2 * ::core::mem::size_of::<*const u8>())
                                .cast::<*mut u8>();
                            let l9 = *base
                                .add(3 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>();
                            _rt::cabi_dealloc(l8, l9, 1);
                        }
                    }
                    _rt::cabi_dealloc(
                        base10,
                        len10 * (4 * ::core::mem::size_of::<*const u8>()),
                        ::core::mem::size_of::<*const u8>(),
                    );
                }
                pub trait Guest {
                    /// Called when a span is started.
                    fn on_start(span: SpanData, parent: SpanContext) -> ();
                    /// Called when a span is ended.
                    fn on_end(span: SpanData) -> ();
                    /// Returns the current span context of the host.
                    fn current_span_context() -> SpanContext;
                }
                #[doc(hidden)]
                macro_rules! __export_wasi_otel_tracing_0_2_0_draft_cabi {
                    ($ty:ident with_types_in $($path_to_types:tt)*) => {
                        const _ : () = { #[unsafe (export_name =
                        "wasi:otel/tracing@0.2.0-draft#on-start")] unsafe extern "C" fn
                        export_on_start(arg0 : * mut u8,) { unsafe { $($path_to_types)*::
                        _export_on_start_cabi::<$ty > (arg0) } } #[unsafe (export_name =
                        "wasi:otel/tracing@0.2.0-draft#on-end")] unsafe extern "C" fn
                        export_on_end(arg0 : * mut u8,) { unsafe { $($path_to_types)*::
                        _export_on_end_cabi::<$ty > (arg0) } } #[unsafe (export_name =
                        "wasi:otel/tracing@0.2.0-draft#current-span-context")] unsafe
                        extern "C" fn export_current_span_context() -> * mut u8 { unsafe
                        { $($path_to_types)*:: _export_current_span_context_cabi::<$ty >
                        () } } #[unsafe (export_name =
                        "cabi_post_wasi:otel/tracing@0.2.0-draft#current-span-context")]
                        unsafe extern "C" fn _post_return_current_span_context(arg0 : *
                        mut u8,) { unsafe { $($path_to_types)*::
                        __post_return_current_span_context::<$ty > (arg0) } } };
                    };
                }
                #[doc(hidden)]
                pub(crate) use __export_wasi_otel_tracing_0_2_0_draft_cabi;
                #[cfg_attr(target_pointer_width = "64", repr(align(8)))]
                #[cfg_attr(target_pointer_width = "32", repr(align(4)))]
                struct _RetArea(
                    [::core::mem::MaybeUninit<
                        u8,
                    >; 7 * ::core::mem::size_of::<*const u8>()],
                );
                static mut _RET_AREA: _RetArea = _RetArea(
                    [::core::mem::MaybeUninit::uninit(); 7
                        * ::core::mem::size_of::<*const u8>()],
                );
            }
        }
    }
    pub mod wasmcp {
        pub mod otel_exporter {
            #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
            pub mod api {
                #[used]
                #[doc(hidden)]
                static __FORCE_SECTION_REF: fn() = super::super::super::super::__link_custom_section_describing_imports;
                use super::super::super::super::_rt;
                pub type SpanContext = super::super::super::super::exports::wasi::otel::tracing::SpanContext;
                #[derive(Debug)]
                #[repr(transparent)]
                pub struct Span {
                    handle: _rt::Resource<Span>,
                }
                type _SpanRep<T> = Option<T>;
                impl Span {
                    /// Creates a new resource from the specified representation.
                    ///
                    /// This function will create a new resource handle by moving `val` onto
                    /// the heap and then passing that heap pointer to the component model to
                    /// create a handle. The owned handle is then returned as `Span`.
                    pub fn new<T: GuestSpan>(val: T) -> Self {
                        Self::type_guard::<T>();
                        let val: _SpanRep<T> = Some(val);
                        let ptr: *mut _SpanRep<T> = _rt::Box::into_raw(
                            _rt::Box::new(val),
                        );
                        unsafe { Self::from_handle(T::_resource_new(ptr.cast())) }
                    }
                    /// Gets access to the underlying `T` which represents this resource.
                    pub fn get<T: GuestSpan>(&self) -> &T {
                        let ptr = unsafe { &*self.as_ptr::<T>() };
                        ptr.as_ref().unwrap()
                    }
                    /// Gets mutable access to the underlying `T` which represents this
                    /// resource.
                    pub fn get_mut<T: GuestSpan>(&mut self) -> &mut T {
                        let ptr = unsafe { &mut *self.as_ptr::<T>() };
                        ptr.as_mut().unwrap()
                    }
                    /// Consumes this resource and returns the underlying `T`.
                    pub fn into_inner<T: GuestSpan>(self) -> T {
                        let ptr = unsafe { &mut *self.as_ptr::<T>() };
                        ptr.take().unwrap()
                    }
                    #[doc(hidden)]
                    pub unsafe fn from_handle(handle: u32) -> Self {
                        Self {
                            handle: unsafe { _rt::Resource::from_handle(handle) },
                        }
                    }
                    #[doc(hidden)]
                    pub fn take_handle(&self) -> u32 {
                        _rt::Resource::take_handle(&self.handle)
                    }
                    #[doc(hidden)]
                    pub fn handle(&self) -> u32 {
                        _rt::Resource::handle(&self.handle)
                    }
                    #[doc(hidden)]
                    fn type_guard<T: 'static>() {
                        use core::any::TypeId;
                        static mut LAST_TYPE: Option<TypeId> = None;
                        unsafe {
                            assert!(! cfg!(target_feature = "atomics"));
                            let id = TypeId::of::<T>();
                            match LAST_TYPE {
                                Some(ty) => {
                                    assert!(
                                        ty == id, "cannot use two types with this resource type"
                                    )
                                }
                                None => LAST_TYPE = Some(id),
                            }
                        }
                    }
                    #[doc(hidden)]
                    pub unsafe fn dtor<T: 'static>(handle: *mut u8) {
                        Self::type_guard::<T>();
                        let _ = unsafe {
                            _rt::Box::from_raw(handle as *mut _SpanRep<T>)
                        };
                    }
                    fn as_ptr<T: GuestSpan>(&self) -> *mut _SpanRep<T> {
                        Span::type_guard::<T>();
                        T::_resource_rep(self.handle()).cast()
                    }
                }
                /// A borrowed version of [`Span`] which represents a borrowed value
                /// with the lifetime `'a`.
                #[derive(Debug)]
                #[repr(transparent)]
                pub struct SpanBorrow<'a> {
                    rep: *mut u8,
                    _marker: core::marker::PhantomData<&'a Span>,
                }
                impl<'a> SpanBorrow<'a> {
                    #[doc(hidden)]
                    pub unsafe fn lift(rep: usize) -> Self {
                        Self {
                            rep: rep as *mut u8,
                            _marker: core::marker::PhantomData,
                        }
                    }
                    /// Gets access to the underlying `T` in this resource.
                    pub fn get<T: GuestSpan>(&self) -> &T {
                        let ptr = unsafe { &mut *self.as_ptr::<T>() };
                        ptr.as_ref().unwrap()
                    }
                    fn as_ptr<T: 'static>(&self) -> *mut _SpanRep<T> {
                        Span::type_guard::<T>();
                        self.rep.cast()
                    }
                }
                unsafe impl _rt::WasmResource for Span {
                    #[inline]
                    unsafe fn drop(_handle: u32) {
                        #[cfg(not(target_arch = "wasm32"))]
                        unreachable!();
                        #[cfg(target_arch = "wasm32")]
                        {
                            #[link(
                                wasm_import_module = "[export]wasmcp:otel-exporter/api@0.1.0"
                            )]
                            unsafe extern "C" {
                                #[link_name = "[resource-drop]span"]
                                fn drop(_: u32);
                            }
                            unsafe { drop(_handle) };
                        }
                    }
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_constructor_span_cabi<T: GuestSpan>(
                    arg0: *mut u8,
                    arg1: usize,
                    arg2: i32,
                    arg3: *mut u8,
                    arg4: usize,
                    arg5: *mut u8,
                    arg6: usize,
                    arg7: i32,
                    arg8: i32,
                    arg9: *mut u8,
                    arg10: usize,
                ) -> i32 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let len0 = arg1;
                    let bytes0 = _rt::Vec::from_raw_parts(arg0.cast(), len0, len0);
                    let result10 = Span::new(
                        T::new(
                            _rt::string_lift(bytes0),
                            match arg2 {
                                0 => None,
                                1 => {
                                    let e = {
                                        let len1 = arg4;
                                        let bytes1 = _rt::Vec::from_raw_parts(
                                            arg3.cast(),
                                            len1,
                                            len1,
                                        );
                                        let len2 = arg6;
                                        let bytes2 = _rt::Vec::from_raw_parts(
                                            arg5.cast(),
                                            len2,
                                            len2,
                                        );
                                        let base9 = arg9;
                                        let len9 = arg10;
                                        let mut result9 = _rt::Vec::with_capacity(len9);
                                        for i in 0..len9 {
                                            let base = base9
                                                .add(i * (4 * ::core::mem::size_of::<*const u8>()));
                                            let e9 = {
                                                let l3 = *base.add(0).cast::<*mut u8>();
                                                let l4 = *base
                                                    .add(::core::mem::size_of::<*const u8>())
                                                    .cast::<usize>();
                                                let len5 = l4;
                                                let bytes5 = _rt::Vec::from_raw_parts(
                                                    l3.cast(),
                                                    len5,
                                                    len5,
                                                );
                                                let l6 = *base
                                                    .add(2 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<*mut u8>();
                                                let l7 = *base
                                                    .add(3 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<usize>();
                                                let len8 = l7;
                                                let bytes8 = _rt::Vec::from_raw_parts(
                                                    l6.cast(),
                                                    len8,
                                                    len8,
                                                );
                                                (_rt::string_lift(bytes5), _rt::string_lift(bytes8))
                                            };
                                            result9.push(e9);
                                        }
                                        _rt::cabi_dealloc(
                                            base9,
                                            len9 * (4 * ::core::mem::size_of::<*const u8>()),
                                            ::core::mem::size_of::<*const u8>(),
                                        );
                                        super::super::super::super::exports::wasi::otel::tracing::SpanContext {
                                            trace_id: _rt::string_lift(bytes1),
                                            span_id: _rt::string_lift(bytes2),
                                            trace_flags: super::super::super::super::exports::wasi::otel::tracing::TraceFlags::empty()
                                                | super::super::super::super::exports::wasi::otel::tracing::TraceFlags::from_bits_retain(
                                                    ((arg7 as u8) << 0) as _,
                                                ),
                                            is_remote: _rt::bool_lift(arg8 as u8),
                                            trace_state: result9,
                                        }
                                    };
                                    Some(e)
                                }
                                _ => _rt::invalid_enum_discriminant(),
                            },
                        ),
                    );
                    (result10).take_handle() as i32
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_method_span_add_event_cabi<T: GuestSpan>(
                    arg0: *mut u8,
                    arg1: *mut u8,
                    arg2: usize,
                ) {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let len0 = arg2;
                    let bytes0 = _rt::Vec::from_raw_parts(arg1.cast(), len0, len0);
                    T::add_event(
                        unsafe { SpanBorrow::lift(arg0 as u32 as usize) }.get(),
                        _rt::string_lift(bytes0),
                    );
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_method_span_finish_cabi<T: GuestSpan>(
                    arg0: *mut u8,
                ) {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    T::finish(unsafe { SpanBorrow::lift(arg0 as u32 as usize) }.get());
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_get_context_cabi<T: Guest>(arg0: i32) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let result0 = T::get_context(unsafe {
                        SpanBorrow::lift(arg0 as u32 as usize)
                    });
                    let ptr1 = (&raw mut _RET_AREA.0).cast::<u8>();
                    let super::super::super::super::exports::wasi::otel::tracing::SpanContext {
                        trace_id: trace_id2,
                        span_id: span_id2,
                        trace_flags: trace_flags2,
                        is_remote: is_remote2,
                        trace_state: trace_state2,
                    } = result0;
                    let vec3 = (trace_id2.into_bytes()).into_boxed_slice();
                    let ptr3 = vec3.as_ptr().cast::<u8>();
                    let len3 = vec3.len();
                    ::core::mem::forget(vec3);
                    *ptr1.add(::core::mem::size_of::<*const u8>()).cast::<usize>() = len3;
                    *ptr1.add(0).cast::<*mut u8>() = ptr3.cast_mut();
                    let vec4 = (span_id2.into_bytes()).into_boxed_slice();
                    let ptr4 = vec4.as_ptr().cast::<u8>();
                    let len4 = vec4.len();
                    ::core::mem::forget(vec4);
                    *ptr1.add(3 * ::core::mem::size_of::<*const u8>()).cast::<usize>() = len4;
                    *ptr1
                        .add(2 * ::core::mem::size_of::<*const u8>())
                        .cast::<*mut u8>() = ptr4.cast_mut();
                    let flags5 = trace_flags2;
                    *ptr1.add(4 * ::core::mem::size_of::<*const u8>()).cast::<u8>() = ((flags5
                        .bits() >> 0) as i32) as u8;
                    *ptr1
                        .add(1 + 4 * ::core::mem::size_of::<*const u8>())
                        .cast::<u8>() = (match is_remote2 {
                        true => 1,
                        false => 0,
                    }) as u8;
                    let vec9 = trace_state2;
                    let len9 = vec9.len();
                    let layout9 = _rt::alloc::Layout::from_size_align_unchecked(
                        vec9.len() * (4 * ::core::mem::size_of::<*const u8>()),
                        ::core::mem::size_of::<*const u8>(),
                    );
                    let result9 = if layout9.size() != 0 {
                        let ptr = _rt::alloc::alloc(layout9).cast::<u8>();
                        if ptr.is_null() {
                            _rt::alloc::handle_alloc_error(layout9);
                        }
                        ptr
                    } else {
                        ::core::ptr::null_mut()
                    };
                    for (i, e) in vec9.into_iter().enumerate() {
                        let base = result9
                            .add(i * (4 * ::core::mem::size_of::<*const u8>()));
                        {
                            let (t6_0, t6_1) = e;
                            let vec7 = (t6_0.into_bytes()).into_boxed_slice();
                            let ptr7 = vec7.as_ptr().cast::<u8>();
                            let len7 = vec7.len();
                            ::core::mem::forget(vec7);
                            *base
                                .add(::core::mem::size_of::<*const u8>())
                                .cast::<usize>() = len7;
                            *base.add(0).cast::<*mut u8>() = ptr7.cast_mut();
                            let vec8 = (t6_1.into_bytes()).into_boxed_slice();
                            let ptr8 = vec8.as_ptr().cast::<u8>();
                            let len8 = vec8.len();
                            ::core::mem::forget(vec8);
                            *base
                                .add(3 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>() = len8;
                            *base
                                .add(2 * ::core::mem::size_of::<*const u8>())
                                .cast::<*mut u8>() = ptr8.cast_mut();
                        }
                    }
                    *ptr1.add(6 * ::core::mem::size_of::<*const u8>()).cast::<usize>() = len9;
                    *ptr1
                        .add(5 * ::core::mem::size_of::<*const u8>())
                        .cast::<*mut u8>() = result9;
                    ptr1
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn __post_return_get_context<T: Guest>(arg0: *mut u8) {
                    let l0 = *arg0.add(0).cast::<*mut u8>();
                    let l1 = *arg0
                        .add(::core::mem::size_of::<*const u8>())
                        .cast::<usize>();
                    _rt::cabi_dealloc(l0, l1, 1);
                    let l2 = *arg0
                        .add(2 * ::core::mem::size_of::<*const u8>())
                        .cast::<*mut u8>();
                    let l3 = *arg0
                        .add(3 * ::core::mem::size_of::<*const u8>())
                        .cast::<usize>();
                    _rt::cabi_dealloc(l2, l3, 1);
                    let l4 = *arg0
                        .add(5 * ::core::mem::size_of::<*const u8>())
                        .cast::<*mut u8>();
                    let l5 = *arg0
                        .add(6 * ::core::mem::size_of::<*const u8>())
                        .cast::<usize>();
                    let base10 = l4;
                    let len10 = l5;
                    for i in 0..len10 {
                        let base = base10
                            .add(i * (4 * ::core::mem::size_of::<*const u8>()));
                        {
                            let l6 = *base.add(0).cast::<*mut u8>();
                            let l7 = *base
                                .add(::core::mem::size_of::<*const u8>())
                                .cast::<usize>();
                            _rt::cabi_dealloc(l6, l7, 1);
                            let l8 = *base
                                .add(2 * ::core::mem::size_of::<*const u8>())
                                .cast::<*mut u8>();
                            let l9 = *base
                                .add(3 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>();
                            _rt::cabi_dealloc(l8, l9, 1);
                        }
                    }
                    _rt::cabi_dealloc(
                        base10,
                        len10 * (4 * ::core::mem::size_of::<*const u8>()),
                        ::core::mem::size_of::<*const u8>(),
                    );
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_get_current_span_cabi<T: Guest>() -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let result0 = T::get_current_span();
                    let ptr1 = (&raw mut _RET_AREA.0).cast::<u8>();
                    match result0 {
                        Some(e) => {
                            *ptr1.add(0).cast::<u8>() = (1i32) as u8;
                            *ptr1.add(4).cast::<i32>() = (e).take_handle() as i32;
                        }
                        None => {
                            *ptr1.add(0).cast::<u8>() = (0i32) as u8;
                        }
                    };
                    ptr1
                }
                pub trait Guest {
                    type Span: GuestSpan;
                    fn get_context(s: SpanBorrow<'_>) -> SpanContext;
                    fn get_current_span() -> Option<Span>;
                }
                pub trait GuestSpan: 'static {
                    #[doc(hidden)]
                    unsafe fn _resource_new(val: *mut u8) -> u32
                    where
                        Self: Sized,
                    {
                        #[cfg(not(target_arch = "wasm32"))]
                        {
                            let _ = val;
                            unreachable!();
                        }
                        #[cfg(target_arch = "wasm32")]
                        {
                            #[link(
                                wasm_import_module = "[export]wasmcp:otel-exporter/api@0.1.0"
                            )]
                            unsafe extern "C" {
                                #[link_name = "[resource-new]span"]
                                fn new(_: *mut u8) -> u32;
                            }
                            unsafe { new(val) }
                        }
                    }
                    #[doc(hidden)]
                    fn _resource_rep(handle: u32) -> *mut u8
                    where
                        Self: Sized,
                    {
                        #[cfg(not(target_arch = "wasm32"))]
                        {
                            let _ = handle;
                            unreachable!();
                        }
                        #[cfg(target_arch = "wasm32")]
                        {
                            #[link(
                                wasm_import_module = "[export]wasmcp:otel-exporter/api@0.1.0"
                            )]
                            unsafe extern "C" {
                                #[link_name = "[resource-rep]span"]
                                fn rep(_: u32) -> *mut u8;
                            }
                            unsafe { rep(handle) }
                        }
                    }
                    fn new(
                        name: _rt::String,
                        parent_context: Option<SpanContext>,
                    ) -> Self;
                    fn add_event(&self, name: _rt::String) -> ();
                    fn finish(&self) -> ();
                }
                #[doc(hidden)]
                macro_rules! __export_wasmcp_otel_exporter_api_0_1_0_cabi {
                    ($ty:ident with_types_in $($path_to_types:tt)*) => {
                        const _ : () = { #[unsafe (export_name =
                        "wasmcp:otel-exporter/api@0.1.0#[constructor]span")] unsafe
                        extern "C" fn export_constructor_span(arg0 : * mut u8, arg1 :
                        usize, arg2 : i32, arg3 : * mut u8, arg4 : usize, arg5 : * mut
                        u8, arg6 : usize, arg7 : i32, arg8 : i32, arg9 : * mut u8, arg10
                        : usize,) -> i32 { unsafe { $($path_to_types)*::
                        _export_constructor_span_cabi::<<$ty as $($path_to_types)*::
                        Guest >::Span > (arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7,
                        arg8, arg9, arg10) } } #[unsafe (export_name =
                        "wasmcp:otel-exporter/api@0.1.0#[method]span.add-event")] unsafe
                        extern "C" fn export_method_span_add_event(arg0 : * mut u8, arg1
                        : * mut u8, arg2 : usize,) { unsafe { $($path_to_types)*::
                        _export_method_span_add_event_cabi::<<$ty as $($path_to_types)*::
                        Guest >::Span > (arg0, arg1, arg2) } } #[unsafe (export_name =
                        "wasmcp:otel-exporter/api@0.1.0#[method]span.finish")] unsafe
                        extern "C" fn export_method_span_finish(arg0 : * mut u8,) {
                        unsafe { $($path_to_types)*::
                        _export_method_span_finish_cabi::<<$ty as $($path_to_types)*::
                        Guest >::Span > (arg0) } } #[unsafe (export_name =
                        "wasmcp:otel-exporter/api@0.1.0#get-context")] unsafe extern "C"
                        fn export_get_context(arg0 : i32,) -> * mut u8 { unsafe {
                        $($path_to_types)*:: _export_get_context_cabi::<$ty > (arg0) } }
                        #[unsafe (export_name =
                        "cabi_post_wasmcp:otel-exporter/api@0.1.0#get-context")] unsafe
                        extern "C" fn _post_return_get_context(arg0 : * mut u8,) { unsafe
                        { $($path_to_types)*:: __post_return_get_context::<$ty > (arg0) }
                        } #[unsafe (export_name =
                        "wasmcp:otel-exporter/api@0.1.0#get-current-span")] unsafe extern
                        "C" fn export_get_current_span() -> * mut u8 { unsafe {
                        $($path_to_types)*:: _export_get_current_span_cabi::<$ty > () } }
                        const _ : () = { #[doc(hidden)] #[unsafe (export_name =
                        "wasmcp:otel-exporter/api@0.1.0#[dtor]span")]
                        #[allow(non_snake_case)] unsafe extern "C" fn dtor(rep : * mut
                        u8) { unsafe { $($path_to_types)*:: Span::dtor::< <$ty as
                        $($path_to_types)*:: Guest >::Span > (rep) } } }; };
                    };
                }
                #[doc(hidden)]
                pub(crate) use __export_wasmcp_otel_exporter_api_0_1_0_cabi;
                #[cfg_attr(target_pointer_width = "64", repr(align(8)))]
                #[cfg_attr(target_pointer_width = "32", repr(align(4)))]
                struct _RetArea(
                    [::core::mem::MaybeUninit<
                        u8,
                    >; 7 * ::core::mem::size_of::<*const u8>()],
                );
                static mut _RET_AREA: _RetArea = _RetArea(
                    [::core::mem::MaybeUninit::uninit(); 7
                        * ::core::mem::size_of::<*const u8>()],
                );
            }
        }
    }
}
#[rustfmt::skip]
mod _rt {
    #![allow(dead_code, clippy::all)]
    pub use alloc_crate::string::String;
    pub use alloc_crate::vec::Vec;
    pub unsafe fn string_lift(bytes: Vec<u8>) -> String {
        if cfg!(debug_assertions) {
            String::from_utf8(bytes).unwrap()
        } else {
            String::from_utf8_unchecked(bytes)
        }
    }
    pub unsafe fn invalid_enum_discriminant<T>() -> T {
        if cfg!(debug_assertions) {
            panic!("invalid enum discriminant")
        } else {
            unsafe { core::hint::unreachable_unchecked() }
        }
    }
    pub unsafe fn cabi_dealloc(ptr: *mut u8, size: usize, align: usize) {
        if size == 0 {
            return;
        }
        let layout = alloc::Layout::from_size_align_unchecked(size, align);
        alloc::dealloc(ptr, layout);
    }
    #[cfg(target_arch = "wasm32")]
    pub fn run_ctors_once() {
        wit_bindgen_rt::run_ctors_once();
    }
    pub unsafe fn bool_lift(val: u8) -> bool {
        if cfg!(debug_assertions) {
            match val {
                0 => false,
                1 => true,
                _ => panic!("invalid bool discriminant"),
            }
        } else {
            val != 0
        }
    }
    pub use alloc_crate::alloc;
    use core::fmt;
    use core::marker;
    use core::sync::atomic::{AtomicU32, Ordering::Relaxed};
    /// A type which represents a component model resource, either imported or
    /// exported into this component.
    ///
    /// This is a low-level wrapper which handles the lifetime of the resource
    /// (namely this has a destructor). The `T` provided defines the component model
    /// intrinsics that this wrapper uses.
    ///
    /// One of the chief purposes of this type is to provide `Deref` implementations
    /// to access the underlying data when it is owned.
    ///
    /// This type is primarily used in generated code for exported and imported
    /// resources.
    #[repr(transparent)]
    pub struct Resource<T: WasmResource> {
        handle: AtomicU32,
        _marker: marker::PhantomData<T>,
    }
    /// A trait which all wasm resources implement, namely providing the ability to
    /// drop a resource.
    ///
    /// This generally is implemented by generated code, not user-facing code.
    #[allow(clippy::missing_safety_doc)]
    pub unsafe trait WasmResource {
        /// Invokes the `[resource-drop]...` intrinsic.
        unsafe fn drop(handle: u32);
    }
    impl<T: WasmResource> Resource<T> {
        #[doc(hidden)]
        pub unsafe fn from_handle(handle: u32) -> Self {
            debug_assert!(handle != u32::MAX);
            Self {
                handle: AtomicU32::new(handle),
                _marker: marker::PhantomData,
            }
        }
        /// Takes ownership of the handle owned by `resource`.
        ///
        /// Note that this ideally would be `into_handle` taking `Resource<T>` by
        /// ownership. The code generator does not enable that in all situations,
        /// unfortunately, so this is provided instead.
        ///
        /// Also note that `take_handle` is in theory only ever called on values
        /// owned by a generated function. For example a generated function might
        /// take `Resource<T>` as an argument but then call `take_handle` on a
        /// reference to that argument. In that sense the dynamic nature of
        /// `take_handle` should only be exposed internally to generated code, not
        /// to user code.
        #[doc(hidden)]
        pub fn take_handle(resource: &Resource<T>) -> u32 {
            resource.handle.swap(u32::MAX, Relaxed)
        }
        #[doc(hidden)]
        pub fn handle(resource: &Resource<T>) -> u32 {
            resource.handle.load(Relaxed)
        }
    }
    impl<T: WasmResource> fmt::Debug for Resource<T> {
        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
            f.debug_struct("Resource").field("handle", &self.handle).finish()
        }
    }
    impl<T: WasmResource> Drop for Resource<T> {
        fn drop(&mut self) {
            unsafe {
                match self.handle.load(Relaxed) {
                    u32::MAX => {}
                    other => T::drop(other),
                }
            }
        }
    }
    pub use alloc_crate::boxed::Box;
    extern crate alloc as alloc_crate;
}
/// Generates `#[unsafe(no_mangle)]` functions to export the specified type as
/// the root implementation of all generated traits.
///
/// For more information see the documentation of `wit_bindgen::generate!`.
///
/// ```rust
/// # macro_rules! export{ ($($t:tt)*) => (); }
/// # trait Guest {}
/// struct MyType;
///
/// impl Guest for MyType {
///     // ...
/// }
///
/// export!(MyType);
/// ```
#[allow(unused_macros)]
#[doc(hidden)]
macro_rules! __export_otel_exporter_impl {
    ($ty:ident) => {
        self::export!($ty with_types_in self);
    };
    ($ty:ident with_types_in $($path_to_types_root:tt)*) => {
        $($path_to_types_root)*::
        exports::wasi::otel::tracing::__export_wasi_otel_tracing_0_2_0_draft_cabi!($ty
        with_types_in $($path_to_types_root)*:: exports::wasi::otel::tracing);
        $($path_to_types_root)*::
        exports::wasmcp::otel_exporter::api::__export_wasmcp_otel_exporter_api_0_1_0_cabi!($ty
        with_types_in $($path_to_types_root)*:: exports::wasmcp::otel_exporter::api);
    };
}
#[doc(inline)]
pub(crate) use __export_otel_exporter_impl as export;
#[cfg(target_arch = "wasm32")]
#[unsafe(
    link_section = "component-type:wit-bindgen:0.41.0:wasmcp:otel-exporter@0.1.0:otel-exporter:encoded world"
)]
#[doc(hidden)]
#[allow(clippy::octal_escapes)]
pub static __WIT_BINDGEN_COMPONENT_TYPE: [u8; 2573] = *b"\
\0asm\x0d\0\x01\0\0\x19\x16wit-component-encoding\x04\0\x07\x89\x13\x01A\x02\x01\
A\x0a\x01B#\x01ky\x01r\x02\x0abatch-size\0\x0atimeout-ms\0\x04\0\x14jaeger-thrif\
t-config\x03\0\x01\x01r\x02\x0abatch-size\0\x0dendpoint-paths\x04\0\x12zipkin-js\
on-config\x03\0\x03\x01m\x03\x04gzip\x07deflate\x04none\x04\0\x10compression-typ\
e\x03\0\x05\x01k\x06\x01r\x03\x0ccontent-types\x0bcompression\x07\x0atimeout-ms\0\
\x04\0\x10otlp-http-config\x03\0\x08\x01r\x02\x0bcompression\x07\x0atimeout-ms\0\
\x04\0\x10otlp-grpc-config\x03\0\x0a\x01q\x04\x09otlp-http\x01\x09\0\x09otlp-grp\
c\x01\x0b\0\x0djaeger-thrift\x01\x02\0\x0bzipkin-json\x01\x04\0\x04\0\x0dotel-pr\
otocol\x03\0\x0c\x01ks\x01o\x02ss\x01p\x0f\x01r\x05\x08endpoints\x07api-keys\x06\
org-id\x0e\x0cservice-names\x13resource-attributes\x10\x04\0\x0egrafana-config\x03\
\0\x11\x01r\x05\x08endpoints\x08username\x0e\x08password\x0e\x0cservice-names\x13\
resource-attributes\x10\x04\0\x0djaeger-config\x03\0\x13\x01r\x06\x04sites\x07ap\
i-keys\x0cservice-names\x0benvironment\x0e\x07version\x0e\x13resource-attributes\
\x10\x04\0\x0edatadog-config\x03\0\x15\x01r\x05\x08endpoints\x07api-keys\x07data\
sets\x0cservice-names\x13resource-attributes\x10\x04\0\x10honeycomb-config\x03\0\
\x17\x01r\x04\x08endpoints\x07api-keys\x0cservice-names\x13resource-attributes\x10\
\x04\0\x0fnewrelic-config\x03\0\x19\x01r\x04\x08endpoints\x07headers\x10\x0cserv\
ice-names\x13resource-attributes\x10\x04\0\x13generic-otlp-config\x03\0\x1b\x01q\
\x06\x07grafana\x01\x12\0\x06jaeger\x01\x14\0\x07datadog\x01\x16\0\x09honeycomb\x01\
\x18\0\x08newrelic\x01\x1a\0\x0cgeneric-otlp\x01\x1c\0\x04\0\x0dotel-provider\x03\
\0\x1d\x01r\x02\x08provider\x1e\x08protocol\x0d\x04\0\x0botel-config\x03\0\x1f\x01\
@\0\0\x20\x04\0\x0fget-otel-config\x01!\x03\0/wasmcp:otel-exporter/otel-provider\
-config@0.1.0\x05\0\x01B\x05\x01r\x02\x07secondsw\x0bnanosecondsy\x04\0\x08datet\
ime\x03\0\0\x01@\0\0\x01\x04\0\x03now\x01\x02\x04\0\x0aresolution\x01\x02\x03\0\x1c\
wasi:clocks/wall-clock@0.2.0\x05\x01\x02\x03\0\x01\x08datetime\x01B-\x02\x03\x02\
\x01\x02\x04\0\x08datetime\x03\0\0\x01s\x04\0\x08trace-id\x03\0\x02\x01s\x04\0\x07\
span-id\x03\0\x04\x01n\x01\x07sampled\x04\0\x0btrace-flags\x03\0\x06\x01o\x02ss\x01\
p\x08\x04\0\x0btrace-state\x03\0\x09\x01r\x05\x08trace-id\x03\x07span-id\x05\x0b\
trace-flags\x07\x09is-remote\x7f\x0btrace-state\x0a\x04\0\x0cspan-context\x03\0\x0b\
\x01m\x05\x06client\x06server\x08producer\x08consumer\x08internal\x04\0\x09span-\
kind\x03\0\x0d\x01s\x04\0\x03key\x03\0\x0f\x01ps\x01p\x7f\x01pu\x01px\x01q\x08\x06\
string\x01s\0\x04bool\x01\x7f\0\x03f64\x01u\0\x03s64\x01x\0\x0cstring-array\x01\x11\
\0\x0abool-array\x01\x12\0\x09f64-array\x01\x13\0\x09s64-array\x01\x14\0\x04\0\x05\
value\x03\0\x15\x01r\x02\x03key\x10\x05value\x16\x04\0\x09key-value\x03\0\x17\x01\
p\x18\x01r\x03\x04names\x04time\x01\x0aattributes\x19\x04\0\x05event\x03\0\x1a\x01\
r\x02\x0cspan-context\x0c\x0aattributes\x19\x04\0\x04link\x03\0\x1c\x01q\x03\x05\
unset\0\0\x02ok\0\0\x05error\x01s\0\x04\0\x06status\x03\0\x1e\x01ks\x01r\x04\x04\
names\x07version\x20\x0aschema-url\x20\x0aattributes\x19\x04\0\x15instrumentatio\
n-scope\x03\0!\x01p\x1b\x01p\x1d\x01r\x0e\x0cspan-context\x0c\x0eparent-span-ids\
\x09span-kind\x0e\x04names\x0astart-time\x01\x08end-time\x01\x0aattributes\x19\x06\
events#\x05links$\x06status\x1f\x15instrumentation-scope\"\x12dropped-attributes\
y\x0edropped-eventsy\x0ddropped-linksy\x04\0\x09span-data\x03\0%\x01@\x02\x04spa\
n&\x06parent\x0c\x01\0\x04\0\x08on-start\x01'\x01@\x01\x04span&\x01\0\x04\0\x06o\
n-end\x01(\x01@\0\0\x0c\x04\0\x14current-span-context\x01)\x04\0\x1dwasi:otel/tr\
acing@0.2.0-draft\x05\x03\x02\x03\0\x02\x0cspan-context\x01B\x11\x02\x03\x02\x01\
\x04\x04\0\x0cspan-context\x03\0\0\x04\0\x04span\x03\x01\x01k\x01\x01i\x02\x01@\x02\
\x04names\x0eparent-context\x03\0\x04\x04\0\x11[constructor]span\x01\x05\x01h\x02\
\x01@\x02\x04self\x06\x04names\x01\0\x04\0\x16[method]span.add-event\x01\x07\x01\
@\x01\x04self\x06\x01\0\x04\0\x13[method]span.finish\x01\x08\x01@\x01\x01s\x06\0\
\x01\x04\0\x0bget-context\x01\x09\x01k\x04\x01@\0\0\x0a\x04\0\x10get-current-spa\
n\x01\x0b\x04\0\x1ewasmcp:otel-exporter/api@0.1.0\x05\x05\x04\0(wasmcp:otel-expo\
rter/otel-exporter@0.1.0\x04\0\x0b\x13\x01\0\x0dotel-exporter\x03\0\0\0G\x09prod\
ucers\x01\x0cprocessed-by\x02\x0dwit-component\x070.227.1\x10wit-bindgen-rust\x06\
0.41.0";
#[inline(never)]
#[doc(hidden)]
pub fn __link_custom_section_describing_imports() {
    wit_bindgen_rt::maybe_link_cabi_realloc();
}
