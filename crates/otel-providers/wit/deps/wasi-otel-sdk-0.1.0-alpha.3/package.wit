package wasi:otel-sdk@0.1.0-alpha.3;

/// Common types used by all observability signals
///
/// Provides foundational types for OpenTelemetry telemetry data including
/// attributes, resources, and instrumentation scopes. These types are shared
/// across trace, logs, and metrics signals.
///
/// Based on the OpenTelemetry specification:
/// - Attributes: <https://opentelemetry.io/docs/specs/otel/common/attribute-naming/>
/// - Resources: <https://opentelemetry.io/docs/specs/otel/resource/semantic_conventions/>
/// - OTLP Common: <https://opentelemetry.io/docs/specs/otlp/#otlpcommon>
///
/// WASM-specific design considerations:
/// - No circular type dependencies (WIT limitation) - simplified value nesting
/// - Explicit value type variants for cross-language compatibility
/// - Schema URLs for semantic convention versioning in edge environments
interface common {
  /// Simple attribute values (no nesting to avoid circular dependency)
  variant simple-value {
    /// String value (UTF-8)
    %string(string),
    /// Boolean value
    %bool(bool),
    /// 64-bit signed integer
    int64(s64),
    /// IEEE 754 64-bit floating point
    %float64(f64),
    /// Binary data / byte sequences
    bytes(list<u8>),
  }

  /// Key-value pair for nested attributes (OTLP KeyValue)
  record key-value {
    /// Attribute name
    key: string,
    /// Simple attribute value (no nesting to avoid circularity)
    value: simple-value,
  }

  /// OpenTelemetry attribute value types (OTLP AnyValue compliant)
  variant attribute-value {
    /// String value (UTF-8)
    %string(string),
    /// Boolean value
    %bool(bool),
    /// 64-bit signed integer
    int64(s64),
    /// IEEE 754 64-bit floating point
    %float64(f64),
    /// Binary data / byte sequences
    bytes(list<u8>),
    /// Homogeneous array of strings
    array-string(list<string>),
    /// Homogeneous array of booleans
    array-bool(list<bool>),
    /// Homogeneous array of 64-bit signed integers
    array-int64(list<s64>),
    /// Homogeneous array of 64-bit floats
    array-float64(list<f64>),
    /// Nested key-value structure (OTLP kvlist_value)
    kvlist(list<key-value>),
  }

  /// Common attribute key-value pair for telemetry metadata
  record attribute {
    /// Attribute name
    key: string,
    /// Typed attribute value
    value: attribute-value,
  }

  /// Resource identification attributes
  record otel-resource {
    /// Entity identification attributes
    attributes: list<attribute>,
    /// Schema URL for semantic conventions version
    schema-url: option<string>,
  }

  /// Instrumentation scope identification
  record instrumentation-scope {
    /// Library/component name
    name: string,
    /// Library/component version
    version: option<string>,
    /// Schema URL for conventions version
    schema-url: option<string>,
    /// Scope metadata
    attributes: list<attribute>,
  }
}

/// Distributed tracing context management and W3C TraceContext utilities
///
/// Implements W3C TraceContext propagation for distributed tracing across
/// WebAssembly component boundaries. Provides context creation, parsing,
/// injection, and extraction for trace correlation.
///
/// Based on specifications:
/// - W3C TraceContext: <https://www.w3.org/TR/trace-context/>
/// - OpenTelemetry Context: <https://opentelemetry.io/docs/specs/otel/context/>
/// - OTLP Trace: <https://opentelemetry.io/docs/specs/otlp/#trace-service>
///
/// WASM-specific design considerations:
/// - Component-managed context (not thread-local) for WASM single-threaded model
/// - Explicit set/get/clear operations for cross-component context propagation
/// - Binary trace/span IDs (16/8 bytes) for efficient edge computing transmission
/// - No implicit context - all context management is explicit and deterministic
interface context {
  use common.{attribute};

  /// W3C TraceContext compliant span context for trace correlation
  record span-context {
    /// Unique trace identifier (MUST be exactly 16 bytes, W3C TraceContext)
    trace-id: list<u8>,
    /// Unique span identifier within trace (MUST be exactly 8 bytes, W3C TraceContext)
    span-id: list<u8>,
    /// W3C trace flags (1 byte: sampling, debug bits)
    trace-flags: u8,
    /// W3C TraceState header value (key=value,key=value format)
    trace-state: string,
    /// Whether context originated from external source (OpenTelemetry)
    is-remote: bool,
  }

  /// Context carriers for W3C TraceContext propagation
  record context-carrier {
    /// Context field name (e.g., "traceparent", "tracestate")
    key: string,
    /// Serialized context value (W3C format)
    value: string,
  }

  /// Context propagation result with error handling
  variant context-result {
    /// Successfully extracted or injected context
    success(span-context),
    /// No context found (not an error)
    not-found,
    /// Invalid context format or parsing error
    invalid(string),
  }

  /// Component-managed context (not parameter-passed)
  /// Set the active span context for this component
  set-active-context: func(context: span-context);

  /// Get the currently active span context
  get-active-context: func() -> option<span-context>;

  /// Clear the active context
  clear-active-context: func();

  /// W3C TraceContext propagation utilities
  /// Extract span context from context carriers
  /// Used by receiving components to continue traces
  extract-context: func(carriers: list<context-carrier>) -> context-result;

  /// Inject span context into context carriers
  /// Used by calling components to propagate traces
  inject-context: func(context: span-context, carriers: list<context-carrier>) -> list<context-carrier>;

  /// Create context carriers from span context
  /// Generates W3C TraceContext format carriers
  create-carriers: func(context: span-context) -> list<context-carrier>;

  /// Parse W3C TraceContext traceparent header format
  /// Converts "00-trace_id-span_id-flags" to span-context
  parse-traceparent: func(traceparent: string) -> context-result;

  /// Format span context as W3C TraceContext traceparent
  /// Converts span-context to "00-trace_id-span_id-flags"
  format-traceparent: func(context: span-context) -> string;

  /// Parse W3C TraceState header format
  /// Converts "key1=value1,key2=value2" to trace-state string
  parse-tracestate: func(tracestate: string) -> result<string, string>;

  /// Format trace state as W3C TraceState header
  /// Converts trace-state string to "key1=value1,key2=value2"
  format-tracestate: func(tracestate: string) -> string;

  /// Validate W3C TraceContext format compliance
  validate-traceparent: func(traceparent: string) -> result<_, string>;

  /// Generate random trace ID (16 bytes)
  generate-trace-id: func() -> list<u8>;

  /// Generate random span ID (8 bytes)
  generate-span-id: func() -> list<u8>;

  /// Create root span context (no parent)
  create-root-context: func(trace-id: list<u8>, span-id: list<u8>, trace-flags: u8) -> span-context;

  /// Create child span context from parent
  create-child-context: func(parent: span-context, span-id: list<u8>) -> span-context;

  /// Check if span context is valid
  is-valid-context: func(context: span-context) -> bool;

  /// Check if context indicates sampling
  is-sampled: func(context: span-context) -> bool;

  /// Set sampling flag in context
  set-sampled: func(context: span-context, sampled: bool) -> span-context;
}

/// Transport-agnostic export interface for OpenTelemetry signals
///
/// Defines the abstract contract that all OTLP transport implementations
/// must satisfy. Enables dynamic transport swapping
/// at component composition time without signal code changes.
///
/// Based on the OpenTelemetry specification:
/// - OTLP Protocol: <https://opentelemetry.io/docs/specs/otlp/>
/// - OTLP/HTTP: <https://opentelemetry.io/docs/specs/otlp/#otlphttp>
/// - OTLP/gRPC: <https://opentelemetry.io/docs/specs/otlp/#otlpgrpc>
///
/// WASM-specific design considerations:
/// - Transport abstraction via resource pattern
/// - Borrowed resource handles for zero-copy signal→transport communication
/// - Pre-serialized payloads reduce component boundary marshaling overhead
/// - Signal-path routing for edge environments with constrained endpoints
/// - Explicit flush/shutdown for deterministic resource cleanup in WASM
///
/// Edge computing optimizations:
/// - Minimal memory footprint - signals share single transport instance
/// - Configurable batch sizes and timeouts for intermittent connectivity
interface transport {
  /// OTLP signal type for routing
  /// Maps to transport-specific paths:
  /// - HTTP: /v1/traces, /v1/logs, /v1/metrics
  /// - File: traces.jsonl, logs.jsonl, metrics.jsonl
  /// - Stdout: trace, log, metric metadata tags
  variant signal-type {
    /// Trace telemetry signal
    traces,
    /// Log telemetry signal
    logs,
    /// Metric telemetry signal
    metrics,
  }

  /// OTLP payload encoding format
  /// Maps to transport-specific content types:
  /// - HTTP: application/x-protobuf, application/json
  /// - File: .pb, .json extensions
  /// - Stdout: format metadata
  variant content-type {
    /// Protocol Buffers binary encoding
    protobuf,
    /// JSON text encoding
    json,
  }

  /// Export error details
  record export-error {
    /// Number of failed items
    failed-count: u32,
    /// Error description
    error-message: string,
  }

  /// Export operation result
  variant export-result {
    /// Export completed successfully
    success,
    /// Export failed completely
    failure(string),
    /// Export partially succeeded (some data rejected by backend)
    partial-failure(export-error),
  }

  /// Abstract transport for OTLP export
  ///
  /// Implementations handle protocol-specific details:
  /// - HTTP transport: sends to HTTP endpoints with auth/compression
  /// - gRPC transport: sends via gRPC with metadata/compression
  /// - File transport: writes to files in OTLP format
  /// - Stdout transport: writes to stdout for container logging
  ///
  /// Signals use only this abstract interface via borrow<exporter-transport>
  resource exporter-transport {
    /// Send OTLP data to transport-specific destination
    ///
    /// Type-safe signal routing and format specification using variants.
    /// Transport implementations map variants to protocol-specific values:
    /// - HTTP transport: signal-type → URL path, content-type → HTTP header
    /// - File transport: signal-type → filename, content-type → file extension
    /// - Stdout transport: signal-type + content-type → metadata tags
    ///
    /// Parameters:
    /// - signal: Type-safe signal routing (traces/logs/metrics)
    /// - payload: Serialized OTLP data (protobuf or JSON bytes)
    /// - format: Type-safe encoding format (protobuf/json)
    ///
    /// Returns: export-result indicating success/failure/partial-failure
    send: func(signal: signal-type, payload: list<u8>, format: content-type) -> export-result;
    /// Flush any buffered data
    /// Forces immediate transmission of any pending data
    /// Returns true if flush succeeded
    flush: func() -> bool;
    /// Shutdown and release transport resources
    /// Consumes the transport handle (WASI pattern)
    /// Implementations should flush remaining data before shutdown
    shutdown: static func(this: exporter-transport) -> bool;
  }
}

/// Complete OpenTelemetry logging interface
///
/// Provides structured logging with automatic trace correlation, severity levels,
/// and OTLP export. Supports both structured (key-value) and unstructured (string)
/// log formats with optional trace context correlation.
///
/// Based on the OpenTelemetry specification:
/// - Logs API: <https://opentelemetry.io/docs/specs/otel/logs/api/>
/// - Logs SDK: <https://opentelemetry.io/docs/specs/otel/logs/sdk/>
/// - OTLP Logs: <https://opentelemetry.io/docs/specs/otlp/#logs>
/// - Log Data Model: <https://opentelemetry.io/docs/specs/otel/logs/data-model/>
///
/// WASM-specific design considerations:
/// - Component-managed context for automatic trace correlation
/// - Explicit emit() calls (no implicit batching in WASM single-threaded model)
/// - Structured log bodies via OTLP AnyValue (string/bytes/kvlist variants)
/// - Severity number enum (no free-form strings) for efficient serialization
/// - Observed timestamp captured at emit time for edge latency measurement
///
/// Edge computing optimizations:
/// - Minimal overhead - log records created on-demand, not buffered
/// - Binary log bodies reduce serialization cost in high-throughput scenarios
/// - Automatic trace/span correlation for request tracing in edge functions
/// - Severity-based filtering prevents debug logs overwhelming edge bandwidth
interface logs {
  use common.{attribute, attribute-value, otel-resource, instrumentation-scope};
  use transport.{exporter-transport, export-result};

  /// ============================================================================
  /// LOG TYPES
  /// ============================================================================
  /// Severity levels following OpenTelemetry conventions
  variant severity-number {
    /// Unspecified (0)
    unspecified,
    /// TRACE (1-4) - Fine-grained debugging events
    trace1,
    trace2,
    trace3,
    trace4,
    /// DEBUG (5-8) - Debugging events
    debug1,
    debug2,
    debug3,
    debug4,
    /// INFO (9-12) - Informational events
    info1,
    info2,
    info3,
    info4,
    /// WARN (13-16) - Warning events
    warn1,
    warn2,
    warn3,
    warn4,
    /// ERROR (17-20) - Error events
    error1,
    error2,
    error3,
    error4,
    /// FATAL (21-24) - Fatal errors
    fatal1,
    fatal2,
    fatal3,
    fatal4,
  }

  /// Log record body types (OTLP AnyValue compliant)
  variant log-body {
    /// String log message
    %string(string),
    /// Binary data
    bytes(list<u8>),
    /// Structured log data
    kvlist(list<attribute>),
  }

  /// Complete log record for export
  record log-record {
    /// Event timestamp (Unix epoch nanoseconds)
    timestamp: option<u64>,
    /// Observed timestamp (when recorded by collector)
    observed-timestamp: u64,
    /// Trace correlation - trace ID (16 bytes)
    trace-id: option<list<u8>>,
    /// Trace correlation - span ID (8 bytes)
    span-id: option<list<u8>>,
    /// W3C trace flags
    trace-flags: option<u8>,
    /// Severity text (log level)
    severity-text: option<string>,
    /// Numerical severity
    severity-number: option<severity-number>,
    /// Log message body
    body: option<log-body>,
    /// Log metadata
    attributes: list<attribute>,
    /// Event name (identifies event class/type)
    event-name: option<string>,
    /// Instrumentation scope that created this log (OTLP requirement)
    instrumentation-scope: instrumentation-scope,
  }

  /// ============================================================================
  /// LOG CONFIGURATION
  /// ============================================================================
  /// Per-signal data limits to prevent resource exhaustion
  record log-limits-config {
    /// Maximum attributes per log record
    max-attributes-per-record: u32,
    /// Maximum length of attribute values
    attribute-value-length-limit: u32,
    /// Maximum total attributes per log record
    log-attribute-count-limit: u32,
  }

  /// ============================================================================
  /// LOG API - Leverages component-managed context from common interface
  /// ============================================================================
  /// Telemetry provider handle types
  /// These are opaque handles to provider instances
  type logger = u32;

  /// Logger provider resource for structured logging
  /// Creates and manages logger instances
  resource logger-provider {
    /// Create a new logger provider with optional configuration
    /// If not provided, uses defaults: standard limits (128 attributes)
    constructor(limits: option<log-limits-config>, service-resource: option<otel-resource>);
    /// Get a logger for the given instrumentation scope
    get-logger: func(name: string, version: option<string>, schema-url: option<string>, attributes: list<attribute>) -> logger;
    /// Emit a log record with correlation to active trace context
    /// Uses component-managed context for trace correlation
    emit: func(logger: logger, severity-number: option<severity-number>, severity-text: option<string>, body: option<log-body>, attributes: list<attribute>, timestamp: option<u64>) -> log-record;
    /// Check if logging is enabled (optimization)
    logger-enabled: func(logger: logger) -> bool;
    /// Force flush all pending log records (OTEL: LoggerProvider.forceFlush())
    /// Returns true if flush succeeded
    force-flush: func() -> bool;
    /// Shutdown the provider and flush all pending log records (OTEL: LoggerProvider.shutdown())
    /// Consumes the provider resource (WASI pattern)
    shutdown: static func(this: logger-provider) -> bool;
  }

  /// ============================================================================
  /// LOG EXPORT - Signal-specific export functionality (OTLP /v1/logs)
  /// ============================================================================
  /// Log exporter resource for OTLP log export
  /// Handles batching and export - completely transport-agnostic
  /// Works with any transport implementation (HTTP, gRPC, file, stdout)
  resource log-exporter {
    /// Create log exporter
    constructor();
    /// Add log records to internal batch (does not trigger export)
    add-logs: func(logs: list<log-record>);
    /// Set resource information for OTLP export
    set-resource: func(service-resource: otel-resource);
    /// Export accumulated log records using the provided abstract transport
    /// Serializes logs to OTLP format and sends via transport
    /// Non-consuming - exporter can be reused for multiple batches
    export-batch: func(transport: borrow<exporter-transport>) -> export-result;
    /// Force flush any pending log records using the provided transport
    force-flush: func(transport: borrow<exporter-transport>) -> bool;
    /// Shutdown the exporter and flush remaining data
    /// Exports any remaining logs before cleanup (OTEL: exporter.shutdown())
    /// Consumes the exporter handle (WASI pattern)
    shutdown: static func(this: log-exporter, transport: borrow<exporter-transport>) -> bool;
  }

  /// Convert severity level to numeric value for OTLP compliance
  severity-to-number: func(severity: severity-number) -> u8;

  /// Serialize log records to OTLP protobuf format
  /// Returns raw protobuf bytes ready for transport
  /// Used internally by log-exporter.export-batch()
  serialize-logs-protobuf: func(logs: list<log-record>, service-resource: otel-resource) -> result<list<u8>, string>;

  /// Serialize log records to OTLP JSON format
  /// Returns raw JSON bytes ready for transport
  /// Used internally by log-exporter.export-batch()
  serialize-logs-json: func(logs: list<log-record>, service-resource: otel-resource) -> result<list<u8>, string>;
}

/// Complete OpenTelemetry metrics interface
///
/// Provides metrics collection capabilities including meter providers, instrument
/// creation (counter, histogram, gauge, up-down-counter), measurement recording,
/// aggregation, and OTLP export. Enables performance monitoring and resource
/// utilization tracking in WebAssembly components.
///
/// Based on the OpenTelemetry specification:
/// - Metrics API: <https://opentelemetry.io/docs/specs/otel/metrics/api/>
/// - Metrics SDK: <https://opentelemetry.io/docs/specs/otel/metrics/sdk/>
/// - OTLP Metrics: <https://opentelemetry.io/docs/specs/otlp/#metrics>
/// - Metric Data Model: <https://opentelemetry.io/docs/specs/otel/metrics/data-model/>
///
/// WASM-specific design considerations:
/// - Explicit instrument creation and measurement recording (no callbacks in WASM)
/// - Push-based aggregation model (no background aggregation threads)
/// - Configurable exemplar sampling for trace correlation without excessive overhead
/// - Pre-aggregated data points reduce memory footprint in constrained environments
/// - Delta vs cumulative temporality configurable per deployment scenario
///
/// Edge computing optimizations:
/// - Minimal memory overhead - configurable attribute/exemplar limits per data point
/// - Efficient histogram bucketing reduces bandwidth for distribution data
/// - Exemplar trace correlation enables end-to-end request performance analysis
/// - Aggregation temporality choice: delta (bandwidth) vs cumulative (reliability)
/// - Instrument-level enablement checks prevent unnecessary measurement overhead
interface metrics {
  use common.{attribute, attribute-value, otel-resource, instrumentation-scope};
  use transport.{exporter-transport, export-result};

  /// ============================================================================
  /// METRIC TYPES
  /// ============================================================================
  /// Metric instrument types following OpenTelemetry conventions
  variant instrument-kind {
    /// Counter - monotonically increasing values
    counter,
    /// UpDownCounter - values that can increase and decrease
    up-down-counter,
    /// Histogram - distribution of measurements
    histogram,
    /// Gauge - current value at a point in time
    gauge,
  }

  /// Aggregation temporality for metric data points
  variant aggregation-temporality {
    /// Delta - measurements since last export
    delta,
    /// Cumulative - measurements since process start
    cumulative,
  }

  /// Metric data point value types
  variant metric-value {
    /// 64-bit signed integer value
    int64(s64),
    /// IEEE 754 64-bit floating point value
    %float64(f64),
  }

  /// Histogram bucket boundary and count
  record histogram-bucket {
    /// Upper boundary (exclusive, +Inf for last bucket)
    upper-bound: f64,
    /// Count of measurements in this bucket
    count: u64,
  }

  /// Histogram data with distribution information
  record histogram-data {
    /// Total count of measurements
    count: u64,
    /// Sum of all measurements (optional)
    sum: option<f64>,
    /// Minimum measurement (optional)
    min: option<f64>,
    /// Maximum measurement (optional)
    max: option<f64>,
    /// Histogram buckets with counts
    buckets: list<histogram-bucket>,
  }

  /// Exemplar - sample measurement with trace context
  record exemplar {
    /// Measurement value
    value: f64,
    /// Measurement timestamp (Unix epoch nanoseconds)
    timestamp: u64,
    /// Trace ID for correlation (16 bytes)
    trace-id: option<list<u8>>,
    /// Span ID for correlation (8 bytes)
    span-id: option<list<u8>>,
    /// Exemplar attributes
    attributes: list<attribute>,
  }

  /// Complete metric data point for export
  record metric-data-point {
    /// Data point start time (Unix epoch nanoseconds)
    start-time: u64,
    /// Data point timestamp (Unix epoch nanoseconds)
    timestamp: u64,
    /// Metric value (counter, gauge, etc.)
    value: option<metric-value>,
    /// Histogram distribution data
    histogram: option<histogram-data>,
    /// Data point attributes (series identity)
    attributes: list<attribute>,
    /// Sample measurements with trace context
    exemplars: list<exemplar>,
  }

  /// Complete metric for export
  record metric-data {
    /// Metric name (should be low cardinality)
    name: string,
    /// Metric description
    description: option<string>,
    /// Metric unit (e.g., "ms", "bytes", "1")
    unit: option<string>,
    /// Instrument type
    kind: instrument-kind,
    /// Aggregation temporality
    temporality: aggregation-temporality,
    /// Metric data points
    data-points: list<metric-data-point>,
    /// Instrumentation scope that created this metric (OTLP requirement)
    instrumentation-scope: instrumentation-scope,
  }

  /// ============================================================================
  /// METRIC CONFIGURATION
  /// ============================================================================
  /// Per-signal data limits to prevent resource exhaustion
  record metric-limits-config {
    /// Maximum attributes per metric data point
    max-attributes-per-data-point: u32,
    /// Maximum length of attribute values
    attribute-value-length-limit: u32,
    /// Maximum total attributes per metric
    metric-attribute-count-limit: u32,
    /// Maximum number of exemplars per data point
    max-exemplars-per-data-point: u32,
  }

  /// ============================================================================
  /// METRIC API - Leverages component-managed context from common interface
  /// ============================================================================
  /// Telemetry provider handle types
  /// These are opaque handles to provider instances
  type instrument = u32;

  /// Meter provider resource for metrics collection
  /// Creates and manages meter instances
  resource meter-provider {
    /// Create a new meter provider with optional configuration
    /// If not provided, uses defaults: standard limits (128 attributes, 128 exemplars)
    constructor(limits: option<metric-limits-config>, service-resource: option<otel-resource>);
    /// Get a meter for the given instrumentation scope
    get-meter: func(name: string, version: option<string>, schema-url: option<string>, attributes: list<attribute>) -> meter;
    /// Force flush all pending metrics (OTEL: MeterProvider.forceFlush())
    /// Returns true if flush succeeded
    force-flush: func() -> bool;
    /// Shutdown the provider and flush all pending metrics (OTEL: MeterProvider.shutdown())
    /// Consumes the provider resource (WASI pattern)
    shutdown: static func(this: meter-provider) -> bool;
  }

  /// Meter resource for metrics instrumentation
  /// Creates instruments and records measurements
  resource meter {
    /// Create a counter instrument
    create-counter: func(name: string, description: option<string>, unit: option<string>) -> instrument;
    /// Create an up-down counter instrument
    create-up-down-counter: func(name: string, description: option<string>, unit: option<string>) -> instrument;
    /// Create a histogram instrument
    create-histogram: func(name: string, description: option<string>, unit: option<string>) -> instrument;
    /// Create a gauge instrument
    create-gauge: func(name: string, description: option<string>, unit: option<string>) -> instrument;
    /// Record a measurement on an instrument
    record-measurement: func(instrument: instrument, value: f64, attributes: list<attribute>);
    /// Check if this meter is enabled (optimization)
    enabled: func() -> bool;
  }

  /// ============================================================================
  /// METRIC EXPORT - Signal-specific export functionality (OTLP /v1/metrics)
  /// ============================================================================
  /// Metric exporter resource for OTLP metric export
  /// Handles batching and export - completely transport-agnostic
  /// Works with any transport implementation (HTTP, gRPC, file, stdout)
  resource metric-exporter {
    /// Create metric exporter
    constructor();
    /// Add metrics to internal batch (does not trigger export)
    add-metrics: func(metrics: list<metric-data>);
    /// Set resource information for OTLP export
    set-resource: func(service-resource: otel-resource);
    /// Export accumulated metrics using the provided abstract transport
    /// Serializes metrics to OTLP format and sends via transport
    /// Non-consuming - exporter can be reused for multiple batches
    export-batch: func(transport: borrow<exporter-transport>) -> export-result;
    /// Force flush any pending metrics using the provided transport
    force-flush: func(transport: borrow<exporter-transport>) -> bool;
    /// Shutdown the exporter and flush remaining data
    /// Exports any remaining metrics before cleanup (OTEL: exporter.shutdown())
    /// Consumes the exporter handle (WASI pattern)
    shutdown: static func(this: metric-exporter, transport: borrow<exporter-transport>) -> bool;
  }

  /// Serialize metrics to OTLP protobuf format
  /// Returns raw protobuf bytes ready for transport
  /// Used internally by metric-exporter.export-batch()
  serialize-metrics-protobuf: func(metrics: list<metric-data>, service-resource: otel-resource) -> result<list<u8>, string>;

  /// Serialize metrics to OTLP JSON format
  /// Returns raw JSON bytes ready for transport
  /// Used internally by metric-exporter.export-batch()
  serialize-metrics-json: func(metrics: list<metric-data>, service-resource: otel-resource) -> result<list<u8>, string>;
}

/// Complete OpenTelemetry tracing interface
///
/// Provides distributed tracing capabilities including tracer providers, span
/// management, sampling configuration, and OTLP export. Enables request tracing
/// across WebAssembly component boundaries with W3C TraceContext propagation.
///
/// Based on the OpenTelemetry specification:
/// - Tracing API: <https://opentelemetry.io/docs/specs/otel/trace/api/>
/// - Tracing SDK: <https://opentelemetry.io/docs/specs/otel/trace/sdk/>
/// - OTLP Trace: <https://opentelemetry.io/docs/specs/otlp/#traces>
/// - Span Data Model: <https://opentelemetry.io/docs/specs/otel/trace/api/#span>
///
/// WASM-specific design considerations:
/// - Resource-based span lifecycle (static finish method for consumption)
/// - Component-managed context (no thread-local storage in WASM)
/// - Explicit sampling decisions (no dynamic sampling in edge environments)
/// - Batch export optimizations for constrained memory (configurable batch size)
/// - Pre-serialization to protobuf/JSON before transport boundary crossing
///
/// Edge computing optimizations:
/// - Minimal memory overhead - configurable attribute/event/link limits
/// - Efficient binary trace IDs (16 bytes) for low-bandwidth propagation
interface trace {
  use common.{attribute, attribute-value, otel-resource, instrumentation-scope};
  use context.{span-context};
  use transport.{exporter-transport, export-result};

  /// ============================================================================
  /// TRACE TYPES
  /// ============================================================================
  /// OpenTelemetry span kind classification
  variant span-kind {
    /// Default internal operation
    internal,
    /// Incoming request handler
    server,
    /// Outgoing request caller
    client,
    /// Async operation initiator (doesn't wait for response)
    producer,
    /// Async operation processor
    consumer,
  }

  /// Span completion status following OpenTelemetry conventions
  variant span-status {
    /// Default status - not explicitly set
    unset,
    /// Operation completed successfully
    ok,
    /// Operation completed with error
    error(string),
  }

  /// Timestamped event within a span
  record span-event {
    /// Event name/type identifier
    name: string,
    /// Event occurrence timestamp (Unix epoch nanoseconds)
    timestamp: u64,
    /// Event metadata
    attributes: list<attribute>,
  }

  /// Link to another span (for distributed tracing)
  record span-link {
    /// Target span context
    context: span-context,
    /// Link metadata
    attributes: list<attribute>,
  }

  /// Complete span data for export
  record span-data {
    /// Operation name (should be low cardinality)
    name: string,
    /// Span identity and propagation context
    context: span-context,
    /// Parent span ID if this is a child span
    parent-span-id: option<list<u8>>,
    /// Operation type classification
    kind: span-kind,
    /// Span start time (Unix epoch nanoseconds)
    start-time: u64,
    /// Span end time (Unix epoch nanoseconds, none if still active)
    end-time: option<u64>,
    /// Span metadata
    attributes: list<attribute>,
    /// Timestamped events within span
    events: list<span-event>,
    /// Links to related spans
    links: list<span-link>,
    /// Final span status
    status: span-status,
    /// Instrumentation scope that created this span (OTLP requirement)
    instrumentation-scope: instrumentation-scope,
    /// Number of attributes dropped due to limits (OTLP requirement)
    dropped-attributes-count: u32,
    /// Number of events dropped due to limits (OTLP requirement)
    dropped-events-count: u32,
    /// Number of links dropped due to limits (OTLP requirement)
    dropped-links-count: u32,
  }

  /// ============================================================================
  /// TRACE CONFIGURATION
  /// ============================================================================
  /// Sampling strategy configuration variants
  variant sampler-config {
    /// Sample all traces (100% sampling)
    always-on,
    /// Sample no traces (0% sampling)
    always-off,
    /// Sample based on trace ID hash ratio (0.0-1.0)
    trace-id-ratio(f64),
    /// Defer to parent span sampling decision (simplified)
    parent-based,
  }

  /// Per-signal data limits to prevent resource exhaustion
  record trace-limits-config {
    /// Maximum attributes per span
    max-attributes-per-span: u32,
    /// Maximum events per span
    max-events-per-span: u32,
    /// Maximum links per span
    max-links-per-span: u32,
    /// Maximum length of attribute values
    attribute-value-length-limit: u32,
    /// Maximum total attributes per span
    span-attribute-count-limit: u32,
  }

  /// ============================================================================
  /// TRACE API - Leverages component-managed context from common interface
  /// ============================================================================
  /// Telemetry provider handle types
  /// These are opaque handles to provider instances
  type tracer = u32;

  /// Span resource for distributed tracing
  /// Follows WASI resource lifecycle with static finish method
  resource span {
    /// Get the span's context for propagation
    get-context: func() -> span-context;
    /// Check if span is recording telemetry data
    is-recording: func() -> bool;
    /// Add or update a span attribute
    set-attribute: func(key: string, value: attribute-value);
    /// Add a timestamped event to the span
    add-event: func(name: string, attributes: list<attribute>, timestamp: option<u64>);
    /// Add a link to another span (after span creation)
    /// Links added after creation may not be considered by samplers
    add-link: func(link: span-link);
    /// Set the span's final status
    set-status: func(status: span-status);
    /// Update the span's operation name
    update-name: func(name: string);
    /// Record an exception as a span event
    record-exception: func(exception-type: string, message: string, stacktrace: option<string>);
    /// End the span and return complete span data
    /// This consumes the span resource (WASI pattern)
    /// Must be called to complete telemetry collection (OTEL: span.end())
    end: static func(this: span, end-time: option<u64>) -> span-data;
  }

  /// Tracer provider resource for distributed tracing
  /// Creates and manages tracer instances
  resource tracer-provider {
    /// Create a new tracer provider with optional configuration
    /// If not provided, uses defaults: AlwaysOn sampling, standard limits (128/128/128)
    constructor(sampler: option<sampler-config>, limits: option<trace-limits-config>, service-resource: option<otel-resource>);
    /// Get a tracer for the given instrumentation scope
    get-tracer: func(name: string, version: option<string>, schema-url: option<string>, attributes: list<attribute>) -> tracer;
    /// Create a new span using active context from common interface
    /// No context parameter needed - uses component-managed context
    start-span: func(tracer: tracer, name: string, kind: span-kind, attributes: list<attribute>, links: list<span-link>, start-time: option<u64>) -> span;
    /// Check if tracing is enabled (optimization)
    tracer-enabled: func(tracer: tracer) -> bool;
    /// Force flush all pending spans (OTEL: TracerProvider.forceFlush())
    /// Returns true if flush succeeded
    force-flush: func() -> bool;
    /// Shutdown the provider and flush all pending spans (OTEL: TracerProvider.shutdown())
    /// Consumes the provider resource (WASI pattern)
    shutdown: static func(this: tracer-provider) -> bool;
  }

  /// ============================================================================
  /// TRACE EXPORT - Signal-specific export functionality (OTLP /v1/traces)
  /// ============================================================================
  /// Serialization error types for OTLP encoding
  variant serialization-error {
    /// JSON serialization failed
    json-encoding(string),
    /// Protobuf encoding failed
    protobuf-encoding(string),
    /// Invalid span data structure
    invalid-data(string),
  }

  /// Trace exporter resource for OTLP trace export
  /// Handles batching and export - completely transport-agnostic
  /// Works with any transport implementation (HTTP, gRPC, file, stdout)
  resource trace-exporter {
    /// Create trace exporter with optional batch size configuration
    /// If batch-size is not specified, defaults to 512 spans
    /// Maximum allowed batch size is 10,000 spans
    constructor(batch-size: option<u32>);
    /// Add spans to internal batch (does not trigger export)
    add-spans: func(spans: list<span-data>);
    /// Set resource information for OTLP export
    set-resource: func(service-resource: otel-resource);
    /// Export accumulated spans using the provided abstract transport
    /// Serializes spans to OTLP format and sends via transport
    /// Non-consuming - exporter can be reused for multiple batches
    export-batch: func(transport: borrow<exporter-transport>) -> export-result;
    /// Force flush any pending spans using the provided transport
    force-flush: func(transport: borrow<exporter-transport>) -> bool;
    /// Shutdown the exporter and flush remaining data
    /// Exports any remaining spans before cleanup (OTEL: exporter.shutdown())
    /// Consumes the exporter handle (WASI pattern)
    shutdown: static func(this: trace-exporter, transport: borrow<exporter-transport>) -> bool;
  }

  /// Serialize spans to OTLP protobuf format
  /// Returns raw protobuf bytes ready for transport
  /// Used internally by trace-exporter.export-batch()
  serialize-spans-protobuf: func(spans: list<span-data>, service-resource: otel-resource) -> result<list<u8>, serialization-error>;

  /// Serialize spans to OTLP JSON format
  /// Returns raw JSON bytes ready for transport
  /// Used internally by trace-exporter.export-batch()
  serialize-spans-json: func(spans: list<span-data>, service-resource: otel-resource) -> result<list<u8>, serialization-error>;
}

/// HTTP-specific transport configuration for OTLP export
///
/// Provides HTTP/HTTPS transport factory and configuration for OTLP/HTTP protocol.
/// Implements the abstract `transport` interface with HTTP-specific features including
/// authentication, compression, retry logic, and timeout management.
///
/// Based on the OpenTelemetry specification:
/// - OTLP/HTTP: <https://opentelemetry.io/docs/specs/otlp/#otlphttp>
/// - OTLP HTTP Request: <https://opentelemetry.io/docs/specs/otlp/#otlphttp-request>
/// - Authentication: <https://opentelemetry.io/docs/specs/otlp/#authentication>
///
/// WASM-specific design considerations:
/// - Factory pattern returns abstract transport
/// - Configuration validated at transport creation time (fail-fast)
/// - Uses WASI HTTP for outgoing requests
/// - Stateless HTTP client - all state in resource handle
/// - Configurable compression (gzip)
interface http-transport {
  use transport.{exporter-transport, export-result, content-type};

  /// ============================================================================
  /// HTTP PROTOCOL CONFIGURATION
  /// ============================================================================
  /// Compression options for HTTP requests
  variant compression-type {
    /// No compression - send raw payload
    none,
    /// Gzip compression - reduces bandwidth, adds CPU overhead
    gzip,
  }

  /// ============================================================================
  /// HTTP AUTHENTICATION CONFIGURATION
  /// ============================================================================
  /// HTTP header key-value pair for custom headers
  record header-pair {
    /// Header name (e.g., "Authorization", "X-Custom-Header")
    key: string,
    /// Header value
    value: string,
  }

  /// HTTP Basic authentication credentials
  record basic-auth-config {
    /// Username for HTTP Basic auth
    username: string,
    /// Password for HTTP Basic auth (consider using secure storage)
    password: string,
  }

  /// Bearer token authentication configuration
  record bearer-token-config {
    /// Bearer token value (e.g., API key, JWT)
    token: string,
  }

  /// Authentication configuration variants
  variant auth-config {
    /// No authentication required
    none,
    /// HTTP Basic authentication (RFC 7617)
    basic(basic-auth-config),
    /// Bearer token authentication (RFC 6750)
    bearer(bearer-token-config),
    /// Custom headers for proprietary auth mechanisms
    headers(list<header-pair>),
  }

  /// ============================================================================
  /// RETRY AND RELIABILITY CONFIGURATION
  /// ============================================================================
  /// Retry configuration for transient failures
  record retry-config {
    /// Maximum retry attempts before giving up
    max-attempts: u32,
    /// Initial delay in milliseconds before first retry
    initial-delay-ms: u32,
    /// Maximum delay in milliseconds (for exponential backoff)
    max-delay-ms: u32,
  }

  /// ============================================================================
  /// HTTP TRANSPORT CONFIGURATION
  /// ============================================================================
  /// Complete HTTP transport configuration
  record http-config {
    /// OTLP endpoint URL (must start with http:// or https://)
    /// Example: "https://api.honeycomb.io" or "http://localhost:4318"
    endpoint: string,
    /// Authentication configuration
    authentication: auth-config,
    /// Request timeout in milliseconds
    /// Applies to connection establishment and response reception
    timeout-ms: u32,
    /// OTLP payload encoding format (protobuf or JSON)
    /// Maps to HTTP Content-Type header
    protocol: content-type,
    /// Compression type for request bodies
    compression: compression-type,
    /// Optional retry configuration
    /// If not specified, defaults to: max-attempts=3, initial-delay=1000ms, max-delay=32000ms
    retry: option<retry-config>,
  }

  /// ============================================================================
  /// HTTP TRANSPORT FACTORY
  /// ============================================================================
  /// HTTP transport creation errors
  variant http-transport-error {
    /// Endpoint URL is empty or missing
    empty-endpoint,
    /// Endpoint URL is malformed (must start with http:// or https://)
    invalid-endpoint,
    /// Timeout configuration is invalid (must be > 0)
    invalid-timeout,
    /// General configuration error with details
    config-error(string),
  }

  /// Create HTTP transport from configuration
  ///
  /// Validates the HTTP configuration and returns an abstract exporter-transport
  /// resource that implements the transport interface. The returned transport
  /// can be shared across all signals (traces, logs, metrics).
  ///
  /// # Configuration Validation
  /// - Endpoint must be non-empty and start with http:// or https://
  /// - Timeout must be greater than zero
  /// - Authentication credentials are validated for proper format
  ///
  /// # Returns
  /// - Ok(exporter-transport): Successfully configured HTTP transport
  /// - Err(http-transport-error): Configuration validation failed
  ///
  /// # Example Usage
  /// ```
  /// let config = http-config {
  ///   endpoint: "https://api.honeycomb.io",
  ///   authentication: auth-config::bearer(bearer-token-config {
  ///     token: "your-api-key"
  ///   }),
  ///   timeout-ms: 10000,
  ///   protocol: content-type::protobuf,
  ///   compression: compression-type::gzip,
  ///   retry: some(retry-config {
  ///     max-attempts: 3,
  ///     initial-delay-ms: 1000,
  ///     max-delay-ms: 32000,
  ///   })
  /// };
  ///
  /// let transport = create-http-transport(config)?;
  /// // Use transport with all signals
  /// trace-exporter.export-batch(&transport);
  /// log-exporter.export-batch(&transport);
  /// metric-exporter.export-batch(&transport);
  /// ```
  create-http-transport: func(config: http-config) -> result<exporter-transport, http-transport-error>;
}

/// World definitions for OpenTelemetry observability component composition
///
/// This file defines WebAssembly Component Model worlds for signal-specific
/// and multi-signal component composition following Component Model best practices.
/// Uses transport abstraction for complete protocol independence.
///
/// Architecture:
/// - Transport components: Export abstract `transport` interface
///   - HTTP transport: Separate component with HTTP-specific config
///   - gRPC transport: Separate component with gRPC-specific config
///   - File transport: Separate component for file-based export
///   - Stdout transport: Separate component for container logging
/// - Signal SDKs: Import only abstract `transport` interface
/// - WAC composition: Wires concrete transport → abstract imports
///
/// Key benefit: Signals know nothing about HTTP/gRPC/file details,
/// enabling dynamic transport swapping at composition time
/// ============================================================================
/// TRANSPORT COMPONENT WORLDS
/// ============================================================================
/// HTTP transport component world
/// Implements OTLP/HTTP transport with authentication, compression, and retry
/// Exports both abstract transport interface and HTTP-specific configuration
world otel-http-transport {
  import wasi:io/poll@0.2.0;
  import wasi:clocks/monotonic-clock@0.2.0;
  import wasi:io/error@0.2.0;
  import wasi:io/streams@0.2.0;
  import wasi:http/types@0.2.0;
  import wasi:http/outgoing-handler@0.2.0;

  export transport;
  export http-transport;
}
/// ============================================================================
/// CONTEXT PROVIDER WORLD
/// ============================================================================
/// Context provider component world
/// Implements W3C TraceContext utilities and trace/span ID generation
/// Exported as standalone component for WAC composition with signal components
world context-provider {
  import wasi:random/random@0.2.0;
  import common;

  export context;
}
/// ============================================================================
/// SINGLE-SIGNAL WORLDS
/// ============================================================================
/// Tracing-only SDK component world
/// Provides tracing providers and span management capabilities
/// Completely transport-agnostic - works with any transport implementation
world trace-sdk {
  import common;
  import context;
  import transport;

  export trace;
}
/// Tracing-instrumented application world
world trace-app {
  import common;
  import context;
  import transport;
  import trace;
}
/// Logging-only SDK component world
/// Provides logging providers and structured logging capabilities
/// Completely transport-agnostic - works with any transport implementation
world logs-sdk {
  import common;
  import transport;

  export logs;
}
/// Logging-instrumented application world
world logs-app {
  import common;
  import transport;
  import logs;
}
/// Metrics-only SDK component world
/// Provides meter providers and instrumentation capabilities
/// Completely transport-agnostic - works with any transport implementation
world metrics-sdk {
  import common;
  import transport;

  export metrics;
}
/// Metrics-instrumented application world
world metrics-app {
  import common;
  import transport;
  import metrics;
}
/// ============================================================================
/// MULTI-SIGNAL WORLDS
/// ============================================================================
/// Complete OpenTelemetry SDK component world
/// Provides all observability signals with unified export
/// Completely transport-agnostic - works with any transport implementation
world otel-sdk {
  import common;
  import context;
  import transport;

  export trace;
  export logs;
  export metrics;
}
