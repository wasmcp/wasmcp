package wasmcp:storage@0.1.0;

/// Key-value storage interface with typed value support
///
/// Provides a typed abstraction over wasi:keyvalue that:
/// - Abstracts away version differences (draft vs draft2)
/// - Stores type metadata with each value for runtime type safety
/// - Provides both generic and typed convenience methods
interface kv {
    use wasi:keyvalue/store.{error, key-response};
    use wasi:keyvalue/batch;
    use wasi:keyvalue/atomics;

    /// A typed value that can be stored in the key-value store.
    ///
    /// Implementation stores a type tag (1 byte) followed by the serialized data.
    /// This enables runtime type safety and generic introspection.
    variant typed-value {
        /// UTF-8 string value
        as-string(string),

        /// JSON string (validated for JSON syntax on write)
        as-json(string),

        /// Unsigned 64-bit integer
        as-u64(u64),

        /// Signed 64-bit integer
        as-s64(s64),

        /// Boolean value
        as-bool(bool),

        /// Raw binary data
        as-bytes(list<u8>)
    }

    /// A bucket is a collection of key-value pairs with type tracking
    resource bucket {
        // ========== Generic API (for introspection/unknown types) ==========

        /// Get a typed value by key
        ///
        /// Returns the value with its type information. Useful for generic
        /// tooling that doesn't know types ahead of time.
        ///
        /// Returns `Ok(none)` if key doesn't exist.
        /// Returns `Err` if stored data is malformed.
        get: func(key: string) -> result<option<typed-value>, error>;

        /// Set a key to a typed value
        ///
        /// Stores the value with a type tag for later retrieval.
        set: func(key: string, value: typed-value) -> result<_, error>;

        // ========== Typed Convenience API (validates type tags) ==========

        /// Get a JSON string value
        ///
        /// Returns error if the stored value is not tagged as JSON.
        get-json: func(key: string) -> result<option<string>, error>;

        /// Set a JSON string value (validates JSON syntax)
        set-json: func(key: string, json: string) -> result<_, error>;

        /// Get a UTF-8 string value
        ///
        /// Returns error if the stored value is not tagged as string.
        get-string: func(key: string) -> result<option<string>, error>;

        /// Set a UTF-8 string value
        set-string: func(key: string, value: string) -> result<_, error>;

        /// Get a u64 value
        ///
        /// Returns error if the stored value is not tagged as u64.
        get-u64: func(key: string) -> result<option<u64>, error>;

        /// Set a u64 value
        set-u64: func(key: string, value: u64) -> result<_, error>;

        /// Get an s64 value
        ///
        /// Returns error if the stored value is not tagged as s64.
        get-s64: func(key: string) -> result<option<s64>, error>;

        /// Set an s64 value
        set-s64: func(key: string, value: s64) -> result<_, error>;

        /// Get a boolean value
        ///
        /// Returns error if the stored value is not tagged as bool.
        get-bool: func(key: string) -> result<option<bool>, error>;

        /// Set a boolean value
        set-bool: func(key: string, value: bool) -> result<_, error>;

        /// Get raw bytes
        ///
        /// Returns error if the stored value is not tagged as bytes.
        get-bytes: func(key: string) -> result<option<list<u8>>, error>;

        /// Set raw bytes
        set-bytes: func(key: string, value: list<u8>) -> result<_, error>;

        // ========== Batch Operations ==========

        /// Get multiple typed values in a single operation
        ///
        /// Returns tuples of (key, typed-value) for each requested key.
        /// Missing keys return `none` for the value in that tuple.
        ///
        /// Uses native wasi:keyvalue/batch under the hood.
        get-many: func(keys: list<string>) -> result<list<option<tuple<string, typed-value>>>, error>;

        /// Set multiple typed values in a single operation
        ///
        /// Uses native wasi:keyvalue/batch under the hood.
        set-many: func(pairs: list<tuple<string, typed-value>>) -> result<_, error>;

        /// Delete multiple keys in a single operation
        ///
        /// Uses native wasi:keyvalue/batch under the hood.
        delete-many: func(keys: list<string>) -> result<_, error>;

        // ========== Common Operations ==========

        /// Delete a key
        ///
        /// No error if key does not exist.
        delete: func(key: string) -> result<_, error>;

        /// Check if a key exists
        exists: func(key: string) -> result<bool, error>;

        /// List all keys with optional pagination
        ///
        /// Note: This is an expensive operation and should be used judiciously.
        /// Keys are not guaranteed to be returned in any particular order.
        /// May show an out-of-date list if there are concurrent writes.
        list-keys: func(cursor: option<u64>) -> result<key-response, error>;

        // ========== Atomic Operations ==========

        /// Atomically increment a u64 counter by delta, returning the new value
        ///
        /// If the key doesn't exist, creates it with value = delta.
        /// If the key exists but is not a u64, returns an error.
        ///
        /// Uses wasi:keyvalue/atomics under the hood when available.
        /// Fallback: May use read-modify-write (non-atomic) if runtime doesn't support atomics.
        increment: func(key: string, delta: u64) -> result<u64, error>;
    }

    /// Open or create a bucket
    ///
    /// The identifier is passed to the underlying KV implementation.
    open: func(identifier: string) -> result<bucket, error>;
}
