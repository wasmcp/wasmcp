//! Configuration management for JWT authentication

use crate::error::{AuthError, Result};
use serde::{Deserialize, Serialize};

/// Main configuration structure
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Config {
    /// JWT provider configuration
    pub provider: JwtProvider,

    /// Optional policy for fine-grained authorization
    pub policy: Option<String>,

    /// Optional policy data (external data for policy evaluation)
    pub policy_data: Option<String>,
}

/// JWT provider configuration
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct JwtProvider {
    /// JWT issuer URL (optional - empty means no issuer validation)
    pub issuer: String,

    /// Static public key (PEM format) - mutually exclusive with jwks_uri
    pub public_key: Option<String>,

    /// JWKS URI for dynamic key fetching
    pub jwks_uri: Option<String>,

    /// Expected audience(s) (required for security)
    pub audience: Vec<String>,

    /// JWT signing algorithm (defaults to RS256)
    pub algorithm: Option<String>,

    /// Required scopes for all requests
    pub required_scopes: Option<Vec<String>>,
}

impl Config {
    /// Load configuration from environment variables
    pub fn load() -> Result<Self> {
        let issuer = get_env("JWT_ISSUER").unwrap_or_default();

        // Normalize issuer
        let issuer = if !issuer.is_empty() {
            normalize_issuer(issuer)?
        } else {
            String::new()
        };

        // Load public key or JWKS URI (mutually exclusive)
        let public_key = get_env("JWT_PUBLIC_KEY");
        let jwks_uri = get_env("JWT_JWKS_URI");

        // Require at least one
        if public_key.is_none() && jwks_uri.is_none() {
            return Err(AuthError::Configuration(
                "Either JWT_PUBLIC_KEY or JWT_JWKS_URI is required".to_string(),
            ));
        }

        // Don't allow both
        if public_key.is_some() && jwks_uri.is_some() {
            return Err(AuthError::Configuration(
                "Cannot specify both JWT_PUBLIC_KEY and JWT_JWKS_URI".to_string(),
            ));
        }

        // Load audience (optional for dynamic registration scenarios)
        let audience: Vec<String> = get_env("JWT_AUDIENCE")
            .map(|audience_str| {
                audience_str
                    .split(',')
                    .map(|aud| aud.trim().to_string())
                    .filter(|aud| !aud.is_empty())
                    .collect()
            })
            .unwrap_or_default();

        // Load algorithm (optional, defaults to RS256)
        let algorithm = get_env("JWT_ALGORITHM").and_then(|alg| {
            // Validate algorithm
            let valid_algorithms = [
                "HS256", "HS384", "HS512", "RS256", "RS384", "RS512", "ES256", "ES384", "PS256",
                "PS384", "PS512",
            ];

            if !valid_algorithms.contains(&alg.as_str()) {
                return None;
            }
            Some(alg)
        });

        // Load required scopes (optional)
        let required_scopes = get_env("JWT_REQUIRED_SCOPES").map(|s| {
            s.split(',')
                .map(|scope| scope.trim().to_string())
                .filter(|scope| !scope.is_empty())
                .collect()
        });

        // Load optional policy configuration
        let policy = get_env("POLICY");
        let policy_data = get_env("POLICY_DATA");

        Ok(Self {
            provider: JwtProvider {
                issuer,
                public_key,
                jwks_uri,
                audience,
                algorithm,
                required_scopes,
            },
            policy,
            policy_data,
        })
    }
}

/// Get environment variable (using WIT bindings)
fn get_env(key: &str) -> Option<String> {
    // Import will be generated by wit-bindgen
    // For now, use std::env as fallback for compilation
    std::env::var(key).ok()
}

/// Normalize issuer (handle both URLs and plain strings)
fn normalize_issuer(mut issuer: String) -> Result<String> {
    // Check if it looks like a URL
    if issuer.starts_with("http://") || issuer.starts_with("https://") {
        // For URLs, validate HTTPS
        if !issuer.starts_with("https://") {
            return Err(AuthError::Configuration(
                "URL issuers must use HTTPS".to_string(),
            ));
        }

        // Remove trailing slash from URLs
        if issuer.ends_with('/') {
            issuer.pop();
        }
    }
    // Otherwise, keep as-is (string issuer per RFC 7519)

    Ok(issuer)
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_normalize_issuer_https_url() {
        let result = normalize_issuer("https://example.com/".to_string()).unwrap();
        assert_eq!(result, "https://example.com");
    }

    #[test]
    fn test_normalize_issuer_plain_string() {
        let result = normalize_issuer("my-issuer".to_string()).unwrap();
        assert_eq!(result, "my-issuer");
    }

    #[test]
    fn test_normalize_issuer_http_fails() {
        let result = normalize_issuer("http://example.com".to_string());
        assert!(result.is_err());
    }
}
